{"pages":[{"title":"一些vim插件的使用方法","text":"tpope/vim-surround 光标在 \"Hello world!\" 中时按下 cs\"' ，则会替换双引号为单引号： 'Hello world!' 继续按下 cs' ，则会替换单引号为 标签 <q> Hello world! </q> 按下 cst\" ，则回到初始的双引号： \"Hello world!\" 要删除符号，则按下 ds\" Hello world! 当光标在hello上时，按下 ysiw] ，则会变为 [Hello] world! 这个操作为其加上了包围符号。 总结： 1.删除包围符号的命令是 ds ,后面加的字符表示要删除的符号。比如： \"Hello *world!\" ds\" Hello world! 2.替换包围符号的命令是 cs ,命令后跟两个参数，分别是被替换的符号和需要使用的符号。比如 \"Hello *world!\" cs\"' 'Hello world!' 3.添加包围符号的命令是 ys ，命令后同样跟两个参数，第一个是一个vim\"动作\"（motion）或者是一个文本对象。（motion即vim动作，比如说 w 向后一个单词。文本对象简单的来说主要是来通过一些分隔符来标识一段文本，比如 iw 就是一个文本对象，即光标下的单词。） Hello w*orld! ysiw) Hello (world)! 另外： yss 命令可以用于整行操作，忽略中间的空格。 yS 和 ySS 还能让包围内容单独一行并且加上缩进。 4.添加包围符号还有个非常好用的：在可视模式v下，按下 S 后即可添加想要添加的包围符号了。 再说一个小技巧：在包围符号为括时，输入左括号 (或者{ ,则会留一个空格 Hello w*orld! ysiw( Hello ( world )!","url":"http://honmaple.tk/articles/2015/10/vim-plugin.html","tags":"linux"},{"title":"linux下C51开发","text":"开发工具mcu8051ide 下载地址 http://sourceforge.net/projects/mcu8051ide/ 安装sdcc $ sudo pacman -S sdcc 根据README需要下载必要的依赖 REQUIRED PACKAGES: (Without these packages this program WILL NOT run) Package min. Version Where it's available tcl 8.5.9 http://www.tcl.tk/software/tcltk/downloadnow84.html tk 8.5.9 http://www.tcl.tk/software/tcltk/downloadnow84.html itcl 3.4 http://sourceforge.net/projects/incrtcl tdom 0.8 http://tdom.github.com/ tkimg 1.3 http://sourceforge.net/projects/tkimg tcllib 1.6 http://sourceforge.net/projects/tcllib Tclx 8.4 http://tclx.sourceforge.net bwidget 1.8 http://sourceforge.net/projects/tcllib 注:安装必要依赖可以下载源码包自己编译安装,因为我的是Archlinux,以下命令以Arch为主 安装tcl,tk,tcllib,bwidget $ sudo pacman -S tcl tk tcllib bwidget 安装itcl,tdom,tkimg,tclx $ yaourt -Ss itcl aur/eclipse-dltk-itcl 5.0-1 ( 3 ) incr Tcl IDE for Eclipse aur/itcl3 3.4.1-1 [ installed ] ( 1 ) Provides the extra language support needed to build large Tcl/Tk applications, version 3.4 $ yaourt -S itcl3 #具体步骤略过 $ yaourt -S tdom aur/tdom 0.8.3-1 [ installed ] ( 13 ) A fast XML/DOM/XPath package for Tcl written in C aur/tdom-git 0.8.3.r92.g363cbda-1 ( 4 ) A fast XML/DOM/XPath package for Tcl written in C $ yaourt -S tdom $ yaourt -Ss tkimg aur/tkimg 1.4.2-1 [ installed ] ( 3 ) This package enhances Tk, adding support for many other Image formats: BMP, XBM, XPM, GIF, PNG, JPEG, TIFF and postscript. $ yaourt -S tkimg $ yaourt -Ss tclx aur/tclx 8.4-4 ( 19 ) Provides OS primitives, file scanning, data records etc. for Tcl aur/tclxml 3.2-2 ( 4 ) XML support for the Tcl scripting language aur/tclxosd 0.20-2 ( 2 ) A Tcl bindings for libxosd ( On Screen Display ) $ yaourt -S tclx #这里发现一个问题，我tclx没有装但mcu8051ide也能正常使用 安装mcu8051ide 解压源码包,进入源码包目录 $ cmake . -DCMAKE_INSTALL_PREFIX = /opt/mcu8051ide/ #不要忘记\".\",后面的是要安装到的目录 $ make $ sudo make install 打开使用mcu8051ide $ cd /opt/bin $ ./mcu8051ide --check-libraries #检查依赖是否安装好 $ ./mcu8051ide #打开软件 ok,可以编写程序了 单片机烧写 使用软件gSTCISP 下载地址 安装gSTCISP 解压缩软件 $ cd gSTC-ISP $ ./configure --prefix = /opt/gSTCISP/ $ make #如果直接make会出错,cd 到src目录，vim Makefile将CFLAGS = -g -O2更改为CFLAGS = -g -O2 -I/usr/include/vte-0.0/ $ sudo make install 使用gSTCISP $ sudo gSTCISP #如果直接使用gSTCISP打开,烧写时会提示没有权限,请使用root权限打开 选择 /dev/ttyUSB0 (or 1) 和 4800 bauds 然后点击下载 ok,可以在linux系统下开发C51单片机了","url":"http://honmaple.tk/articles/2015/10/linux-C51.html","tags":"linux"},{"title":"fedora22成功安装bumblebee-nvidia","text":"有一些错误，现更正 将selinux设置为disabled # vim /etc/sysconfig/selinux 安装及必要的依赖 # dnf install -y libbsd-devel libbsd glibc-devel libX11-devel help2man autoconf git tar glib2 glib2-devel kernel-devel kernel-headers automake gcc gtk2-devel # dnf install VirtualGL # dnf install VirtualGL.i686 # 即使是在64位操作系统上，这个也是必装的 # dnf -y install http://install.linux.ncsu.edu/pub/yum/itecs/public/bumblebee/fedora22/noarch/bumblebee-release-1.2-1.noarch.rpm # dnf -y install bbswitch bumblebee # dnf -y install http://install.linux.ncsu.edu/pub/yum/itecs/public/bumblebee-nonfree/fedora22/noarch/bumblebee-nonfree-release-1.2-1.noarch.rpm # dnf -y install bumblebee-nvidia 安装完成后加入用户组 $ sudo usermod -a -G video username $ sudo usermod -a -G bumblebee username #username是用户名 启动必要服务 $ sudo systemctl enable dkms $ sudo systemctl enable bumblebeed 重启 $ reboot 测试bumblebee $ optirun glxgears -info | grep \"GL_VENDOR\"","url":"http://honmaple.tk/articles/2015/10/bumvlebee.html","tags":"linux"},{"title":"centos搭建shadowsocks服务端","text":"1.安装必要组建 # yum install build-essential autoconf libtool openssl-devel gcc -y 2.安装git # yum install git -y # git --version #安装完后查看版本 3.下载shadowsocks-libev源码包并且编译安装 $ git clone https://github.com/madeye/shadowsocks-libev.git $ cd shadowsocks-libev $ ./configure # make && make install .配置shadowsocks # nohup /usr/local/bin/ss-server -s IP地址 -p 端口 -k 密码 -m 加密方式 & 注： ip地址为当前服务器ip，端口随意，加密方式建议为aes-256-cfb 5.加入开机启动 # echo \"nohup /usr/local/bin/ss-server -s IP地址 -p 端口 -k 密码 -m 加密方式 &\" >> /etc/rc.local 6.加入防火墙 # vim /etc/sysconfig/iptables 增加 -A INPUT -m state --state NEW -m tcp -p tcp --dport 端口 -j ACCEPT 重启防火墙 # service iptables restart 7.客户端配置 下载地址 注：如果 http://sourceforge.net/ 进不去可以 http://sourceforge.jp 客户端中两个端口，一个是服务端（自己设的端口) ，另一个本地端口（默认1080），配置完成启用系统代理，并且选PAC模式 ok，就这样","url":"http://honmaple.tk/articles/2015/10/shadowsocks.html","tags":"linux"},{"title":"linux的一些操作命令","text":"字符界面播放ascii视频 $ mplayer -vo caca MovieName 打开nvidia设置 $ optirun nvidia-settings -c :8 更新google禁用 GPG 签名检查 $ sudo dnf update google-chrome-stable* --nogpgcheck 字符界面使用鼠标 $ sudo dnf install gpm $ sudo service gpm start 新字体安装 字体目录下运行 $ mkfontscale $ mkfontdir $ fc -cache -fv ssh代理 $ ssh -qTfnN -D 7070 ~@~ 安装vimdoc ./vimcdoc.sh -i 安装 ./vimcdoc.sh -u 卸载 编译Youcompleteme $ ./install.sh --clang-completer vim安装bundle插件管理 $ git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle","url":"http://honmaple.tk/articles/2015/10/linuxcommand.html","tags":"linux"},{"title":"git学习","text":"参考资料 廖雪峰Git教程 记忆一下主要内容： 安装git $ sudo dnf install git 安装后配置 $ git config --global user.name \"Your Name\" $ git config --global user.email \"email@example.com\" 创建版本库 $ mkdir git $ cd git $ mkdir \"目录名\" $ cd \"目录名\" $ git init #将该目录变成可用于git管理的仓库 git操作指令 $ git add filename #将文件添加到仓库 $ git commit -m \"注释内容\" #将文件提交到仓库，-m后面是本次提交的内容说明 $ git add file1.txt $ git add file2.txt file3.txt $ git commit -m \"add 3 files.\" #git commit 可以一次性提交多个文件 $ git status #查看仓库当前状态 $ git diff filename #查看文件修改状态 $ git log --pretty = oneline #查看提交日志 $ git reset --hard HEAD&#94; #从当前状态回退到上个版本状态 ，上上版本HEAD&#94;&#94;,100个上版本HEAD~100 $ git diff HEAD -- filename #查看工作区与版本库里的最新版本的区别 $ git checkout -- filename #让工作区文件回退到上次提交状态 $ git reset HEAD readme.txt #把暂存区的修改撤销掉 $ git rm filename #删除仓库文件 远程仓库 $ ssh-keygen -t rsa -C \"youremail@example.com\" #生成公钥与私钥 将公钥上传到到 GitHub 账户 保存好私钥 $ git remote add origin git@github.com:honmaple/vim.git #关联远程仓库 $ git push -u origin master #把本地库内容推送到远程库 $ git push origin master #以后提交本地内容只要输入这个命令就行 $ git clone git@github.com：honmaple/honmaple.git #从远程库克隆到本地 我这里出现问题(远程的commit比本地的commit要新),需要 $ git pull origin master","url":"http://honmaple.tk/articles/2015/10/git.html","tags":"linux"},{"title":"fedora安装后设置","text":"1.增加sudo用户组 $ su 转到root用户，输入密码 # visudo 在root ALL=(ALL) ALL下增加一行 yourname ALL=(ALL) ALL 如果不想每次输入密码更改为 yourname ALL=(ALL) NOPASSWD:ALL :wq #保存退出 exit #回到一般用户 2.备份的主题，图标,字体拷贝到home目录 $ cp -r files ~/.theme $ cp -r files ~/.icons $ cp -r files ~/.fonts $ sudo chmod -R 755 files ## 3. 启用RPM Fusion仓库 $ sudo rpm -Uhv http://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-22.noarch.rpm $ sudo rpm -Uhv http://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-22.noarch.rpm 4.使用 dnf 缓存与dnf 最快源 # vim /etc/dnf/dnf.conf 添加 keepcache=true 与 fastestmirror=true 5. 安装Flash播放器 32位系统 $ sudo rpm - ivh http : // linuxdownload . adobe . com / adobe - release / adobe - release - i386 - 1.0 - 1. noarch . rpm $ sudo rpm -- import / etc / pki / rpm - gpg / RPM - GPG - KEY - adobe - linux $ sudo dnf install flash - plugin 64位系统 $ sudo rpm - ivh http : // linuxdownload . adobe . com / adobe - release / adobe - release - x86_64 - 1.0 - 1. noarch . rpm $ sudo rpm -- import / etc / pki / rpm - gpg / RPM - GPG - KEY - adobe - linux $ sudo dnf install flash - plugin 6.安装解压缩插件 $ sudo yum install unrar unzip p7zip 7.安装gcc 和g++ $ sudo yum install gcc gcc-c++ 8.安装播放器 vlc视频播放器 $ sudo yum install vlc mplayer 音乐播放器 $ sudo yum install moc 歌词 osdlyrics 9.安装火狐 $ sudo yum install firefox 10.安装code::blocks $ sudo yum install codeblocks 11.开机默认进文本模式 $ sudo rm /etc/systemd/system/default.target $ sudo ln -sf /lib/systemd/system/multi-user.target /etc/systemd/system/default.target #文本模式 $ sudo ln -sf /lib/systemd/system/graphical.target /etc/systemd/system/default.target #图形模式 12.安装头文件 $ sudo yum install kernel-headers kernel-devel 13.一些必要的编译工具 $ sudo yum install cscope ctags pylint cmake clang gtk2-devel ncurses ncurses-devel 14.游戏 $ sudo yum install asciiquarium sl fortune oneko gnome-mines 扫雷 gnome-sudoku 数独 gnome-mahjongg 对对碰 15.输入法 $ sudo yum install fcitx fcitx-configtool fcitx-qt fcitx-sunpinyin 16.联网程序 $ sudo yum install w3m w3m-img bcloud uget git wget firefox google-chrome-stable 17.系统清理 $ sudo yum install bleachbit 18.图像与文字 $ sudo yum install wps gimp shotwell 19.其他 # vim /etc/sysconfig/selinux #selinux配置位置 # vim /etc/sysconfig/iptables #防火墙配置位置","url":"http://honmaple.tk/articles/2015/10/fedora-setting.html","tags":"linux"},{"title":"vim配置","text":"我的vimrc配置 let g : iswindows = 0 let g : islinux = 0 if ( has ( \"win32\" ) || has ( \"win64\" ) || has ( \"win95\" ) || has ( \"win16\" )) let g : iswindows = 1 else let g : islinux = 1 endif \" ----------------------------------------------------------------------------- \" < 判断是终端还是 Gvim > \" ----------------------------------------------------------------------------- if has ( \"gui_running\" ) let g : isGUI = 1 else let g : isGUI = 0 endif \" ----------------------------------------------------------------------------- \" < Windows Gvim 配置> \" ----------------------------------------------------------------------------- if ( g : iswindows && g : isGUI ) source $VIMRUNTIME / vimrc_example . vim source $VIMRUNTIME / mswin . vim behave mswin set diffexpr = MyDiff () function MyDiff () let opt = ' - a -- binary ' if & diffopt =~ ' icase ' | let opt = opt . ' - i ' | endif if & diffopt =~ ' iwhite ' | let opt = opt . ' - b ' | endif let arg1 = v : fname_in if arg1 =~ ' ' | let arg1 = '\"' . arg1 . '\"' | endif let arg2 = v : fname_new if arg2 =~ ' ' | let arg2 = '\"' . arg2 . '\"' | endif let arg3 = v : fname_out if arg3 =~ ' ' | let arg3 = '\"' . arg3 . '\"' | endif let eq = '' if $VIMRUNTIME =~ ' ' if & sh =~ '\\ < cmd ' let cmd = ' \"\" ' . $VIMRUNTIME . '\\ diff \"' let eq = '\"' else let cmd = substitute ( $VIMRUNTIME , ' ' , ' \" ', '') . '\\diff\" ' endif else let cmd = $VIMRUNTIME . '\\ diff ' endif silent execute '!' . cmd . ' ' . opt . arg1 . ' ' . arg2 . ' > ' . arg3 . eq endfunction endif \" ----------------------------------------------------------------------------- \" < Vundle 插件管理工具配置 > \" ----------------------------------------------------------------------------- \" 用于更方便的管理vim插件，具体用法参考 :h vundle 帮助 \" Vundle工具安装方法为在终端输入如下命令 \" git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle \" 如果想在 windows 安装就必需先安装 \" git for window \"，可查阅网上资料 set nocompatible \"禁用 Vi 兼容模式 filetype off \"禁用文件类型侦测 set rtp +=~/ . vim / bundle / vundle / call vundle #rc () \" 使用Vundle来管理插件，这个必须要有。 Bundle ' gmarik / vundle ' \" 可以通过以下四种方式指定插件的来源 \" a) 指定Github中vim-scripts仓库中的插件，直接指定插件名称即可，插件明中的 \" 空格使用\"-\"代替。 Bundle ' L9 ' Bundle ' FuzzyFinder ' \" \" c ) 指定非 Github的Git仓库的插件 ，需要使用 git地址 Bundle ' git : //git.wincent.com/command-t.git' \" 以下为要安装或更新的插件，不同仓库都有（具体书写规范请参考帮助） Bundle ' a . vim ' Bundle ' Align ' Bundle ' jiangmiao / auto - pairs ' Bundle ' bufexplorer . zip ' Bundle ' mattn / emmet - vim ' Bundle ' Yggdroot / indentLine ' Bundle ' scrooloose / nerdtree ' Bundle ' scrooloose / nerdcommenter ' Bundle ' Lokaltog / vim - powerline ' Bundle ' bling / vim - bufferline ' Bundle ' kien / ctrlp . vim ' Bundle ' tacahiroy / ctrlp - funky ' Bundle ' repeat . vim ' Bundle ' wesleyche / SrcExpl ' Bundle ' scrooloose / syntastic ' Bundle ' majutsushi / tagbar ' Bundle ' taglist . vim ' \"Bundle 'TxtBrowser' Bundle ' cscope . vim ' Bundle ' ctags . vim ' Bundle ' Lokaltog / vim - easymotion ' \"Bundle 'c.vim' Bundle ' hallison / vim - markdown ' Bundle ' winmanager ' \"Bundle 'python_ifold' Bundle ' molokai ' Bundle ' altercation / vim - colors - solarized ' Bundle ' vimwiki ' Bundle ' kevinw / pyflakes - vim ' Bundle ' hdima / python - syntax ' Bundle ' Valloric / YouCompleteMe ' Bundle ' SirVer / ultisnips ' Bundle ' honza / vim - snippets ' Bundle ' ap / vim - css - color ' Bundle ' jelera / vim - javascript - syntax ' Bundle \"pangloss/vim-javascript\" \" ========================================== \" javascript插件设置 \" ========================================== let g : html_indent_inctags = \"html,body,head,tbody\" let g : html_indent_script1 = \"inc\" let g : html_indent_style1 = \"inc\" \"=========================================== \"syntastic设置 \"=========================================== let g : syntastic_error_symbol = ' >> ' let g : syntastic_warning_symbol = '>' let g : syntastic_check_on_open = 1 let g : syntastic_check_on_wq = 0 let g : syntastic_enable_highlighting = 1 \"let g:syntastic_python_checkers=['pyflakes'] \" 使用 pyflakes \" error code: http://pep8.readthedocs.org/en/latest/intro.html#error-codes \"let g:syntastic_python_checkers=['pyflakes', 'pep8'] \" 使用 pyflakes \"let g:syntastic_python_pep8_args='--ignore=E501,E225' let g : syntastic_python_checkers = [ ' pyflakes ' , ' pylint ' ] let g : syntastic_python_checkers = [ ' pylint ' ] let g : syntastic_python_pylint_args = ' -- disable = C0111 , R0903 , C0301 ' let g : syntastic_javascript_checkers = [ ' jsl ' , ' jshint ' ] let g : syntastic_html_checkers = [ ' tidy ' , ' jshint ' ] \" 修改高亮的背景色, 适应主题 highlight SyntasticErrorSign guifg = white guibg = black \" to see error location list let g : syntastic_always_populate_loc_list = 0 let g : syntastic_auto_loc_list = 0 let g : syntastic_loc_list_height = 5 \"=================================================== \" Youcompleteme自动补全 \"=================================================== \"youcompleteme 默认tab s-tab 和自动补全冲突 let g : ycm_key_list_select_completion = [ ' < Down > ' ] let g : ycm_key_list_previous_completion = [ ' < Up > ' ] let g : ycm_complete_in_comments = 1 \"在注释输入中也能补全 let g : ycm_complete_in_strings = 1 \"在字符串输入中也能补全 let g : ycm_use_ultisnips_completer = 1 \"提示UltiSnips let g : ycm_collect_identifiers_from_comments_and_strings = 1 \"注释和字符串中的文字也会被收入补全 let g : ycm_collect_identifiers_from_tags_files = 1 let g : ycm_seed_identifiers_with_syntax = 1 \"语言关键字补全, 不过python关键字都很短，所以，需要的自己打开 let g : ycm_cache_omnifunc = 0 \" 禁止缓存匹配项,每次都重新生成匹配项 \" 跳转到定义处, 分屏打开 let g : ycm_goto_buffer_command = ' horizontal - split ' \" nnoremap <leader>jd :YcmCompleter GoToDefinition<CR> nnoremap < leader > jd : YcmCompleter GoToDefinitionElseDeclaration < CR > nnoremap < leader > gd : YcmCompleter GoToDeclaration < CR > if ! empty ( glob ( \"~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py\" )) let g : ycm_global_ycm_extra_conf = \"~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py\" endif \" YCM 补全菜单配色 \" 菜单 \"highlight Pmenu ctermfg=2 ctermbg=3 guifg=#005f87 guibg=#EEE8D5 \" 选中项 \"highlight PmenuSel ctermfg=2 ctermbg=3 guifg=#AFD700 guibg=#106900 \" 直接触发自动补全 insert模式下 \" let g:ycm_key_invoke_completion = '<C-Space>' \" 黑名单,不启用 let g : ycm_filetype_blacklist = { \\ ' tagbar ' : 1 , \\ ' gitcommit ' : 1 , \\ } \"=========================================== \"快速插入代码片段 \"=========================================== \"let g:UltiSnipsExpandTrigger = '<C-space>' \"let g:UltiSnipsJumpForwardTrigger = '<Down>' \"let g:UltiSnipsJumpBackwardTrigger = '<Up>' \"定义存放代码片段的文件夹 .vim/snippets下，使用自定义和默认的，将会的到全局，有冲突的会提示 let g : UltiSnipsSnippetDirectories = [ ' bundle / vim - snippets ' , ' bundle / ultisnips ' ] function ! g : UltiSnips_Complete () call UltiSnips #ExpandSnippet () if g : ulti_expand_res == 0 if pumvisible () return \"\\<Down>\" else call UltiSnips #JumpForwards () if g : ulti_jump_forwards_res == 0 return \"\\<TAB>\" endif endif endif return \"\" endfunction au BufEnter * exec \"inoremap <silent> \" . g : UltiSnipsExpandTrigger . \" <C-R>=g:UltiSnips_Complete()<cr>\" let g : UltiSnipsJumpForwardTrigger = \"<tab>\" let g : UltiSnipsListSnippets = \"<c-e>\" \"回车即选中当前项 inoremap < expr > < CR > pumvisible () ? \"\\<C-y>\" : \"\\<C-g>u\\<CR>\" if has ( ' conceal ' ) set conceallevel = 2 concealcursor = i endif \" ========================================== \" < indentLine 插件配置 > \" ========================================== \" 用于显示对齐线，与 indent_guides 在显示方式上不同，根据自己喜好选择了 \" 在终端上会有屏幕刷新的问题，这个问题能解决有更好了 \" 开启/关闭对齐线 let g : indentLine_char = \"┊\" let g : indentLine_first_char = \"┊\" \" 色块宽度 \"let g:indent_guides_guide_size=1 \" 设置终端对齐线颜色，如果不喜欢可以将其注释掉采用默认颜色 let g : indentLine_color_term = 256 \" ========================================== \" markdown \" ========================================== au BufRead , BufNewFile * .{ md , mdown , mkd , mkdn , markdown , mdwn } set filetype = mkd let g : vim_markdown_folding_disabled = 1 let g : vim_markdown_no_default_key_mappings = 1 \" ========================================== \" ctrlp \" ========================================= let g : ctrlp_working_path_mode = ' ra ' let g : ctrlp_custom_ignore = { \\ ' dir ' : '\\ . git $\\ | \\ . hg $\\ | \\ . svn $' , \\ ' file ' : '\\ . exe $\\ | \\ . so $\\ | \\ . dll $\\ | \\ . pyc $' } let g : ctrlp_working_path_mode = 0 let g : ctrlp_match_window_bottom = 1 let g : ctrlp_max_height = 15 let g : ctrlp_match_window_reversed = 0 let g : ctrlp_mruf_max = 500 let g : ctrlp_follow_symlinks = 1 \" ========================================== \" ctrlp-funky \" ========================================== let g : ctrlp_extensions = [ ' funky ' ] let g : ctrlp_funky_syntax_highlight = 1 \" ========================================== \" < Tagbar 插件配置 > \" ========================================== \" 相对 TagList 能更好的支持面向对象 \" 常规模式下输入 tb 调用插件，如果有打开 TagList 窗口则先将其关闭 \"nmap tb :TlistClose<CR>:TagbarToggle<CR> let g : tagbar_width = 20 \"设置窗口宽度 let g : tagbar_left = 1 \"在左侧窗口中显示 let g : tagbar_compact = 1 \"不显示帮助信息 let g : winManagerWindowLayout = \"TagList|FileExplorer,BufExplorer\" \"let g:winManagerWindowLayout = \" TagList | Tagbar \" \" =========================================== \" < TagList 插件配置 > \" =========================================== \" 高效地浏览源码, 其功能就像vc中的workpace \" 那里面列出了当前文件中的所有宏,全局变量, 函数名等 \" 常规模式下输入 tl 调用插件，如果有打开 Tagbar 窗口则先将其关闭 \"nmap tl :TagbarClose<CR>:Tlist<CR> let Tlist_Show_One_File = 1 \"只显示当前文件的tags let Tlist_Show_Menu = 1 \"显示菜单 let Tlist_Enable_Fold_Column = 0 \"使taglist插件不显示左边的折叠行 let Tlist_Exit_OnlyWindow = 1 \"如果Taglist窗口是最后一个窗口则退出Vim let Tlist_File_Fold_Auto_Close = 1 \"自动折叠 let Tlist_WinWidth = 20 \"设置窗口宽度 let Tlist_Use_Right_Window = 1 \"在右侧窗口中显示 \" =========================================== \" nerdcommenter \" =========================================== \" <leader>cc，注释当前选中文本，如果选中的是整行则在每行首添加 //，如果选中一行的部分内容则在选中部分前后添加分别 / 、 /； \"<leader>cu，取消选中文本块的注释 \" \" =========================================== \" < txtbrowser 插件配置 > \" =========================================== \" 用于文本文件生成标签与与语法高亮（调用TagList插件生成标签，如果可以） \"au BufRead,BufNewFile *.txt setlocal ft=txt \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" BufExplorer \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"<Leader>be 全屏方式打来 buffer 列表 \"<Leader>bs 水平窗口打来 buffer 列表 \"<Leader>bv 垂直窗口打开 buffer 列表 \"let g:bufExplorerDefaultHelp=0 \" Do not show default help . \"let g:bufExplorerShowRelativePath=1 \" Show relative paths . \"let g:bufExplorerSortBy='mru' \" Sort by most recently used . \"let g:bufExplorerSplitRight=0 \" Split left . \"let g:bufExplorerSplitVertical=1 \" Split vertically . \"let g:bufExplorerSplitVertSize = 30 \" Split width \"autocmd BufWinEnter \\[Buf\\ List\\] setl nonumber \" \" \" =========================================== \" < cscope 工具配置 > \" =========================================== \" 用Cscope自己的话说 你可以把它当做是超过频的ctags if has ( \"cscope\" ) \"设定可以使用 quickfix 窗口来查看 cscope 结果 set cscopequickfix = s - , c - , d - , i - , t - , e - \"使支持用 Ctrl+] 和 Ctrl+t 快捷键在代码间跳转 set cscopetag \"如果你想反向搜索顺序设置为1 set csto = 0 \"在当前目录中添加任何数据库 if filereadable ( \"cscope.out\" ) cs add cscope . out \"否则添加数据库环境中所指出的 elseif $CSCOPE_DB != \"\" cs add $CSCOPE_DB endif set cscopeverbose \"快捷键设置 nmap < C - \\ > s : cs find s < C - R >= expand ( \"<cword>\" ) < CR >< CR > nmap < C - \\ > g : cs find g < C - R >= expand ( \"<cword>\" ) < CR >< CR > nmap < C - \\ > c : cs find c < C - R >= expand ( \"<cword>\" ) < CR >< CR > nmap < C - \\ > t : cs find t < C - R >= expand ( \"<cword>\" ) < CR >< CR > nmap < C - \\ > e : cs find e < C - R >= expand ( \"<cword>\" ) < CR >< CR > nmap < C - \\ > f : cs find f < C - R >= expand ( \"<cfile>\" ) < CR >< CR > nmap < C - \\ > i : cs find i &#94;< C - R >= expand ( \"<cfile>\" ) < CR > $ < CR > nmap < C - \\ > d : cs find d < C - R >= expand ( \"<cword>\" ) < CR >< CR > endif \" ========================================= \" < ctags 工具配置 > \" ========================================= \" 对浏览代码非常的方便,可以在函数,变量之间跳转等 set tags = . / tags ; \"向上级目录递归查找tags文件（好像只有在Windows下才有用） \" 自动切换目录为当前编辑文件所在目录 au BufRead , BufNewFile , BufEnter * cd %: p : h \" ========================================= \" vimwiki设置 \" ========================================= let g : vimwiki_use_mouse = 1 let g : vimwiki_list = [{ ' path ' : ' ~/ MyCode / vimwiki / ' , \\ ' path_html ' : ' ~/ MyCode / vimwiki_html / ' , \\ ' html_header ' : ' ~/ MyCode / vimwiki_template / header . htm ' , \\ ' html_footer ' : ' ~/ MyCode / vimwiki_template / footer . htm ' ,}] \" ========================================= \"NerdTree设置 \" ========================================= \"autocmd BufEnter * :syntax sync fromstart \"set hid \" 可以在没有保存的情况下切换 buffer \" 自动开启nerdtree let g : nerdtree_tabs_open_on_console_startup = 1 \"当打开vim且没有文件时自动打开NERDTree autocmd vimenter * if ! argc () | NERDTree | endif \" 只剩 NERDTree时自动关闭 autocmd bufenter * if ( winnr ( \"$\" ) == 1 && exists ( \"b:NERDTreeType\" ) && b : NERDTreeType == \"primary\" ) | q | endif \"显示文件 let NERDTreeShowFiles = 1 \"显示隐藏文件 let NERDTreeShowHidden = 0 \"高亮显示当前文件或目录 let NERDTreeHightCursorline = 1 \"不显示'Bookmarks' label 'Press ? for help' let NERDTreeMinimalUI = 1 \" s/v 分屏打开文件 let g : NERDTreeMapOpenSplit = 's' let g : NERDTreeMapOpenVSplit = 'v' \" ========================================= \" python语法实时检查 \" ========================================= \" python fly check, 弥补syntastic只能打开和保存才检查语法的不足 let g : pyflakes_use_quickfix = 1 \" for python.vim syntax highlight let python_highlight_all = 1 \" ======================================== \" General Settings 基础设置 \" ======================================== \" 修改leader键 let mapleader = ',' let g : mapleader = ',' filetype on \"启用文件类型侦测 filetype plugin on \"针对不同的文件类型加载对应的插件 filetype plugin indent on \"启用缩进 syntax on \"代码高亮 \"syntax enable set t_Co = 256 set background = dark if has ( \"gui_running\" ) let g : solarized_termcolors = 256 \"这个必须在前 colorscheme solarized \"终端配色方案 else let g : molokai_original = 1 colorscheme molokai \"终端配色方案 endif \"colorscheme solarized \" 终端配色方案 \"let g:solarized_termcolors=256 \"let g:solarized_termtrans=1 \"let g:solarized_contrast='normal' \"let g:solarized_visibility='normal' set mouse = a \"任何模式下启用鼠标 set mousehide \"Hide the mouse cursor while typing scriptencoding utf - 8 if has ( ' clipboard ' ) if has ( ' unnamedplus ' ) \" When possible use + register for copy-paste set clipboard = unnamed , unnamedplus else \" On mac and Windows, use * register for copy-paste set clipboard = unnamed endif endif set shortmess += filmnrxoOtT \"去掉欢迎界面 set guifont = Monospace \\ 12 set viewoptions = folds , options , cursor , unix , slash \" Better Unix / Windows compatibility set virtualedit = onemore \" Allow for cursor beyond last character set history = 1000 \" Store a ton of history (default is 20) \"set spell \" 启用拼写检查 set hidden \" Allow buffer switching without saving set iskeyword -= . \" '.' is an end of word designator set iskeyword -= # \" '#' is an end of word designator set iskeyword -=- \" '-' is an end of word designator \"set backup \" 设置备份文件 \"if has('persistent_undo') \" set undofile \" So is persistent undo ... \" set undolevels=1000 \" Maximum number of changes that can be undone \" set undoreload=10000 \" Maximum number lines to save for undo on a buffer reload \"endif set tabpagemax = 15 \" Only show 15 tabs set showmode \" Display the current mode set cursorline \"高亮光标所在行 set cuc \"高亮光标所在列 highlight clear SignColumn \" SignColumn should match background highlight clear LineNr \" Current line number row will have same background color in relative mode \"highlight clear CursorLineNr \" Remove highlight color from current line number \"if has('cmdline_info') \" set ruler \" Show the ruler \" set rulerformat=%30(%=\\:b%n%y%m%r%w\\ %l,%c%V\\ %P%) \" A ruler on steroids \" set showcmd \" Show partial commands in status line and \" Selected characters/lines in visual mode \"endif \"if has('statusline') set laststatus = 2 \"启用状态栏信息 \" set statusline=%<%f\\ \" Filename \" set statusline+=%w%h%m%r \" Options \" set statusline+=\\ [%{&ff}/%Y] \" Filetype \" set statusline+=\\ [%{getcwd()}] \" Current dir \" set statusline+=%=%-14.(%l,%c%V%)\\ %p%% \" Right aligned file nav info \"endif set backspace = indent , eol , start \" Backspace for dummies set linespace = 0 \" No extra spaces between rows set number \"显示行号 set relativenumber number \"设置相对行号 au FocusLost * : set norelativenumber number au FocusGained * : set relativenumber \" 插入模式下用绝对行号, 普通模式下用相对 autocmd InsertEnter * : set norelativenumber number autocmd InsertLeave * : set relativenumber function ! NumberToggle () if ( & relativenumber == 1 ) set norelativenumber number else set relativenumber endif endfunc set scrolloff = 10 \"在上下移动光标时，光标的上方或下方至少会保留显示的行数 set showmatch \"高亮显示匹配的括号 set incsearch \"在输入要搜索的文字时，实时匹配 set hlsearch \"高亮搜索 \"set winminheight=0 \" Windows can be 0 line high set ignorecase \"搜索模式里忽略大小写 set smartcase \"如果搜索模式包含大写字符，不使用'ignorecase' 选项，只有在输入搜索模式并且打开 'ignorecase' 选项时才会使用 set wildmenu \" 增强模式中的命令行自动完成操作 set wildmode = list : longest , full \" Command <Tab> completion, list matches, then longest common part, then all. set whichwrap = b , s , h , l , < , > ,[,] \" Backspace and cursor keys wrap too \"让Vim的补全菜单行为与一般IDE一致(参考VimTip1228) set completeopt = longest , menu set wildignore =* . o , *~ , * . pyc , * . class \" set scrolljump = 5 \" Lines to scroll when cursor leaves screen \"set scrolloff=3 \" Minimum lines to keep above and below cursor set foldenable \"启用折叠 set list set listchars = tab : ›\\ , trail : • , extends : # , nbsp :. \" Highlight problematic whitespace set showcmd \"在状态栏显示正在输入的命令 set nowrap \"设置不自动换行 set autoindent \"打开自动缩进 set shiftwidth = 4 \"换行时自动缩进宽度，可更改（宽度同tabstop） set expandtab \"将Tab键转换为空格 set tabstop = 4 \"设置Tab键的宽度，可以更改，如：宽度为2 \"set softtabstop=4 \" Let backspace delete indent \"set nojoinspaces \" Prevents inserting two spaces after punctuation on a join ( J ) \"set splitright \" Puts new vsplit windows to the right of the current \"set splitbelow \" Puts new split windows to the bottom of the current \"set pastetoggle=<F12> \" pastetoggle ( sane indentation on pastes ) \"autocmd BufNewFile,BufRead *.html.twig set filetype=html.twig \"autocmd FileType haskell,puppet,ruby,yml setlocal expandtab shiftwidth=2 softtabstop=2 \"autocmd BufNewFile,BufRead *.coffee set filetype=coffee \"autocmd FileType haskell setlocal commentstring=--\\ %s \"autocmd FileType haskell,rust setlocal nospell let g : FoldMethod = 0 fun ! ToggleFold () if g : FoldMethod == 0 exe \"normal! zM\" let g : FoldMethod = 1 else exe \"normal! zR\" let g : FoldMethod = 0 endif endfun function ! ToggleBG () let s : tbg = & background \" Inversion if s : tbg == \"dark\" set background = light else set background = dark endif endfunction \"set smartindent \" 启用智能对齐方式 \"set shiftround \" 缩进时，取整 \"set showtabline=1 \" 显示标签 set smarttab \"指定按一次backspace就删除shiftwidth宽度 \"set foldmethod=indent \" indent 折叠方式 set foldmethod = syntax \"set foldmethod=marker \" 启动 vim 时关闭折叠代码 set nofoldenable \"set matchtime=5 \" 匹配括号高亮的时间（单位是十分之一秒） \"set autoread \" 当文件在外部被修改，自动更新该文件 \"set autowrite \" 自动保存 set vb t_vb = \"关闭提示音 \" 启用每行超过80列的字符提示（字体变蓝并加下划线），不启用就注释掉 \"au BufWinEnter * let w:m2=matchadd('Underlined', '\\%>' . 80 . 'v.\\+', -1) \" =============================== \" < 界面配置 > \" =============================== \" 显示/隐藏菜单栏、工具栏、滚动条，可用 Ctrl + F11 切换 if has ( \"gui_running\" ) winpos 100 10 \"指定窗口出现的位置，坐标原点在屏幕左上角 set lines = 38 columns = 120 set guioptions -= m set guioptions -= T set guioptions -= r set guioptions -= L nmap < silent > < c - F11 > : if & guioptions =~ # 'm' < Bar > \\ set guioptions -= m < Bar > \\ set guioptions -= T < Bar > \\ set guioptions -= r < Bar > \\ set guioptions -= L < Bar > \\ else < Bar > \\ set guioptions += m < Bar > \\ set guioptions += T < Bar > \\ set guioptions += r < Bar > \\ set guioptions += L < Bar > \\ endif < CR > endif \"========================================== \" others 其它设置 \"========================================== autocmd ! bufwritepost _vimrc source % \" vimrc文件修改之后自动加载。 windows。 autocmd ! bufwritepost . vimrc source % \" vimrc文件修改之后自动加载。 linux。 \"离开插入模式后自动关闭预览窗口 autocmd InsertLeave * if pumvisible () == 0 | pclose | endif if has ( \"autocmd\" ) au BufReadPost * if line ( \"' \\\" \" ) > 1 && line ( \"' \\\" \" ) <= line ( \"$\" ) | exe \"normal! g' \\\" \" | endif endif \" Python 文件的一般设置，比如不要 tab 等 \"autocmd FileType python set tabstop=4 shiftwidth=4 expandtab ai \"autocmd FileType ruby set tabstop=2 shiftwidth=2 softtabstop=2 expandtab ai \"autocmd BufRead,BufNew *.md,*.mkd,*.markdown set filetype=markdown.mkd \" 保存python文件时删除多余空格 fun ! < SID > StripTrailingWhitespaces () let l = line ( \".\" ) let c = col ( \".\" ) %s / \\ s \\ + $ //e call cursor ( l , c ) endfun autocmd FileType c , cpp , java , go , php , javascript , puppet , python , rust , twig , xml , yml , perl autocmd BufWritePre < buffer > : call < SID > StripTrailingWhitespaces () \"设置标记一列的背景颜色和数字一行颜色一致 hi ! link SignColumn LineNr hi ! link ShowMarksHLl DiffAdd hi ! link ShowMarksHLu DiffChange \" for error highlight，防止错误整行标红导致看不清 highlight clear SpellBad highlight SpellBad term = standout ctermfg = 1 term = underline cterm = underline highlight clear SpellCap highlight SpellCap term = underline cterm = underline highlight clear SpellRare highlight SpellRare term = underline cterm = underline highlight clear SpellLocal highlight SpellLocal term = underline cterm = underline \" ====================================================================================== \" 插入文件标题 \" ====================================================================================== \"新建.c,.h,.sh,.java文件，自动插入文件头 autocmd BufNewFile * . cpp , * .[ ch ], * . sh , * . rb , * . java , * . py exec \":call SetTitle()\" \"\" 定义函数 SetTitle ，自动插入文件头 func ! SetTitle () \"如果文件类型为.sh文件 if & filetype == ' sh ' call setline ( 1 , \"\\#!/bin/bash\" ) call append ( line ( \".\" ), \"\" ) elseif & filetype == ' python ' call setline ( 1 , \"#!/usr/bin/env python\" ) call append ( line ( \".\" ), \"# -*- coding=UTF-8 -*-\" ) call append ( line ( \".\" ) + 1 , \"#*************************************************************************\" ) call append ( line ( \".\" ) + 2 , \"# File Name: \" . expand ( \"%\" )) call append ( line ( \".\" ) + 3 , \"# Author:JiangLin \" ) call append ( line ( \".\" ) + 4 , \"# Mail:xiyang0807@163.com \" ) call append ( line ( \".\" ) + 5 , \"# Created Time: \" . strftime ( \"%c\" )) call append ( line ( \".\" ) + 6 , \"#*************************************************************************\" ) call append ( line ( \".\" ) + 7 , \"\" ) elseif & filetype == ' ruby ' call setline ( 1 , \"#!/usr/bin/env ruby\" ) call append ( line ( \".\" ), \"# encoding: utf-8\" ) call append ( line ( \".\" ) + 1 , \"\" ) endif if expand ( \"%:e\" ) == ' cpp ' call setline ( 1 , \"/**************************************************************************\" ) call append ( line ( \".\" ), \" File Name: \" . expand ( \"%\" )) call append ( line ( \".\" ) + 1 , \" Author:JiangLin \" ) call append ( line ( \".\" ) + 2 , \" Mail:xiyang0807@163.com \" ) call append ( line ( \".\" ) + 3 , \" Created Time: \" . strftime ( \"%c\" )) call append ( line ( \".\" ) + 4 , \"**************************************************************************/\" ) call append ( line ( \".\" ) + 5 , \"#include<iostream>\" ) call append ( line ( \".\" ) + 6 , \"using namespace std;\" ) call append ( line ( \".\" ) + 7 , \"\" ) endif if & filetype == 'c' call setline ( 1 , \"/**************************************************************************\" ) call append ( line ( \".\" ), \" File Name: \" . expand ( \"%\" )) call append ( line ( \".\" ) + 1 , \" Author:JiangLin \" ) call append ( line ( \".\" ) + 2 , \" Mail:xiyang0807@163.com \" ) call append ( line ( \".\" ) + 3 , \" Created Time: \" . strftime ( \"%c\" )) call append ( line ( \".\" ) + 4 , \"**************************************************************************/\" ) call append ( line ( \".\" ) + 5 , \"#include<stdio.h>\" ) call append ( line ( \".\" ) + 6 , \"#include<string.h>\" ) call append ( line ( \".\" ) + 7 , \"\" ) endif if expand ( \"%:e\" ) == 'h' call setline ( 1 , \"/**************************************************************************\" ) call append ( line ( \".\" ), \" File Name: \" . expand ( \"%\" )) call append ( line ( \".\" ) + 1 , \" Author:JiangLin \" ) call append ( line ( \".\" ) + 2 , \" Mail:xiyang0807@163.com \" ) call append ( line ( \".\" ) + 3 , \" Created Time: \" . strftime ( \"%c\" )) call append ( line ( \".\" ) + 4 , \"**************************************************************************/\" ) call append ( line ( \".\" ) + 5 , \"#ifndef _\" . toupper ( expand ( \"%:r\" )). \"_H\" ) call append ( line ( \".\" ) + 6 , \"#define _\" . toupper ( expand ( \"%:r\" )). \"_H\" ) call append ( line ( \".\" ) + 7 , \"#endif\" ) endif \"新建文件后，自动定位到文件末尾 endfunc autocmd BufNewFile * normal G \" ----------------------------------------------------------------------------- \" < 编译运行配置 \" ----------------------------------------------------------------------------- let s : LastShellReturn_C = 0 let s : LastShellReturn_L = 0 let s : ShowWarning = 1 let s : Obj_Extension = ' . o ' let s : Exe_Extension = ' . exe ' let s : Sou_Error = 0 let s : Python_Extension = ' . py ' let s : windows_CFlags = ' gcc \\ - fexec - charset = gbk \\ - Wall \\ - g \\ - O0 \\ - c \\ % \\ - o \\ %< . o ' let s : linux_CFlags = ' gcc \\ - Wall \\ - g \\ - O0 \\ - c \\ % \\ - o \\ %< . o ' let s : windows_CPPFlags = ' g ++ \\ - fexec - charset = gbk \\ - Wall \\ - g \\ - O0 \\ - c \\ % \\ - o \\ %< . o ' let s : linux_CPPFlags = ' g ++ \\ - Wall \\ - g \\ - O0 \\ - c \\ % \\ - o \\ %< . o ' let s : PythonFlags = ' python \\ - u \\ % ' func ! Compile () exe \":ccl\" exe \":update\" let s : Sou_Error = 0 let s : LastShellReturn_C = 0 let Sou = expand ( \"%:p\" ) let v : statusmsg = '' if expand ( \"%:e\" ) == \"c\" || expand ( \"%:e\" ) == \"cpp\" || expand ( \"%:e\" ) == \"cxx\" let Obj = expand ( \"%:p:r\" ). s : Obj_Extension let Obj_Name = expand ( \"%:p:t:r\" ). s : Obj_Extension if ! filereadable ( Obj ) || ( filereadable ( Obj ) && ( getftime ( Obj ) < getftime ( Sou ))) redraw ! if expand ( \"%:e\" ) == \"c\" if g : iswindows exe \":setlocal makeprg=\" . s : windows_CFlags else exe \":setlocal makeprg=\" . s : linux_CFlags endif echohl WarningMsg | echo \" compiling...\" silent make elseif expand ( \"%:e\" ) == \"cpp\" || expand ( \"%:e\" ) == \"cxx\" if g : iswindows exe \":setlocal makeprg=\" . s : windows_CPPFlags else exe \":setlocal makeprg=\" . s : linux_CPPFlags endif echohl WarningMsg | echo \" compiling...\" silent make endif redraw ! if v : shell_error != 0 let s : LastShellReturn_C = v : shell_error endif if g : iswindows if s : LastShellReturn_C != 0 exe \":bo cope\" echohl WarningMsg | echo \" compilation failed\" else if s : ShowWarning exe \":bo cw\" endif echohl WarningMsg | echo \" compilation successful\" endif else if empty ( v : statusmsg ) echohl WarningMsg | echo \" compilation successful\" else exe \":bo cope\" endif endif else echohl WarningMsg | echo \"\" Obj_Name \"is up to date\" endif elseif expand ( \"%:e\" ) == \"py\" let Python = expand ( \"%:p:r\" ). s : Python_Extension let Python_Name = expand ( \"%:p:t:r\" ). s : Python_Extension if filereadable ( Python ) || ( ! filereadable ( Python ) && ( getftime ( Python ) < getftime ( Sou ))) redraw ! exe \":setlocal makeprg=\" . s : PythonFlags echohl WarningMsg | echo \" compiling...\" silent make redraw ! if v : shell_error != 0 let s : LastShellReturn_C = v : shell_error endif if g : iswindows if s : LastShellReturn_C != 0 exe \":bo cope\" echohl WarningMsg | echo \" compilation failed\" else if s : ShowWarning exe \":bo cw\" endif echohl WarningMsg | echo \" compilation successful\" endif else if empty ( v : statusmsg ) echohl WarningMsg | echo \" compilation successful\" else exe \":bo cope\" endif endif else echohl WarningMsg | echo \"\" Python_Name \"is up to date\" endif else let s : Sou_Error = 1 echohl WarningMsg | echo \" please choose the correct source file\" endif exe \":setlocal makeprg=make\" endfunc func ! Link () call Compile () if s : Sou_Error || s : LastShellReturn_C != 0 return endif if expand ( \"%:e\" ) == \"c\" || expand ( \"%:e\" ) == \"cpp\" || expand ( \"%:e\" ) == \"cxx\" let s : LastShellReturn_L = 0 let Sou = expand ( \"%:p\" ) let Obj = expand ( \"%:p:r\" ). s : Obj_Extension if g : iswindows let Exe = expand ( \"%:p:r\" ). s : Exe_Extension let Exe_Name = expand ( \"%:p:t:r\" ). s : Exe_Extension else let Exe = expand ( \"%:p:r\" ) let Exe_Name = expand ( \"%:p:t:r\" ) endif let v : statusmsg = '' if filereadable ( Obj ) && ( getftime ( Obj ) >= getftime ( Sou )) redraw ! if ! executable ( Exe ) || ( executable ( Exe ) && getftime ( Exe ) < getftime ( Obj )) if expand ( \"%:e\" ) == \"c\" setlocal makeprg = gcc \\ - o \\ %< \\ %< . o echohl WarningMsg | echo \" linking...\" silent make elseif expand ( \"%:e\" ) == \"cpp\" || expand ( \"%:e\" ) == \"cxx\" setlocal makeprg = g ++ \\ - o \\ %< \\ %< . o echohl WarningMsg | echo \" linking...\" silent make endif redraw ! if v : shell_error != 0 let s : LastShellReturn_L = v : shell_error endif if g : iswindows if s : LastShellReturn_L != 0 exe \":bo cope\" echohl WarningMsg | echo \" linking failed\" else if s : ShowWarning exe \":bo cw\" endif echohl WarningMsg | echo \" linking successful\" endif else if empty ( v : statusmsg ) echohl WarningMsg | echo \" linking successful\" else exe \":bo cope\" endif endif else echohl WarningMsg | echo \"\" Exe_Name \"is up to date\" endif endif setlocal makeprg = make elseif expand ( \"%:e\" ) == \"py\" return endif endfunc func ! Run () let s : ShowWarning = 0 call Link () let s : ShowWarning = 1 if s : Sou_Error || s : LastShellReturn_C != 0 || s : LastShellReturn_L != 0 return endif let Sou = expand ( \"%:p\" ) if expand ( \"%:e\" ) == \"c\" || expand ( \"%:e\" ) == \"cpp\" || expand ( \"%:e\" ) == \"cxx\" let Obj = expand ( \"%:p:r\" ). s : Obj_Extension if g : iswindows let Exe = expand ( \"%:p:r\" ). s : Exe_Extension else let Exe = expand ( \"%:p:r\" ) endif if executable ( Exe ) && getftime ( Exe ) >= getftime ( Obj ) && getftime ( Obj ) >= getftime ( Sou ) redraw ! echohl WarningMsg | echo \" running...\" if g : iswindows exe \":!%<.exe\" else if g : isGUI exe \":!xfce4-terminal -x bash -c './%<; echo; echo 请按 Enter 键继续; read'\" else exe \":!clear; ./%<\" endif endif redraw ! echohl WarningMsg | echo \" running finish\" endif elseif expand ( \"%:e\" ) == \"py\" let python = expand ( \"%:p:r\" ). s : Python_Extension if getftime ( python ) >= getftime ( Sou ) redraw ! echohl WarningMsg | echo \" running...\" if g : iswindows exe \":!pythton %\" else if g : isGUI exe \":!xfce4-terminal -x bash -c 'python %; echo; echo 请按 Enter 键继续; read'\" else exe \":!clear; python %\" endif endif redraw ! echohl WarningMsg | echo \" running finish\" endif endif endfunc func ! RunPython () exe \":w\" exe \":!clear; python -u %\" endfunc \"代码格式优化化 \"定义FormartSrc() func ! FormartSrc () exec \"w\" if & filetype == 'c' exec \"!astyle --style=ansi -a --suffix=none %\" elseif & filetype == ' cpp ' || & filetype == ' hpp ' exec \"r !astyle --style=ansi --one-line=keep-statements -a --suffix=none %> /dev/null 2>&1\" elseif & filetype == ' perl ' exec \"!astyle --style=gnu --suffix=none %\" elseif & filetype == ' py ' ||& filetype == ' python ' exec \"r !autopep8 -i --aggressive %\" elseif & filetype == ' java ' exec \"!astyle --style=java --suffix=none %\" elseif & filetype == ' jsp ' exec \"!astyle --style=gnu --suffix=none %\" elseif & filetype == ' xml ' exec \"!astyle --style=gnu --suffix=none %\" else exec \"normal gg=G\" return endif exec \"e! %\" endfunc \"结束定义FormartSrc \"======================================================================= \"常用快捷键设置 \"======================================================================= \" 常规模式下用空格键来开关光标行所在折叠（注：zR 展开所有折叠，zM 关闭所有折叠） nnoremap < space > @ = (( foldclosed ( line ( '.' )) < 0 ) ? ' zc ' : ' zo ' ) < CR > \" 常规模式下输入 cS 清除行尾空格 nmap cS : %s / \\ s \\ + $ //g<CR>:noh<CR> \" 常规模式下输入 cM 清除行尾 &#94;M 符号 nmap cM : %s / \\ r $ //g<CR>:noh<CR> \" Ctrl + K 插入模式下光标向上移动 imap < c - k > < Up > \" Ctrl + J 插入模式下光标向下移动 imap < c - j > < Down > \" Ctrl + H 插入模式下光标向左移动 imap < c - h > < Left > \" Ctrl + L 插入模式下光标向右移动 imap < c - l > < Right > \"设置esc键 imap jj < Esc > nmap ;; < Esc > vmap ;; < Esc > nmap < C - Z > < Esc > u \"map! <C-O> <C-Y>, map < C - A > ggVG $ \"+y \"map <F12> gg=G vmap < leader > y \"+y nmap < leader > p \"+p \" 选中状态下 Ctrl+c 复制 \"map <C-v> \" * pa \"imap <C-v> <Esc>\" * pa imap < C - a > < Esc >&#94; imap < C - e > < Esc > $ \"vmap <C-v> \" + p \"map <c-v> \" + gp \"map <c-c> \" + y \" 开启/关闭对齐线 nmap < leader > il : IndentLinesToggle < CR > \" 在不使用 MiniBufExplorer 插件时也可用<C-k,j,h,l>切换到上下左右的窗口中去 noremap < c - k > < c - w > k noremap < c - j > < c - w > j noremap < c - h > < c - w > h noremap < c - l > < c - w > l \"行首行尾 noremap H &#94; noremap L $ \" 设置NerdTree map < F2 > : NERDTreeMirror < CR > map < F2 > : NERDTreeToggle < CR > \" 增强源代码浏览，其功能就像Windows中的\" Source Insight \" nmap < F3 > : SrcExplToggle < CR > \"打开/闭浏览窗口 \" 常规模式下输入 tb 调用插件，如果有打开 TagList 窗口则先将其关闭 nmap tb : TlistClose < CR >: TagbarToggle < CR > \"nmap tb :TagbarToggle<CR> \" 常规模式下输入 tl 调用插件，如果有打开 Tagbar 窗口则先将其关闭 nmap tl : TagbarClose < CR >: Tlist < CR > \"切换buffer nmap b1 : b1 < CR > nmap b2 : b2 < CR > nmap b3 : b3 < CR > nmap b4 : b4 < CR > nmap b5 : b5 < CR > nmap b6 : b6 < CR > nmap b7 : b7 < CR > nmap b8 : b8 < CR > nmap b9 : b9 < CR > \"C，C++ 按F5编译运行 map < F5 > : call Run () < CR > map < F8 > : call RunPython () < CR > \"代码格式优化化 map < F6 > : call FormartSrc () < CR > noremap < F1 > < Esc > \"废弃F1键以防调出系统帮助 map < leader > zz : call ToggleFold () < cr > \"代码折叠快捷键 nnoremap < C - n > : call NumberToggle () < cr > \"显示/关闭相对行号 \" 去掉搜索高亮 noremap < silent >< leader >/ : nohls < CR > \"鼠标粘贴 noremap < silent >< leader > vb : set mouse = v < CR > \"切换背景 noremap < leader > bg : call ToggleBG () < CR > \"CtrlPFunky快捷键 nnoremap < Leader > fu : CtrlPFunky < Cr > \" narrow the list down with a word under cursor nnoremap < Leader > fU : execute ' CtrlPFunky ' . expand ( ' < cword > ' ) < Cr > \"ctrlpwen文件模糊查找快捷键 ctrl+p nnoremap < silent > < D - t > : CtrlP < CR > nnoremap < silent > < D - r > : CtrlPMRU < CR > \"粘贴快捷键 set pastetoggle =< F12 > \"<C-y>, emmet快捷键 \"<leader><leader>fa 快速移动 \"<leader>cc，注释当前选中文本，如果选中的是整行则在每行首添加 //，如果选中一行的部分内容则在选中部分前后添加分别 / 、 /； \"<leader>cu，取消选中文本块的注释 \" \"<Leader>be 全屏方式打来 buffer 列表 \"<Leader>bs 水平窗口打来 buffer 列表 \"<Leader>bv 垂直窗口打开 buffer 列表","url":"http://honmaple.tk/articles/2015/10/vimrc.html","tags":"linux"},{"title":"使用pelican搭建个人博客","text":"pelican介绍 Pelican是一个用Python语言编写的静态网站生成器，支持使用restructuredText和Markdown写文章，配置灵活，扩展性强 pelican安装 $ sudo pip install pelican 安装markdown $ sudo pip install markdown pelican使用 工具准备好了，接下来就开始使用 $ cd git $ mkdir pelican #建立一个文件夹(位置和名称随意，自己记得就行) $ cd pelican $ pelican-quickstart 显示 (也可以直接回车默认) Welcome to pelican-quickstart v3.4.0. This script will help you create a new Pelican-based website. Please answer the following questions so this script can generate the files needed by Pelican. > Where do you want to create your new web site? [.] > What will be the title of this web site? HonMaple > Who will be the author of this web site? honmaple > What will be the default language of this web site? [en] zh > Do you want to specify a URL prefix? e.g., http://example.com (Y/n) > What is your URL prefix? (see above example; no trailing slash) http://honmaple.github.io > Do you want to enable article pagination? (Y/n) > How many articles per page do you want? [10] > Do you want to generate a Fabfile/Makefile to automate generation and publishing? (Y/n) > Do you want an auto-reload & simpleHTTP script to assist with theme and site development? (Y/n) > Do you want to upload your website using FTP? (y/N) > Do you want to upload your website using SSH? (y/N) > Do you want to upload your website using Dropbox? (y/N) > Do you want to upload your website using S3? (y/N) > Do you want to upload your website using Rackspace Cloud Files? (y/N) > Do you want to upload your website using GitHub Pages? (y/N) Y > Is this your personal page (username.github.io)? (y/N) Y Done. Your new project is available at /home/git/pelican 接下来要设置pelicanconf.py和publishconf.py 具体可以看 官方帮助文档 或者参考 我的配置 查看目录 pelican/ ├── content ├── output ├── develop_server.sh ├── fabfile.py ├── Makefile ├── pelicanconf.py # Main settings file └── publishconf.py # Settings to use when ready to publish 现在可以开始写第一篇文章了 $ cd content $ mkdir articles pages extra impages $ cd articles $ vim hello.md 在文件开头输入下列内容 TITLE : 文章标题 Author : 作者 Date : 2015 - 10 - 15 Category : 文章类别 Tags : 标签 Summary : 概要内容 具体内容 保存退出后输入 $ cd ../../ #进入pelican文件夹下 $ make html 可以看实际效果 $ google-chrome-stable output/index.html 提交内容 编辑好内容并且 make html 后需要将内容push到github $ cd output/ $ git init $ git remote add origin git@github.com:honmaple/honmaple.github.io.git #关联远程仓库 $ git add * $ git commit -m \"My first blog by pelican\" 过几分钟后就可以看到内容了","url":"http://honmaple.tk/articles/2015/10/pelican.html","tags":"python"}]}