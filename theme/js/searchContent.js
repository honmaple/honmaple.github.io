var tipuesearch = {"pages":[{"title":"曾经","text":"小学时 她曾问我 谁是运动会上得分最多的人 我笑着 指了指旁边 是他 后来 听说他们在一起了 明明得分最多的人是我 初中 她曾问我 谁考了全校第二 我笑着 指了指旁边 是他 后来 听说他们走得很近 明明考了全校第二的人是我 后来 她不再问我了 后来 我没有她了","tags":"Life","url":"https://honmaple.me/articles/2019/05/曾经.html","loc":"https://honmaple.me/articles/2019/05/曾经.html"},{"title":"关于ivy的使用技巧","text":"ivy默认的配置已经足够了，但还是可以通过一些技巧来提升使用体验 ivy中的tab ivy提供了好几个有关补全的命令，分别是 ivy-done , ivy-partial-or-done , ivy-immediate-done , ivy-dispatching-done , 但不幸，想要获得高效的补全，我不得不记住这n多个命令，这常常使效率变得更低， 所以，我自定义了一个 maple/ivy-done , 仅使用 tab 这一个按键就可以获得以上所有的体验 ( defun maple/ivy-done () ( interactive ) ( let (( dir ivy--directory )) ( ivy-partial-or-done ) ( when ( string= dir ivy--directory ) ( ivy-insert-current ) ( when ( and ( eq ( ivy-state-collection ivy-last ) #' read-file-name-internal ) ( setq dir ( ivy-expand-file-if-directory ( ivy-state-current ivy-last )))) ( ivy--cd dir ) ( setq this-command 'ivy-cd ))))) 预设场景一 dirs目录下有 init-a.el init-b.el init-c.el 等多个文件, 我需要把 init-c.el 重命名为 init-c.el.bak , 默认的ivy会怎么做呢 输入 init c 进行查找 使用 C-M-j (ivy-immediate-done) 插入当前选中项 修改 而使用 maple/ivy-done 后呢 输入 init c 进行查找 使用 tab 插入当前选中项 修改 预设场景二 有一个n级子目录，需要切换到第n个子目录下, 默认的ivy会怎么做呢 使用 tab 选中 再次使用 tab 切换目录 而使用 maple/ivy-done 后呢 使用 tab 选中并切换目录 ivy中的C-h 由于我是邪恶的 evil 用户, 所以我正常情况会使用 C-j , C-k 来选择待选项，同样的，我希望能够使用 C-h 来进行某些操作,比如在 counsel-ag 中使用 C-h 代替 backspace 删除输入的字符，而在 counsel-find-file 中使用 C-h 切换到上一级目录 ivy默认提供了 counsel-up-directory 命令可以切换到上级目录, 我希望能更进一步，当有插入的字符时, 调用 C-h 能够直接清除插入的字符,再次调用才切换到上一级目录 ( defun maple/ivy-c-h () ( interactive ) ( if ( eq ( ivy-state-collection ivy-last ) #' read-file-name-internal ) ( if ( string-equal ( ivy--input ) \"\" ) ( counsel-up-directory ) ( delete-minibuffer-contents )) ( ivy-backward-delete-char ))) ivy-occur批量操作 自动打开wgrep-mode ivy默认调用 ivy-occur 后, 还需要调用 ivy-wgrep-change-to-wgrep-mode 才能进行批量修改 ;; ivy-occur custom ( defun maple/ivy-edit () \"Edit the current search results in a buffer using wgrep.\" ( interactive ) ( run-with-idle-timer 0 nil 'ivy-wgrep-change-to-wgrep-mode ) ( ivy-occur )) 批量修改文件名 预设场景: 当某个项目下有许多使用 aaa.py 的文件,我需要把 aaa.py 全部修改为 bbb.py , 也许某个 aaa.py 需要修改成 ccc.py ，我在使用 projectile-find-file 搜索完全部的 aaa.py 后，打开ivy默认的 ivy-occur 并不能对文件进行修改(提示 Text read only ), 所以我采用 find-name-dired 来批量修改文件名(目前还有些问题) ( defun maple/ivy-dired-occur () ( interactive ) ( find-name-dired ( or ( projectile-project-root ) default-directory ) ( concat ( ivy--input ) \"*\" )) ( ivy-exit-with-action ( lambda ( _ ) ( pop-to-buffer ( get-buffer \"*Find*\" )) ( dired-hide-details-mode ) ( wdired-change-to-wdired-mode ) ( when ( bound-and-true-p evil-local-mode ) ( evil-normal-state ))))) counsel-find-file 重命名 预设场景: 有一个dirs目录, 我需要在同级目录下创建一个 dirs-aa.el 的文件, 默认的ivy会怎么做呢 切换到 dirs 目录的上级目录 使用 ivy-immediate-done 插入目录名 新建文件 但还有一种方式 切换到 dirs 目录 使用 backspace 键删除目录末尾的 =/= 新建文件 不幸的是，ivy中 backspace 的按键绑定了 ivy-backward-delete-char , 在 counsel-find-file 中使用 ivy会直接返回上级目录, 所以需要对 ivy-backward-delete-char 作简单的修改 ( defun maple/ivy-backward-delete-char () ( interactive ) ( let (( dir ivy--directory ) ( p ( and ivy--directory ( = ( minibuffer-prompt-end ) ( point ))))) ( ivy-backward-delete-char ) ( when p ( insert ( file-name-nondirectory ( directory-file-name dir )))))) 自动创建不存在的目录 不仅用于ivy, 其它文件操作命令也需要 ( defun maple/ivy-make-directory-maybe () \"Create parent directory if not exists while visiting file.\" ( let (( dir ( file-name-directory buffer-file-name ))) ( unless ( file-exists-p dir ) ( if ( y-or-n-p ( format \"Directory %s does not exist,do you want you create it? \" dir )) ( make-directory dir t ) ( keyboard-quit ))))) ( add-to-list 'find-file-not-found-functions 'maple/ivy-make-directory-maybe nil #'eq ) ivy自动使用选中的内容 在使用 counsel-ag 或者 swiper , 我需要快速搜索选中的关键词，然而，ivy默认并不支持这么做，ivy需要打开 counsel-ag 后使用 M-n 插入选中的关键词，当然，也许是作者认为这样的方式很方便，但我并不认同，我为何需要重复一次操作呢，为何还需要记住 M-n 这样的按键呢？ ( defun maple/region-string () \"Get region string.\" ( if ( not ( use-region-p )) \"\" ( let* (( beg ( region-beginning )) ( end ( region-end )) ( eol ( save-excursion ( goto-char beg ) ( line-end-position )))) ( deactivate-mark ) ( buffer-substring-no-properties beg ( min end eol ))))) ;; custom counsel-ag ( defun maple/counsel-ag ( -counsel-ag &optional initial-input initial-directory extra-ag-args ag-prompt ) ( funcall -counsel-ag ( or initial-input ( maple/region-string )) ( or initial-directory default-directory ) extra-ag-args ag-prompt )) ( advice-add 'counsel-ag :around #' maple/counsel-ag ) 这样，调用 counsel-ag 时，如何已经有选中的关键词，就会直接调用该关键词进行查找，避免重复操作, 同样的对于 swiper 也可以使用另一种方式 ( defun maple/ivy-search-at-point ( func ) ( let (( ivy-initial-inputs-alist ( list ( cons func ( maple/region-string ))))) ( funcall func ))) ( defun maple/swiper () ( interactive ) ( maple/ivy-search-at-point 'swiper )) 搜索某个目录 counsel-ag 默认搜索当前目录，想要搜索某个目录，需要切换到该目录下调用 counsel-ag ，无疑的，这非常不方便，所以，我希望可以选择某个目录进行搜索 ( defun maple/counsel-ag-directory () ( interactive ) ( counsel-ag nil ( read-directory-name \"Search in directory: \" ))) ivy的显示避免出现在视线外 详见 自定义helm式的ivy.html 中的 吐嘈六: minibuffer","tags":"Linux","url":"https://honmaple.me/articles/2019/05/关于ivy的使用技巧.html","loc":"https://honmaple.me/articles/2019/05/关于ivy的使用技巧.html"},{"title":"鱼","text":"莫相逢 只道人生初见 寻归里 岂敢天涯 且听风雨且听云 庄周，意逍遥","tags":"Life","url":"https://honmaple.me/articles/2019/04/鱼.html","loc":"https://honmaple.me/articles/2019/04/鱼.html"},{"title":"路","text":"当你不断超越前方的人 在更前方 总会有那么一盏红灯 也许是为了安全 也许是为了公平 谁知道呢 你，终归是只能等着","tags":"Life","url":"https://honmaple.me/articles/2019/04/路.html","loc":"https://honmaple.me/articles/2019/04/路.html"},{"title":"未来，谁知道呢","text":"终究是辞职了， 放弃了下个月可能发的年终奖， 放弃了下个月就要涨的工资， 也许还要放弃杭州这座美丽而陌生的城市， 可未来，谁知道呢？ 总是担心怎么给父母交代， 总是担心养老保险怎么办， 公积金怎么办， 租房搬家怎么办， 档案怎么办， 户口怎么办， 买房买车怎么办， 结婚怎么办， 孩子怎么办， ...... 未来，到底该怎么办 也许明天就要发生世界大战， 也许明天会因为意外而死去 也许明天会更好， 可未来，谁知道呢？ 什么时候能够重归路上， 我，一直在路上","tags":"Life","url":"https://honmaple.me/articles/2019/03/未来，谁知道呢.html","loc":"https://honmaple.me/articles/2019/03/未来，谁知道呢.html"},{"title":"忆","text":"青霜长华旧离人 梅雨秋雪落缤纷","tags":"Life","url":"https://honmaple.me/articles/2019/02/忆.html","loc":"https://honmaple.me/articles/2019/02/忆.html"},{"title":"emacs窗口管理","text":"init-window.el 基础设置 ;; 设置默认为左右分屏 ( setq split-width-threshold 1 ) ( evil-leader/set-key \"ws\" 'split-window-below ;; 上下分屏 \"wv\" 'split-window-right ) ;; 左右分屏 使用shackle管理窗口 当设置了 (setq split-width-threshold 1) 后所有的窗口都会变成左右分屏，所以需要 shackle 或 popwin package对窗口进行管理, 对一些特殊的窗口或 buffer 比如 *Help* 和 flycheck error list 需要设置为显示在下方，并且默认选中 ( setq shackle-rules ' (( \"*Help*\" :select t :align 'below :autoclose t ) ( flycheck-error-list-mode :select t :align 'below :autoclose t ))) 设置默认的参数 ( setq shackle-default-size 0.3 shackle-default-alignment 'below shackle-default-rule nil ) 窗口黄金分割zoom 窗口黄金分割是一个非常有用的效果，当选中某个buffer时，这个buffer的window会自动按比例放大，这样就不用手动对窗口进行调整, 之前一直使用 golden-ratio 这个package, 但看github上最近一次提交已经是两年前，加上使用需要定义很多的 golden-ratio-extra-commands , 所以切换到了 zoom zoom 这个 package也有一些问题，比如我定义了 ( setq zoom-size ' ( 0.618 . 0.618 ) zoom-ignored-major-modes ' ( term-mode flycheck-error-list-mode )) 但使用 flycheck-list-errors 时还是会自动缩放窗口大小，后来翻看源码时发现新建 window 是都会调用 balance-windows ,所以我稍微修改了一下 ( defun maple/balance-windows ( func &optional window-or-frame ) ( unless ( zoom--window-ignored-p ) ( funcall func window-or-frame ))) ( advice-add 'balance-windows :around 'maple/balance-windows ) 这样在调用 flycheck-list-errors 就不会再自动缩放窗口大小了 另外有一些命令需要临时关闭 zoom-mode ,所以有添加了一个 marco 临时关闭 zoom-mode ( defmacro with-zoom-disable ( body ) ( declare ( indent defun )) ( let (( zoom-mode-p ( when ( featurep 'zoom ) zoom-mode )) res ) ( when zoom-mode-p ( zoom-mode -1 )) ( setq res `,@ body ) ( when zoom-mode-p ( zoom-mode zoom-mode-p )) res )) 比如: ( with-zoom-disable ( maple-imenu )) window-numbering显示当前窗口号 为了更方便的在窗口间进行跳转，避免重复使用 evil-window-down , evil-window-right 等命令 ( use-package window-numbering :hook ( maple-theme . window-numbering-mode )) maple-theme-hook : 加载 theme 后执行hook 然后设置(这里只设置到5,因为我大概不会开10个窗口的) ( evil-leader/set-key \"w0\" 'select-window-0 \"w1\" 'select-window-1 \"w2\" 'select-window-2 \"w3\" 'select-window-3 \"w4\" 'select-window-4 \"w5\" 'select-window-5 ) 这样就可以使用 leader + w + {window number} 或者 alt + {window number} 跳转 另外 window-number 的显示需要 mode-line 的支持，比如在 maple-modeline 里可以这样定义 ( maple-modeline-define window-number :if ( bound-and-true-p window-numbering-mode ) :format ( let (( color ( face-attribute 'cursor :background ))) ( maple-modeline--add-text-property ( maple-modeline--unicode-number ( int-to-string ( window-numbering-get-number ))) 'face ` ( :foreground , color :distant-foreground \"white\" ))))","tags":"Linux","url":"https://honmaple.me/articles/2019/01/emacs窗口管理.html","loc":"https://honmaple.me/articles/2019/01/emacs窗口管理.html"},{"title":"web-mode自定义fold函数以适应indent-region","text":"web-mode 有一个内置的 web-mode-fold-or-unfold 函数，但这个函数有一个问题，当存在 fold 时，使用 indent-region 会得到错误的缩进，想要得到正确的缩进，必须先 unfold , 比如 < div > < div class = \"col-xs-3 col-sm-3\" id = \"sidebar\" role = \"navigation\" > < button class = \"btn btn-primary\" > Submit </ button > < br /> < span > < button class = \"btn btn-primary\" > Submit </ button > < br /> </ span > < span > < button class = \"btn btn-primary\" > Submit </ button > < br /> </ span > </ div > </ div > < button class = \"btn btn-primary\" > Submit </ button > < br /> < a href = \"\" > as </ a > 当把 div#sidebar 使用 web-mode-fold-or-unfold 折叠起来, 然后使用 ( defun maple/indent-buffer () \"Format buffer with `indent-region`.\" ( interactive ) ( save-excursion ( indent-region ( point-min ) ( point-max ) nil ))) 展开后就会变成 <!-- sidebar --> < div > < div class = \"col-xs-3 col-sm-3\" id = \"sidebar\" role = \"navigation\" > < button class = \"btn btn-primary\" > Submit </ button > < br /> < span > < button class = \"btn btn-primary\" > Submit </ button > < br /> </ span > < span > < button class = \"btn btn-primary\" > Submit </ button > < br /> </ span > </ div > </ div > < button class = \"btn btn-primary\" > Submit </ button > < br /> < a href = \"\" > as </ a > 这与期望的效果不符(不知道是不是只有我碰到，还是这可能是一个 bug ), 我去看了一下 web-mode-fold-or-unfold 的实现, 它使用的是 ( put-text-property beg-inside end-inside 'invisible t ) 来隐藏折叠部分， 我不太清楚为什么使用put-text-property会使indent-region缩进有问题，有知道的可以告知一下 ，但我平时在其他项目中都是使用 hs-toggle-hiding 来折叠代码， hs-toggle-hiding 能很好的与 indent-region 配合 由于 web-mode-fold-or-unfold 这个函数太长，不想占用我自己的配置， 所以魔改了一下 ( fset 'maple/put-text-property ( symbol-function 'put-text-property )) ( defun maple/web-mode-put-text ( p q prop value ) ( if ( and ( eq prop 'invisible ) value ) ( hs-make-overlay p q 'code ) ( maple/put-text-property p q prop value ))) ( defun maple/web-mode-fold-or-unfold () ( interactive ) ( cl-letf ((( symbol-function 'put-text-property ) 'maple/web-mode-put-text )) ( web-mode-fold-or-unfold ))) 把 put-text-property 临时修改成 hs-make-overlay ,这样 web-mode 折叠后就能正确地使用 maple/indent-buffer 了 来源: honmaple's init-web.el","tags":"Linux","url":"https://honmaple.me/articles/2018/11/web-mode自定义fold函数以适应indent-region.html","loc":"https://honmaple.me/articles/2018/11/web-mode自定义fold函数以适应indent-region.html"},{"title":"从远程url下载并压缩js,css","text":"之前一直在使用 bootcdn.cn 提供的 CDN 服务，没出过什么大问题，即使国庆第一天凌晨挂过，对它依旧信任。 但事与愿违，无意中打开查看源码，才发现竟然有那么多的css，js文件 < link href = \"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel = \"stylesheet\" > < link href = \"https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css\" rel = \"stylesheet\" > < link href = \"https://cdn.bootcss.com/fancybox/3.1.25/jquery.fancybox.min.css\" rel = \"stylesheet\" > < script src = \"https://cdn.bootcss.com/lazysizes/4.0.1/lazysizes.min.js\" ></ script > < script src = \"https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js\" ></ script > < script src = \"https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js\" ></ script > < script src = \"https://cdn.bootcss.com/particles.js/2.0.0/particles.min.js\" ></ script > < script src = \"https://cdn.bootcss.com/fancybox/3.1.25/jquery.fancybox.min.js\" ></ script > 作为强迫症有些受不了，想要把这些合并成一个 css 文件或 js 文件 首先找到熟悉的python的 webassets ，但发现只能使用本地文件，又不想一个文件一个文件的下载下来，所以写了一段简单的代码，把下载文件并压缩文件合到一起 下载文件 def write_to_file ( name , url ): resp = requests . get ( url ) path = os . path . join ( \"/tmp\" , name ) with open ( path , \"w\" ) as f : f . write ( resp . text ) return name 压缩css from webassets import Bundle from webassets import Environment def asset_css ( files ): env = Environment ( directory = '/tmp' , url = '/media' ) css = Bundle ( * files , filters = 'cssmin' , output = '/tmp/mine.css' ) env . register ( 'css_all' , css ) print ( env [ 'css_all' ] . urls ()) 压缩js def asset_js ( files ): env = Environment ( directory = '/tmp' , url = '/media' ) css = Bundle ( * files , filters = 'jsmin' , output = '/tmp/mine.js' ) env . register ( 'js_all' , css ) print ( env [ 'js_all' ] . urls ()) 调用 css_files = { \"bootstrap.min.css\" : \"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" , \"font-awesome.min.css\" : \"https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css\" , \"jquery.fancybox.min.css\" : \"https://cdn.bootcss.com/fancybox/3.1.25/jquery.fancybox.min.css\" } js_files = { \"lazysizes.min.js\" : \"https://cdn.bootcss.com/lazysizes/4.0.1/lazysizes.min.js\" , \"jquery.min.js\" : \"https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js\" , \"bootstrap.min.js\" : \"https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js\" , \"particles.min.js\" : \"https://cdn.bootcss.com/particles.js/2.0.0/particles.min.js\" , \"jquery.fancybox.min.js\" : \"https://cdn.bootcss.com/fancybox/3.1.25/jquery.fancybox.min.js\" } def main (): files = [] for name , url in css_files . items (): files . append ( write_to_file ( name , url )) asset_css ( files ) files = [] for name , url in js_files . items (): files . append ( write_to_file ( name , url )) asset_js ( files ) if __name__ == '__main__' : main () 然后把压缩的 mine.css 和 mine.js 上传到云存储，测试后发现一切正常， 唯有 font-awesome 缺少字体， 下载 字体 后手动上传到 css 文件的相对目录 ../fonts 即可 为避免忘记，特此记录","tags":"coding","url":"https://honmaple.me/articles/2018/10/从远程url下载并压缩js,css.html","loc":"https://honmaple.me/articles/2018/10/从远程url下载并压缩js,css.html"},{"title":"maple-imenu——类似tagbar的emacs插件","text":"这几天参考 imenu-list 重写了一个类似 vim 中 tagbar 的插件 maple-imenu , 其实之前我一直在使用另一个类似的插件—— imenu-list , 虽然 imenu-list 已经足够使用了, 但它和 golden-ratio 搭配起来很难受， golden-ratio 我是常开的, 但 imenu-list 也会偶尔使用(浏览及讲解代码必备，否则查找某个函数和变量时很难受的) 原本我想要自定义一下 imenu-list ，但看了源码之后, 发现很多地方都不符合我的需求， 而且需要改动的地方越来越多，最后不如自己重写 如何使用 下载 文件 复制到 $HOME/.emacs.d/site-lisp/maple-imenu 目录, 然后 ( use-package maple-imenu :load-path \"site-lisp/maple-imenu\" :commands ( maple-imenu ) :config ( with-eval-after-load 'evil ( evil-make-overriding-map maple-imenu-mode-map 'normal ))) M-x maple-imenu 相关变量 maple-imenu-buffer maple-imenu buffer name, default *maple-imenu* maple-imenu-displayed-buffer displayed buffer name, default nil maple-imenu-overlays save overlay info, toggle open or close entry maple-imenu-width maple-imenu window size, default 25 maple-imenu-padding maple-imenu prefix padding, default 2 maple-imenu-position maple-imenu window display position, default 'right , or 'left maple-imenu-arrow open or close arrow, default (\"▾\" . \"▸\") maple-imenu-auto-update auto update when t , after save every time 相比较 imenu-list ➊ 代码和逻辑我认为与 imenu-list 比起来更加通俗易懂 ➋ window fixed, 至少与 golden-ratio 搭配不那么难受 ➌ 更多我可以控制和自定义的地方","tags":"Linux","url":"https://honmaple.me/articles/2018/10/maple-imenu——类似tagbar的emacs插件.html","loc":"https://honmaple.me/articles/2018/10/maple-imenu——类似tagbar的emacs插件.html"},{"title":"使用maple-note管理笔记","text":"更新于 2019.04 blog-mode 更新为 maple-note 新建 Git 仓库 emacs-maple-note emacs-maple-note blog-mode , 一个基于 tabulated-list 的emacs笔记管理插件 前言 很早之前我一直在使用 blog-admin 作为博客笔记的管理工具, 虽然没有用社区维护的 CodeFalling/blog-admin , 而是用我自己修改的 honmaple/blog-admin , 毕竟我使用的 pelican , 是一个很小众的静态博客生成工具, 为了适应 pelican , 也为了适应自己平时的使用, 所以自己修改了一个版本 但最近一是闲来没事，二是 blog-admin 使用的是 ctable ，中英文对齐上有些问题(虽然早就解决了), 三是觉得 blog-admin 有很多我不需要的代码, 而且看到那一长串的配置。。。 ( setq blog-admin-backend-type 'pelican blog-admin-backend-new-post-in-drafts t ;; create new post in drafts by default blog-admin-backend-new-post-with-same-name-dir nil ;; create same-name directory with new post blog-admin-backend-path \"~/git/pelican\" blog-admin-backend-pelican-config-file \"pelicanconf.py\" blog-admin-backend-pelican-posts-dir \"content/org\" blog-admin-backend-pelican-org-mode-dir \"content/org\" blog-admin-backend-pelican-markdown-dir \"content/markdown\" blog-admin-backend-pelican-drafts-dir \"content/draft\" ) ( add-hook 'blog-admin-backend-after-new-post-hook 'find-file ) ( maple/add-hook 'blog-admin-mode-hook :if ( display-graphic-p ) ;; (set-face-attribute 'variable-pitch nil :font \"-Sony-Sony Fixed-normal-normal-normal-*-16-*-*-*-c-80-iso10646-1\") ( set-face-attribute 'variable-pitch nil :font \"Inconsolata 12\" ) ( buffer-face-mode )) 查找资料后锁定了 tabulated-list , 毕竟默认的emacs包管理器使用的就是 tabulated-list , 最终参考 package.el.gz , 自己写了一个 maple-note blog-mode 配置 ( use-package maple-note :ensure nil :commands maple-note :config ( setq maple-note-root-path \"~/git/pelican\" maple-note-draft-path \"content/draft\" ) ( setq maple-note-alist ' (( \"markdown\" :path \"content/markdown\" :read maple-note--read-md :template \"Title: %s Author: honmaple Date: %s Modified: %s Category: Tags: Slug: %s Summary: \" ) ( \"org-mode\" :path \"content/org\" :read maple-note--read-org :template \"#+TITLE: %s #+AUTHOR: honmaple #+DATE: %s #+CATEGORY: #+PROPERTY: MODIFIED %s #+PROPERTY: TAGS #+PROPERTY: SLUG %s #+PROPERTY: SUMMARY \" )))) ;; 弃用 ( use-package blog-mode :load-path \"site-lisp/blog-mode\" :commands blog-start :config ( setq blog-root-path \"~/git/pelican\" ;; 文章根目录 blog-org-path \"content/org\" ;; org文件保存目录 blog-md-path \"content/markdown\" ;; markdown文件保存目录 blog-draft-path \"content/draft\" )) ;; 草稿文件保存目录 快捷键 w 新建文章 新建文章以 .org 或 .md 结尾, 默认会保存在 maple-note-draft-path blog-draft-path 目录下 r 刷新列表 s 发布与未发布切换 这个其实是目录的切换, 未发布的放到 maple-note-draft-path blog-draft-path 目录下, 已发布的 org 文件放到 blog-org-path 目录, markdown 文件放到 blog-md-path 目录 ,已发布的 org 文件放到 maple-note-alist 中预定义的 path 路径里, markdown 文件同理 D 删除当前文章 f 筛选文章 筛选 title 和 category RET (鼠标左键) 点击 title : 打开文件 点击 publish : 发布与未发布切换 点击 category : 筛选当前分类","tags":"Linux","url":"https://honmaple.me/articles/2018/10/使用maple-note管理笔记.html","loc":"https://honmaple.me/articles/2018/10/使用maple-note管理笔记.html"},{"title":"西子遇","text":"欲把西湖比西子 淡妆浓抹总相宜 久闻西子久成思 时至菡萏时遇迟 朝闻西子犹在天 夕至柳畔觉未眠","tags":"Life","url":"https://honmaple.me/articles/2018/10/西子遇.html","loc":"https://honmaple.me/articles/2018/10/西子遇.html"},{"title":"elasticsearch笔记","text":"elasticsearch 安装 优化 关闭swap swapoff -a # 注释 /etc/fstab swap sysctl -p unlimit调整 sysctl -w vm.max_map_count = 262144 echo 'vm.max_map_count=262144' >> /etc/sysctl.conf 使用ssd 重启 curl -X PUT \"localhost:9200/_cluster/settings\" -H 'Content-Type: application/json' -d ' { \"persistent\": { \"cluster.routing.allocation.enable\": \"none\" } } ' curl -X POST \"localhost:9200/_flush/synced\" supervisorctl restart elasticsearch curl -X GET \"localhost:9200/_cat/health\" curl -X PUT \"localhost:9200/_cluster/settings\" -H 'Content-Type: application/json' -d ' { \"persistent\": { \"cluster.routing.allocation.enable\": null } } ' 踩坑 滚动重启 重启前 curl -XPUT http://192.168.67.14:9200/_cluster/settings -d '{ \"transient\" : { \"cluster.routing.allocation.enable\" : \"none\" } }' 重启后 curl -XPUT http://192.168.67.14:9200/_cluster/settings -d '{ \"transient\" : { \"cluster.routing.allocation.enable\" : \"all\" } }' 修改index.number_of_shards 磁盘损坏 curl -XPOST 'http://192.168.60.32:9200/_cluster/reroute' -d '{ \"commands\" : [ { \"allocate\" : { \"index\" : \".marvel-2018.10.10\", \"shard\" : 0, \"node\" : \"1.7.5-192.168.67.14\", \"allow_primary\" : true } } ] }' unassigned shards curl http://127.0.0.1:9200/_cat/shards?v 2 > & 1 | grep UNASSIGNED curl http://127.0.0.1:9200/_nodes/process?pretty curl -XPOST 'http://192.168.60.32:9200/_cluster/reroute' -d '{ \"commands\" : [ { \"allocate\" : { \"index\" : \"logstash-xxx-up-2019.01.29\", \"shard\" : 9, \"node\" : \"kzI0751OSJBcx_wmLQ\", \"allow_primary\" : true } } ] }' 修改@timestamp类型 curl -XPUT \"http://127.0.0.1:9200/_template/uplog\" -H 'Content-Type: application/json' -H 'Host: elasticsearch.morgans' -d ' { \"index_patterns\": [\"uplog-*\"], \"settings\": { \"index.number_of_replicas\": 0 }, \"mappings\": { \"_default_\": { \"properties\": { \"@timestamp\": { \"type\": \"date\", \"doc_values\": true } } } } }' kibana 安装 优化 踩坑 保存时kibana报错 Visualization Editor: blocked by: [FORBIDDEN/12/index read-only 参考 https://github.com/elastic/kibana/issues/13685 curl -XPUT -H \"Content-Type: application/json\" http://127.0.0.1:9200/.kibana/_settings -d '{\"index.blocks.read_only_allow_delete\": null}' Timelion每次查询得到的数据不一样 参考 https://github.com/elastic/kibana/issues/23428 和 https://discuss.elastic.co/t/timelion-gives-different-result-when-it-auto-refreshes/155182 修改 kibana.yml 配置 elasticsearch.shardTimeout = 30000","tags":"Linux","url":"https://honmaple.me/articles/2018/09/elasticsearch笔记.html","loc":"https://honmaple.me/articles/2018/09/elasticsearch笔记.html"},{"title":"ansible笔记","text":"ansible动态解析inventory ansible 调用inventory模块时总会调用一个文件或脚本来进行处理, 但我想要动态的解析inventory, 即直接传入一个字符串而不是文件, 直接调用ansible的接口来进行解析（不同格式的inventory也可以手动解析，比如yaml格式可以使用pyyaml解析，不过直接使用ansible接口会更方便一些） 但问题是 ansible 没有直接可供调用的接口, 不过可以直接查看ansible源码，找到相应的解析函数，封装一下即可 查找源码, 根据 InventoryManager 传递的 source 变量找到 parse_sources 这个函数 class InventoryManager ( object ): def parse_sources ( self , cache = False ): ''' iterate over inventory sources and parse each one to populate it''' self . _setup_inventory_plugins () ... 然后再根据 def _setup_inventory_plugins ( self ): ''' sets up loaded inventory plugins for usage ''' inventory_loader = PluginLoader ( 'InventoryModule' , 'ansible.plugins.inventory' , C . DEFAULT_INVENTORY_PLUGIN_PATH , 'inventory_plugins' ) ... 找到对应的解析 plugin , 我使用的是 ini 格式的inventory, 所以自定义一下 ansible.plugins.inventory.ini.InventoryModule 这个模块即可 from ansible.plugins.inventory.ini import InventoryModule from ansible.inventory.data import InventoryData from ansible.parsing.dataloader import DataLoader from ansible.module_utils._text import to_text from ansible.template import Templar class InventoryCustomModule ( InventoryModule ): def mine_parse ( self , b_data ): self . loader = DataLoader () self . inventory = InventoryData () self . templar = Templar ( loader = self . loader ) try : data = to_text ( b_data , errors = 'surrogate_or_strict' ) . splitlines () except UnicodeError : data = [] for line in b_data . splitlines (): if line and line [ 0 ] in self . b_COMMENT_MARKERS : data . append ( u '' ) else : data . append ( to_text ( line , errors = 'surrogate_or_strict' )) return self . _parse ( \"\" , data ) 如何使用 : text = ''' \\ [MY-HOST] MY_HOST-1 ansible_ssh_host=127.0.0.1 MY_HOST-2 ansible_ssh_host=127.0.0.2 MY_HOST-3 ansible_ssh_host=127.0.0.3 MY_HOST-4 ansible_ssh_host=127.0.0.4 [MY-HOST:vars] vip=127.0.0.10 ppp=test [MY-HOST1] MY_HOST1-1 ansible_ssh_host=127.0.0.11 MY_HOST1-2 ansible_ssh_host=127.0.0.12 [MY-HOST:children] MY-HOST1 ''' module = InventoryCustomModule () module . mine_parse ( text ) for _ , group in module . inventory . groups . items (): print ( group , group . child_groups , group . vars ) for host in group . hosts : print ( host , host . vars ) 结果 : (ungrouped, [], {}) (all, [ungrouped], {}) (MY-HOST, [MY-HOST1], {u'vip': u'127.0.0.10', u'ppp': u'test'}) (MY_HOST-1, {u'ansible_ssh_host': u'127.0.0.1', 'inventory_file': None, 'inventory_dir': None}) (MY_HOST-2, {u'ansible_ssh_host': u'127.0.0.2', 'inventory_file': None, 'inventory_dir': None}) (MY_HOST-3, {u'ansible_ssh_host': u'127.0.0.3', 'inventory_file': None, 'inventory_dir': None}) (MY_HOST-4, {u'ansible_ssh_host': u'127.0.0.4', 'inventory_file': None, 'inventory_dir': None}) (MY-HOST1, [], {}) (MY_HOST1-1, {u'ansible_ssh_host': u'127.0.0.11', 'inventory_file': None, 'inventory_dir': None}) (MY_HOST1-2, {u'ansible_ssh_host': u'127.0.0.12', 'inventory_file': None, 'inventory_dir': None}) 可以看出已经没什么大的问题了, 但有一个点, all 组下的groups列表只有 ungrouped , 正常情况下 MY-HOST 组也应该继承 all 组, 可能是还需要一些其他的操作吧 ，继续翻源码，找到了 InventoryData 的 reconcile_inventory 方法, 修改一下即可 module = InventoryCustomModule () module . mine_parse ( text ) module . inventory . reconcile_inventory () ansible自定义模块传递list变量会变成字符串 我自定义了一个模块，需要传入一个 list 变量 group_names from ansible.module_utils.basic import AnsibleModule def main (): module = AnsibleModule ( argument_spec = dict ( group_names = { \"required\" : True })) i = module . params . get ( 'group_names' ) msg = { \"group_names\" : i , \"type\" : str ( type ( i ))} module . fail_json ( changed = False , msg = msg ) if __name__ == \"__main__\" : main () 但发现传入的变量最后变成的 str type FAILED! => {\"changed\": false, \"failed\": true, \"msg\": {\"group_names\": \"['test']\", \"type\": \"<type 'str'>\"}} 最后查找资料后才知道, 传递的变量需要增加 type 参数, 否则都是 str module = AnsibleModule ( argument_spec = dict ( group_names = { \"required\" : True , \"type\" : \"list\" }))","tags":"Linux","url":"https://honmaple.me/articles/2018/09/ansible笔记.html","loc":"https://honmaple.me/articles/2018/09/ansible笔记.html"},{"title":"如何保持一个干净的系统","text":"由于工作需要经常会使用多种语言, 比如 python, golang, lua, javascript等, 各种语言都有自己的包管理器，像python的包管理器 pip , lua的包管理器 luarocks 。。。 每个包管理器安装package的方式，位置都不相同，对于一个有洁癖的人来说, ls ~/ -al 后各种各样的 .something 简直是场灾难, 所以保持一个干净的系统是非常必要的, 比如把相关语言的package都放到一个目录(我选择放到 $HOME/repo/{language} )下 请不要使用root用户，或者sudo来安装非必要的软件包 python 我的 python 环境是 pip+virtualenv+virtualenvwrapper , pip 可以有多种使用方式: sudo sudo 安装的package放到 /usr/lib64/python-{verison} 目录下, 这可能会与系统的包管理器所安装的python package冲突, 比如 docker 可以使用 sudo pacman -S docker 也可以使用 sudo pip install docker 但更新系统包时可能有冲突导致无法更新 --user (-U) 使用本地安装，不需要 sudo 权限, 安装的package会放到 $HOME/.local 目录下 virtualenv python的各种依赖包环境分离靠的就是 virtualenv , 它会把安装的 package 放到 $WORKON_HOME 这个环境变量下, 我平时也主要使用这个，但一些常用的package, 像http,docker-compose,pelican等, 我不想在使用时还得 workon {virtualenv name} 然后才能使用, 太麻烦 最有效的方法是搭配 --user 和 virtualenv 设置 --user 的安装目录 export PYTHONUSERBASE = $HOME /repo/python 设置 virtualenv 的安装目录 export WORKON_HOME = $HOME /repo/python/virtualenv source $HOME /repo/python/bin/virtualenvwrapper.sh 设置 PATH 变量 export PATH = $PATH : $HOME /repo/python/bin 然后无论是 pip install package --user 还是 mkvirtualenv 后 pip install package , 所安装的package都会放到 $HOME/repo/python 目录下 golang 与python同理 设置 GOPATH 变量 export GOPATH = $HOME /repo/golang 设置 PATH 变量 export PATH = $PATH : $HOME /repo/python/bin: $HOME /repo/golang/bin lua 设置 luarocks 安装默认参数 alias luarocks = 'luarocks --tree=$HOME/repo/lua' 设置 LUA_PATH 与 LUA_CPATH 变量 export LUA_PATH = \" $HOME /repo/lua/share/lua/5.3/?.lua; $HOME /repo/lua/share/lua/5.3/?/init.lua; $LUA_PATH ;\" export LUA_CPATH = \" $HOME /repo/lua/lib/lua/5.3/?.so; $LUA_CPATH ;\" 设置 PATH 变量 export PATH = $PATH : $HOME /repo/python/bin: $HOME /repo/golang/bin: $HOME /repo/lua/bin javascript 设置 NODE_PATH 变量 export NODE_PATH = $HOME /repo/npm 设置 PATH 变量 export PATH = $PATH : $HOME /repo/python/bin: $HOME /repo/golang/bin: $HOME /repo/lua/bin: $HOME /repo/npm/.bin 最后, 把相关代码放到 $HOME/.bashrc 中, 就可以享受一个相对干净的系统了","tags":"Linux","url":"https://honmaple.me/articles/2018/07/如何保持一个干净的系统.html","loc":"https://honmaple.me/articles/2018/07/如何保持一个干净的系统.html"},{"title":"花落","text":"风落花语风落天 花落风雨花落田 无意间想到的 花落系列 。。。很好听的名字 花落······雨 花落······枫 花落······雾 花落······叶 花落······雪 花落······风 花落······夜 花落······月 花落······己 。。。。","tags":"Life","url":"https://honmaple.me/articles/2018/07/花落.html","loc":"https://honmaple.me/articles/2018/07/花落.html"},{"title":"自定义helm式的ivy","text":"在 n 个月前, 我曾写过 helm与ivy简单对比 , 并吐嘈了 ivy 细节打磨不够，以至于我切换到 ivy 不到几天后, 又回到了 helm 的拥抱, 但在 n 个月后，本着 生命不止，折腾不息 的精神, \"狠狠地\"的折腾了一把 ivy , 让 ivy 也能像 helm 一样\"如丝般润滑\"，适应我平时的操作 吐嘈一: counsel-find-file 我在 dired 中移动文件, 即使已经设置了 :map counsel-find-file-map ( \"C-h\" . counsel-up-directory ) 但 C-h 返回上级目录还是无效 无意中从 spacemacs 中找到了解决办法(我电脑上常备 spacemacs 的配置，当看到 spacemacs 有什么更新都会切换过去尝试一番, 遇到适合自己的配置会\"参考\"一下, 哈), spacemacs 并没有遇到上述问题，在经过查找后，发现有这个一行 ( define-key ivy-minibuffer-map ( kbd \"C-h\" ) ( kbd \"DEL\" )) 转换成我自己的配置就是 :map ivy-minibuffer-map ( \"C-h\" . [ backspace ]) 吐嘈二: tab 键 tab 键我只想要 complete ， 而不是 complete and done , 虽然 ivy 提供了另外的选项 ivy-partial-or-done ,但不是我想要的效果,尤其是把 aaa.py 重命名为 aaa.py.bak 时 关于这一条，真的是\"狠狠\"地折腾了一把, 最终以 胜利 告终 ( defun maple/ivy-done () ( interactive ) ( let (( dir ivy--directory )) ( ivy-partial-or-done ) ( when ( string= dir ivy--directory ) ( ivy-insert-current ) ( when ( and ( eq ( ivy-state-collection ivy-last ) #' read-file-name-internal ) ( setq dir ( ivy-expand-file-if-directory ( ivy-state-current ivy-last )))) ( ivy--cd dir ) ( setq this-command 'ivy-cd ))))) 主要思路就是插入当前选中项, 如果是 read-file-name-internal (文件操作), 并且选中项是一个目录，则列出这个目录的文件，避免选中 tab 两次才能列出文件, 这样一来，第一次 tab 就是 complete , 第二次 tab 才是 done , 最终效果超出预期(V 字手) 吐嘈三: 记忆多个按键 ivy 有这样一个问题,它不会像 helm 一样在第一行显示用户输入的字符，在 ivy 的很多 issue 中都有人提了这个问题，如果当前目录下有名为 aaa 的目录,这是我想要创建一个 aaa.py 的文件，ivy 会列出 aaa 这个目录，那是我该怎么创建 aaa.py 文件。方法是一个新的命令 ivy-immediate-done ,而不是 ivy-alt-done 现在的 ivy 已经支持可选择用户输入 ( setq ivy-use-selectable-prompt t ) 吐嘈四: 模糊搜索 在 helm 中我可以很容易的使用模糊搜索，ivy 中也一样，只要简单的设置 ( setq ivy-re-builders-alist ' (( t . ivy--regex-fuzzy ))) 但 ivy 中有这样一个问题，空格键不能在模糊匹配中使用，/汗，作为从 helm 转入 ivy 的人，经常会不经意间在输入时按下空格键，然后，What? ivy 中搜索变成空了 其实我想要混合使用空格与非空格, 但最终还是没能找到解决办法, 因为我已经适应的使用空格分隔, 所以暂时使用 ( setq ivy-re-builders-alist ' (( t . ivy--regex-ignore-order )) 吐嘈五: 候选词按使用频率排序 这个。。。 吐嘈六: minibuffer helm 从当前 buffer 中弹出 helm-buffer 是多么明智的选择，视野不会移动到当前 buffer 以外的地方，尤其是在屏幕较大的时候, 而 ivy 使用 minibuffer 总是从屏幕左下方弹出 经过多次试验， 最终也找到的解决办法 ;; custom ivy display function ( defvar maple/ivy-format-padding nil ) ( defun maple/ivy-read-around ( -ivy-read &rest args ) \"Advice ivy-read `-IVY-READ` `ARGS`.\" ( let (( maple/ivy-format-padding ( make-string ( window-left-column ) ?\\s ))) ( setcar args ( concat maple/ivy-format-padding ( car args ))) ( apply -ivy-read args ))) ( defun maple/ivy-format-function ( cands ) \"Transform CANDS into a string for minibuffer.\" ( ivy--format-function-generic ( lambda ( str ) ( concat maple/ivy-format-padding ( ivy--add-face str 'ivy-current-match ))) ( lambda ( str ) ( concat maple/ivy-format-padding str )) cands \"\\n\" )) ( advice-add 'ivy-read :around #' maple/ivy-read-around ) ( setq ivy-count-format \"\" ivy-format-function 'maple/ivy-format-function ) 主要思路就是在各个 collections 前添加空格, 空格宽度为 (window-left-column) , window-left-column 按照 help 文档来说就是 Return left column of window WINDOW , 与屏幕左边缘的距离; 然后自定义 ivy-format-function ,即可, 需要注意的一点, 不仅 collections 前需要添加空格, prompt 前也需要添加空格 最终效果 吐嘈七: dired 中复制或重命名文件 我之前想要复制或重命名一个文件，只要进入 dired 中按 C 或 R ，然后选择目标就行，但不知道为什么，使用 ivy 时复制重命名总是报错，不成功 经过测试, 现在的 ivy 表现正常 吐嘈八: sudo edit 使用 ivy 时, sudo edit 不成功 目前已正常 吐嘈九: counsel-ag 默认不会使用已选的单词 counsel-ag , 默认不会使用已选的单词, 想要查找已选单词, 需要在激活 counsel-ag 后使用 M-n , 很麻烦，不像 helm 默认就可以选择 region 里的单词, 另外 counsel-ag 默认会使用含 .git 目录的目录作为根目录进行查找, 这与 counsel-projectile-ag 功能上有些冲突了 解决办法很简单, defadvice counsel-ag 即可 ( defun maple/counsel-ag ( -counsel-ag &optional initial-input initial-directory extra-ag-args ag-prompt ) ( when ( and ( not initial-input ) ( region-active-p )) ( setq initial-input ( buffer-substring-no-properties ( region-beginning ) ( region-end )))) ( unless initial-directory ( setq initial-directory default-directory )) ( funcall -counsel-ag initial-input initial-directory extra-ag-args ag-prompt )) ( advice-add 'counsel-ag :around #' maple/counsel-ag ) 总结 说一说为什么想要折腾 ivy : 在使用 helm 时, 首次打开会很慢(我在打开 emacs 后,习惯使用 helm-recentf 打开最近文件, 但不知道为什么，第一次会非常慢)；另外, 打开 emacs 后， 必须先使用 helm-recentf 才能激活 helm , 如果使用其它 helm 命令, 比如 helm-M-x 或者 helm-projectile 只会使用默认的 ido ， 并不能激活 helm helm 真的为用户做出太多选择， 想要自定义非常难, 即使成功也不是从源头解决，而是用了取巧的办法 速度，不知道是不是我的感觉错误，最新版本的 helm 速度慢了很多 还得吐嘈 ivy : ivy 细节上果然打磨不够, 不过经过调(折)教(腾), 大致上和我之前使用 helm 的习惯一样了 最终吐嘈点: ivy-occur , ivy-occur 使用了 wgrep 作为多文件编辑, 但说实话, 我觉得很难用, 和 helm-ag 自己实现的 helm-ag-edit 比起来更是难受, 一会就要切换一下 ivy-wgrep-change-to-wgrep-mode , 不切用不了, 这个等有时间再折腾吧! ok,就这样","tags":"Linux","url":"https://honmaple.me/articles/2018/06/自定义helm式的ivy.html","loc":"https://honmaple.me/articles/2018/06/自定义helm式的ivy.html"},{"title":"为pelican添加子站点功能","text":"创建翻译 babel-init: cd $( THEMEDIR ) && pybabel extract -F babel.cfg -k lazy_gettext -o messages.pot ./ && pybabel init -i messages.pot -d translations -l en babel-update: cd $( THEMEDIR ) && pybabel extract -F babel.cfg -k lazy_gettext -o messages.pot ./ && pybabel update -i messages.pot -d translations babel-compile: cd $( THEMEDIR ) && pybabel compile -d translations 动态变量 在模板里，我有一些动态变量需要翻译，比如在分类里的 Python 需要翻译成 生活苦短 ,但很不幸, Babel 并不支持动态变量的翻译。 刚开始，在我没使用 i18n_subsites 时，我采用加载一个 i18n.html 文件 {% macro gettext ( string ) - %} {% set _gettext = dict ( python = '人生苦短' , security = '极客安全' , archives = '文章归档' , ) %} {{ _gettext.get ( string.lower (), string ) }} {% - endmacro %} 类似字典的形式对部分变量进行翻译，这能够工作的很好，虽然有些麻烦。 在使用 Babel 之后，我想要把它和 messages.po 统一管理，所以采用另一种比较折中的方案: jinja2 filter from babel import support def gettrans ( text , locale = DEFAULT_LANG ): translations = support . Translations () catalog = support . Translations . load ( os . path . abspath ( os . path . join ( THEME , \"translations\" )), locale ) translations . merge ( catalog ) if hasattr ( catalog , 'plural' ): translations . plural = catalog . plural return translations . gettext ( text ) JINJA_FILTERS = { 'gettrans' : gettrans , } 这样就可以通过传递变量来获取对应的翻译, 而我所需要做的就是写好 messages.po 然后编译成 messages.mo 即可，同样为了每次使用 pybabel update 都可以得到相同的内容，我使用了一种取巧的办法, 同样是 i18n.html 文件，把所需要国际化的可能变量全部放到一起，但不要在其它模板里 import 这个模板，这样每次更新翻译文件，*Babel* 都能自动找到并生成相同的 messages.po 文件 {% macro gettrans ( string ) - %} {% set _gettrans =[ _ ( \"Linux\" ), _ ( \"Python\" ), _ ( \"Security\" ), _ ( \"友链\" ), _ ( \"联系\" )] %} {% - endmacro %} 这种方式同样解决了我的另一个问题: 我可能在中文站点使用的是英文变量，但需要显示翻译后的中文，而在英文站点使用英文变量，显示的却同样是英文。说起来比较绕口，简单来说就是，中文站点里有一个 Python 变量,我需要显示为 人生苦短 ， 而在英文站点，则显示为 Python ，毕竟我可以在 zh_CN/LC_MESSAGES/messages.po 写上翻译后的内容,而在 en/LC_MESSAGES/messages.po 里保持原样,很方便地做到中英文分离。","tags":"Python","url":"https://honmaple.me/articles/2018/06/为pelican添加子站点功能.html","loc":"https://honmaple.me/articles/2018/06/为pelican添加子站点功能.html"},{"title":"看,那是屋檐","text":"听说，抬起头可以看到屋檐 可惜，外面没下雨 听说，外面在下雨 可惜，抬起头没有屋檐","tags":"recall","url":"https://honmaple.me/articles/2018/04/看,那是屋檐.html","loc":"https://honmaple.me/articles/2018/04/看,那是屋檐.html"},{"title":"落花","text":"落花 落花有意随流水 流水无心恋落花 久在门(人)前山间坐 静(坐)看人(世)间二月花","tags":"recall","url":"https://honmaple.me/articles/2018/04/落花.html","loc":"https://honmaple.me/articles/2018/04/落花.html"},{"title":"golang笔记","text":"读取配置文件 注: Configuration 里元素(Path)必须 大写 开头 import ( \"encoding/json\" \"flag\" \"fmt\" \"io/ioutil\" ) type Configuration struct { Path string } const VETSION = \"0.1.0\" var ( config Configuration ) func init () { var ( conf_file string print_ver bool ) flag . StringVar ( & conf_file , \"c\" , \"etc/config.json\" , \"config file\" ) flag . BoolVar ( & print_ver , \"v\" , false , \"config file\" ) flag . Parse () raw , err := ioutil . ReadFile ( conf_file ) if err != nil { log . Error ( \"config parse fail!\" ) os . Exit ( 1 ) } err = json . Unmarshal ( raw , & config ) if err != nil { log . Error ( \"config unmarshal fail!\" ) os . Exit ( 1 ) } if print_ver { fmt . Println ( \"version:\" , VERSION ) os . Exit ( 0 ) } } 判断文件是否存在 import ( \"os\" ) func file_is_exists ( f string ) bool { _ , err := os . Stat ( f ) if os . IsNotExist ( err ) { return false } return err == nil } 随机睡眠 import ( \"math/rand\" \"time\" ) func random_sleep ( t int ) { rand . Seed ( time . Now (). Unix ()) time . Sleep ( time . Duration ( rand . Intn ( t )) * time . Microsecond ) } 字符串 随机的n位字符串 var letterRunes = [] rune ( \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" ) func randStringRunes ( n int ) string { rand . Seed ( time . Now (). UnixNano ()) b := make ([] rune , n ) for i := range b { b [ i ] = letterRunes [ rand . Intn ( len ( letterRunes ))] } return string ( b ) } 字符串连接 import ( \"bytes\" ) func string_concat ( s ... string ) string { var buffer bytes . Buffer for _ , i := range s { buffer . WriteString ( i ) } return buffer . String () } 检查元素是否在map中 func check_in_map ( f map [ string ] string , v string ) bool { if _ , ok := f [ v ]; ok { return true } return false } 检查元素是否在list中 func check_in_list ( f [] string , v string ) bool { for i := range f { if f [ i ] == v { return true } } return false } 执行Linux命令 import ( \"os/exec\" ) func exec_command ( command string , args ... string ) ( error , bool ) { var ( err error ) cmd := exec . Command ( command , args ... ) cmd . Start () done := make ( chan error ) go func () { done <- cmd . Wait () }() select { case <- time . After ( 600 * time . Second ): if err = cmd . Process . Kill (); err != nil { log . Error ( \"failed to kill: %s, error: %s\" , cmd . Path , err ) } go func () { <- done // allow goroutine to exit }() log . Info ( \"process:%s killed\" , cmd . Path ) return err , true case err = <- done : return err , false } } 迭代文件目录 func file_iter ( path string ) [] string { // path must be abs path var files [] string scripts , _ := ioutil . ReadDir ( path ) for _ , script := range scripts { if script . IsDir () { return file_iter ( filepath . Join ( path , script . Name ())) } files = append ( files , filepath . Join ( path , script . Name ())) } return files } 求两列表的差集 func difference ( a , b [] string ) [] string { // len(a) < len(b), avoid all item of a belong to b m := map [ string ] bool {} for _ , x := range a { m [ x ] = true } diff := [] string {} for _ , x := range b { if _ , ok := m [ x ]; ! ok { diff = append ( diff , x ) } } return diff } 删除列表中重复的数据 func RemoveDuplicates ( elements [] string ) [] string { keys := map [ string ] bool {} result := [] string {} for _ , element := range elements { if _ , value := keys [ element ]; ! value { keys [ element ] = true result = append ( result , element ) } } return result } 参数校验 是否是IP func IsValidIP ( key string ) bool { IP := net . ParseIP ( key ) if IP == nil { return false } return true } 是否是EMAIL import \"regexp\" func IsValidEmail ( key string ) bool { re := regexp . MustCompile ( \"&#94;[a-zA-Z0-9.!#$%&'*+/=?&#94;_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$\" ) if ! re . MatchString ( key ) { return false } if strings . HasSuffix ( key , \"@upai.com\" ) || strings . HasSuffix ( key , \"@huaban.com\" ) { return true } return false } 读取http响应的gz package func main () { resp , _ := HTTPRequest ( \"GET\" , \"http://some-gz-package/package-name\" , nil ) defer resp . Body . Close () gz , err := gzip . NewReader ( resp . Body ) if err != nil { fmt . Println ( err . Error ()) return } defer gz . Close () scanner := bufio . NewScanner ( gz ) for scanner . Scan () { fmt . Println ( scanner . Text ()) } }","tags":"Life","url":"https://honmaple.me/articles/2018/03/golang笔记.html","loc":"https://honmaple.me/articles/2018/03/golang笔记.html"},{"title":"日上三竿与夜半三更","text":"日上三竿犹在眠 不是神仙 胜似神仙 很舒服 夜半三更竿犹在醒 不是鬼 胜似鬼 很难受 日上三竿犹在醒 不是鬼 胜似鬼 很难受 夜半三更竿犹在眠 不是神仙 胜似神仙 很舒服","tags":"recall","url":"https://honmaple.me/articles/2018/03/日上三竿与夜半三更.html","loc":"https://honmaple.me/articles/2018/03/日上三竿与夜半三更.html"},{"title":"git笔记","text":"git修改提交作者和邮箱 提交前 如果代码未提交,则可以 git config user.name \"Author Name\" git config user.email \"Author Email\" 提交后 如果代码已经提交,或者已经push到remote(只能修改最近一次提交) git commit --amend --author = \"NewAuthor <NewEmail@address.com>\" 修改全部 commit ,需要使用脚本 参考github官方 #!/bin/sh git filter-branch --env-filter ' OLD_EMAIL=\"your-old-email@example.com\" CORRECT_NAME=\"Your Correct Name\" CORRECT_EMAIL=\"your-correct-email@example.com\" if [ \"$GIT_COMMITTER_EMAIL\" = \"$OLD_EMAIL\" ] then export GIT_COMMITTER_NAME=\"$CORRECT_NAME\" export GIT_COMMITTER_EMAIL=\"$CORRECT_EMAIL\" fi if [ \"$GIT_AUTHOR_EMAIL\" = \"$OLD_EMAIL\" ] then export GIT_AUTHOR_NAME=\"$CORRECT_NAME\" export GIT_AUTHOR_EMAIL=\"$CORRECT_EMAIL\" fi ' --tag-name-filter cat -- --branches --tags 在 .git 同级目录下运行 sh git.sh 然后使用 --force push到远程 合并多个commit历史 git rebase -i commit_id 使用 magit magit-status ll # move to commit id r-ii git删除远程分支已经被删除的本地分支 也不知道为什么， google了很久也没找到答案，明明题目已经清楚的问 如何删除远程分支已经被删除的本地分支? 可下面一群人在答 如何删除本地分支已经被删除的远程分支? 瞎答 最后还是只能靠自己 # 先清理远程分支, 即删除本地分支已经被删除的远程分支 git fetch -p # 找到存在的远程分支 git branch -r | grep -v HEAD | awk -F '/' '{print $2}' > /tmp/test.txt # 清理本地分支 git branch -a | grep -v '\\*' | egrep -v -f /tmp/test.txt | xargs git branch -d 注意: 不要使用 xargs git branch -D 合并pull request git fetch origin pull/3/head:pr git checkou pr","tags":"Linux","url":"https://honmaple.me/articles/2018/03/git笔记.html","loc":"https://honmaple.me/articles/2018/03/git笔记.html"},{"title":"docker笔记","text":"docker删除硬盘残留的文件 使用 docker rmi ... 或者 docker image rm ... 并不能将镜像完全删除，还会一直占用硬盘空间 docker system prune 该命令不会删除已存在镜像(不管是否正在运行) (硬盘一下子多个好几个G, 心情不错) docker构建时禁用缓存 dockerfile 中有多个 RUN 或者 ADD .. 命令时, 每个 RUN 都会创建一个 image, 下一个 image 会以上一个为基础（缓存）继续构建, 可以使用 docker images -a 看到很多 <none> 的 image 不过作为一名有洁癖的coder, 这种情况不能忍 docker build --no-cache -t hello .","tags":"Linux","url":"https://honmaple.me/articles/2018/02/docker笔记.html","loc":"https://honmaple.me/articles/2018/02/docker笔记.html"},{"title":"flask_maple文档","text":"安装 To install Flask-Maple: pip install flask - maple Or alternatively, you can download the repository and install manually by doing: git clone git @github.com : honmaple / flask - maple . git cd flask - maple python setup . py install 用户系统 在 flask_maple/auth/model.py 中默认实现了 GroupMixin 与 UserMixin 如果要创建 user 表与 group 表,只需要 from flask_maple.auth.models import UserMixin , GroupMixin class User ( db . Model , UserMixin ): pass class Group ( db . Model , GroupMixin ): pass 即可 user 表默认创建以下字段, 可添加更多想要的字段 id username password email is_superuser is_confirmed register_time last_login groups group 表默认创建以下字段 id name users parent_group child_groups 权限 使用 from flask_maple.permission.models import PermissionMixin class Permission ( db . Model , PermissionMixin ): pass user 表与 group 表可继承 flask_maple.permission.models.UserMixin 与 flask_maple.permission.models.GroupMixin 或者直接使用 flask_maple.auth.models.UserMixin 与 flask_maple.auth.models.GroupMixin 添加权限 identity = user # or group identity . add_perm ( action , resource , resource_type = 'endpoint' , description = None ) 删除权限 identity . remove_perm ( action , resource , resource_type = 'endpoint' ) 检查权限 identity . has_perm ( action , resource , resource_type = 'endpoint' , and_ = False ) 权限缓存 默认权限会从数据库获取, 如果经常使用，可自行添加缓存, 并在添加删除权限后自行对缓存进行操作 class User ( db . Model , UserMixin ): def perm_cache ( self , action , resource , resource_type = 'endpoint' , and_ = False ): return 登录 依赖于 flask-login , flask-mail 使用 from flask_maple import auth auth . init_app ( app ) # 或者 from flask_maple.auth.views import Auth Auth ( app ) 将会创建6个 url /login /logout /register /forget /confirm /confirm/<token> 可以自定义登陆，注册，忘记密码页面，以登陆页面为例 (templates/maple/login.html) {% extends \"base/base.html\" %} {%- block content -%} {% import 'maple/auth.html' as auth %} < div class = \"panel panel-primary\" > < div class = \"panel-heading\" > < a href = \"{{ url_for('auth.login') }}\" style = \"color:#fff\" > {{ _('Login')}} </ a > </ div > < div class = \"panel-body\" > {{ auth.login()}} </ div > </ div > {% endblock %} 注意事项 登陆与登出默认使用 user.login(remember) , user.logout() , 如果未使用 flask_maple/auth/model.py 中的 UserMixin ,则需要自己定义 验证码 使用 Pillow 生成验证码 pip install pillow 使用 from flask_maple import Captcha captcha = Captcha ( app ) # 因为字体可能存在侵权，所以需要指定自己服务器字体, 默认为 /usr/share/fonts/TTF/DejaVuSans.ttf captcha = Captcha ( app , font = \"\" ) 然后访问 http://127.0.0.1/captcha 配置 CAPTCHA_URL = \"The captcha url,default 'captcha'\" 错误处理 主要是对发生错误时的页面进行定制(403,404,500) from flask_maple import Error error = Error ( app ) 定制图片源于 flask 官网,侵删 邮箱 依赖于 flask-mail , 区别使用多线程发送 from flask_maple.mail import Mail mail = Mail ( app ) mail . send_email ( * args , ** kwargs ) 此外，还有一个 MailMixin ,实现了邮箱验证需要的密钥, from flask_maple.mail import MailMixin class User ( db . Model , MailMixin ): pass print ( user . email_token ) print ( User . check_email_token ( token , max_age = 259200 )) 表单 数据库 像django一样使用 flask-sqlalchemy djang orm 与sqlalchemy相比,为什么很多人都认为django orm更好用,大概就是因为django orm更方便 基本查询(已实现) gt lt lte gte contains in exact iexact startswith istartswith iendswith endswith isnull range year month day 示例: Post . query . filter_by ( title__contains = 'sql' ) . all () Post . query . exclude_by ( title__contains = 'sql' ) . all () 关系查询 Post . query . filter_by ( tags__name__contains = 'sql' ) . all () 其它 Post . query . filter_by ( tags__name__contains = 'sql' ) . or ( Post . id == 1 , Post . id == 2 ) . all () Post . query . filter_by ( tags__name__contains = 'sql' ) . and ( Post . id == 1 , Post . id == 2 ) . all () Post . query . filter_by ( tags__name__contains = 'sql' ) . exists () Post . query . load_only ( 'title' ) 序列化 把 sqlalchemy 对象序列化为 json , 使用方法参考于 django rest framework 多个实例 from flask_maple.serializer import Serializer posts = Post . query . all () serializer = Serializer ( posts ) data = serializer . data 单个实例 post = Post . query . first () serializer = Serializer ( post ) data = serializer . data 排除字段 serializer = Seralizer ( post , exclude = [ 'title' ]) 仅包括字段 serializer = Seralizer ( post , include = [ 'title' ]) 关系查询深度 serializer = Seralizer ( post , depth = 3 ) depth默认为 2 额外的字段 class Post ( Model ): ...... def get_post_count ( self ): return 11 serializer = Serializer ( post , extra = [ 'get_post_count' ]) 自定义 from flask_maple.serializer import Serializer class PostSerializer ( Serializer ): class Meta : include = [] depth = 2 include = [] exclude = [] extra = [ 'count' ] serializer = PostSerializer ( post , include = [ 'title' ]) 中间件 参考于 django from flask_maple.middleware import Middleware app = ... Middleware ( app ) 中间件写法(以一个简单的性能测试中间件为例) class ProfileMiddleware ( object ): def preprocess_request ( self ): pr = cProfile . Profile () pr . enable () request . pr = pr def process_response ( self , response ): pr = request . pr pr . disable () s = StringIO () sortby = 'cumulative' ps = pstats . Stats ( pr , stream = s ) . sort_stats ( sortby ) ps . print_stats () print ( s . getvalue ()) return response 重要 ，需要加入中间件配置 MIDDLEWARE = [\"path.to.ProfileMiddleware\"] 日志 记录 info 和 error 两个日志level, 使用很简单 from flask_maple.log import Logging app = ... Logging ( app ) 配置文件 LOGGING = { 'info' : 'logs/info.log' , # 记录info level的日志,与配置文件同级下的logs目录,可修改 'error' : 'logs/error.log' , # 记录error level的日志 'send_mail' : False , # 当有错误发生时，是否发送邮件到管理员邮箱 'toaddrs' : [], # 管理员邮箱，可为多个 'subject' : 'Your Application Failed' , 'formatter' : ''' Message type: %(levelname)s Location: %(pathname)s : %(lineno)d Module: %(module)s Function: %(funcName)s Time: %(asctime)s Message: %(message)s ''' } 当 send_mail 为 True 时, 配置依赖于 flask_mail 的配置(主要是不想写多份) MAIL_USERNAME MAIL_PASSWORD MAIL_SERVER MAIL_PORT MAIL_DEFAULT_SENDER App 创建两个常用的 url /robots.txt /favicon.ico 使用 from flask_maple.app import App App ( app ) 此外,因为国际化等原因,可以传递 flask_maple.json.CustomJSONEncoder 给App from flask_maple.app import App from flask_maple.json import CustomJSONEncoder App ( app , json = CustomJSONEncoder ) 配置 参考于 django,可以懒加载 blueprint INSTALLED_APPS = [ \"path.to.blueprint1\", \"path.to.blueprint2\", { \"kwargs\":{}, \"blueprint\":{} } ] Bootstrap 主要是个人经常使用的一些模板,比如bootstrap的js,css文件，分页模板, 上下撑满等 并依赖于 flask-assets ,对js,css文件进行压缩 使用 from flask_maple import Bootstrap bootstrap = Bootstrap ( app , css = ( 'styles/monokai.css' , 'styles/mine.css' ), js = ( 'styles/upload.js' , 'styles/forums.js' , 'styles/following.js' , 'styles/topic.js' ), use_auth = True ) 或者 bootstrap = Bootstrap () bootstrap . init_app ( app ) 模板 {% extends 'maple/base.html' %} {% block main -%} < button class = \"btn btn-primary\" > submit </ button > < span class = \"glyphicon glyphicon-search\" aria-hidden = \"true\" ></ span > {% endblock -%} 配置 AUTHOR_NAME = \"This will show you name at html footer\" Redis 默认会加载 rediscluster.StrictRedisCluster ,如果rediscluster未安装则加载 redis.StrictRedis 使用 from flask_maple.redis import Redis redis = Redis ( app ) # 像平时使用redispy一样使用 print ( redis . get ( ... )) 配置 REDSI = {...}","tags":"Python","url":"https://honmaple.me/articles/2018/02/flask_maple文档.html","loc":"https://honmaple.me/articles/2018/02/flask_maple文档.html"},{"title":"lua笔记","text":"lua分割字符串 local ngx_find = ngx . re . find local function split ( str , sep , count ) local t = {} count = count or - 1 local nfield , nstart = 1 , 1 local nfirst , nlast = string.find ( str , sep ) -- local nfirst,nlast = ngx_find(str, sep, \"jo\") while nfirst and count ~= 0 do t [ nfield ] = string.sub ( str , nstart , nfirst - 1 ) nfield = nfield + 1 nstart = nlast + 1 nfirst , nlast = string.find ( str , sep , nstart ) -- nfirst,nlast = ngx_find(str, sep, \"jo\", nil, nstart) count = count - 1 end t [ nfield ] = string.sub ( str , nstart ) return t end","tags":"coding","url":"https://honmaple.me/articles/2018/01/lua笔记.html","loc":"https://honmaple.me/articles/2018/01/lua笔记.html"},{"title":"emacs自动更新文件头","text":"前面已经说过，可以使用 auto-insert 自动添加文件头，今天来说一说自动更新文件头，比如说每次保存时自动更新 last updated 字段 自动更新Last Updated 如果使用的是header2,直接设置相关的变量就可，假如使用的是 auto-insert ，同样也可以使用emacs内置的 time-stamp 对Last Updated进行自动更新 time-stamp默认使用 Time-stamp: ,如果要对 Last Updated 进行自动更新，只需要简单的设置 ( setq time-stamp-active t ) ( setq time-stamp-line-limit 11 ) ( setq time-stamp-start \"[lL]ast[ -][uU]pdate[ \\t]*:?\" ) ( setq time-stamp-end \"\\n\" ) ( setq time-stamp-format \" %#A %Y-%02m-%02d %02H:%02M:%02S (%Z)\" ) 然后添加 ( add-hook 'before-save-hook 'time-stamp ) 这样就能在每次保存时自动更新相应的字段了 自动更新Filename 之前遇到过，使用 auto-insert 在每次创建新文件时自动添加了文件头，但后面文件名被修改了，文件头里的文件名却不会自动更改，基于这个原因需要自己实现一个函数(我没有找到可以使用的已经存在的package) 先理一理逻辑: 只需要查找当前文件前几行信息，如果找到 File Name: 字段，获取字段信息，与当前文件名进行对比，如果不一致则替换为当前文件名,直接给出代码吧 查找当前文件前几行 ( save-excursion ( goto-char ( point-min )) ;;跳转到开头 ( let (( lines 0 )) ( while ( < lines line-limit ) ;; 查找 ( setq lines ( 1+ lines )) ( forward-line 1 )))) 获取当前文件名 ( file-name-nondirectory ( buffer-file-name )) 查找File Name ( looking-at \".*\\\\(File Name:\\\\)\\\\(.*\\\\)\" ) 对文件名进行比对与替换 ( let (( beg ( match-beginning 2 )) ( end ( match-end 2 ))) ( when ( not ( string= 文件名 ( string-trim-left ( match-string 2 )))) ( goto-char beg ) ( delete-region beg end ) ( insert \" \" name ))) 即可得到相关的完整函数(完整函数后面再讲) 自动更新Email 工作和平时使用的邮箱不一样，我虽然设置了 at_home 变量区分工作与平时的邮箱,但不是每次我都记得要更新这个变量，所以有了这个需要，自动将文件头里的email信息更改为平时所用的邮箱，大致逻辑与自动更新Filename相同，所以我写了一个 macro 来自动生成相关的代码 直接给出代码 ( defun maple/header-update-action ( name ) \"A.\" ( let (( beg ( match-beginning 2 )) ( end ( match-end 2 ))) ( when ( not ( string= name ( string-trim-left ( match-string 2 )))) ( goto-char beg ) ( delete-region beg end ) ( insert \" \" name )))) ( defun maple/header-update ( regex default line-limit ) \"B.\" ( interactive ) ( save-excursion ( goto-char ( point-min )) ( let (( lines 0 )) ( while ( < lines line-limit ) ( when ( and ( looking-at regex )) ( maple/header-update-action default )) ( setq lines ( 1+ lines )) ( forward-line 1 ))))) ( defmacro maple/header-update-engine ( name regex default &optional line-limit ) \"C.\" ` ( defun , ( intern ( format \"maple/header-update-%s\" name )) () , ( format \"Update %s with regex.\" name ) ( interactive ) ( maple/header-update , regex , default , ( or line-limit 7 )))) 这样，我就可以调用 macro 来生成代码 自动更新Filename ( maple/header-update-engine \"filename\" \".*\\\\(File Name:\\\\)\\\\(.*\\\\)\" ( file-name-nondirectory ( buffer-file-name )) 7 ) 生成一个 maple/header-update-filename 的函数,只要调用它即可更新文件名信息 自动更新email 同样的 ( maple/header-update-engine \"email\" \".*\\\\(Email:\\\\)\\\\(.*\\\\)\" \"youemail@gmail.com\" 7 ) 生成一个可供调用的 maple/header-update-email 如果想要添加其它功能，只要使用 maple/header-update-engine 即可 相关的配置可以在我的 github 上找到","tags":"Linux","url":"https://honmaple.me/articles/2018/01/emacs自动更新文件头.html","loc":"https://honmaple.me/articles/2018/01/emacs自动更新文件头.html"},{"title":"emacs自动添加文件头","text":"想要在emacs中添加文件头有好几种方法: 直接手打 使用模板yasnippet 使用header2 使用内置的package auto-insert header2可能是最方便的一种自动添加文件头的方式，但我之前使用过，想要自定义自己想要的内容很难，而且白白浪费header2的功能 今天主要说一说emacs内置里 auto-insert ,使用它在创建文件时自动添加文件头信息 基础使用 直接 (auto-insert-mode) 并且设置 (setq auto-insert-query nil) ;; 不提醒 自定义文件头 ( setq auto-insert-alist ' ((( python-mode . \"Python program\" ) nil \"#!/usr/bin/env python\\n\" \"# -*- coding: utf-8 -*-\\n\" \"# **************************************************************************\\n\" \"# Copyright © \" ( substring ( current-time-string ) -4 ) \" \" ( user-full-name ) \"\\n\" \"# File Name: \" ( file-name-nondirectory buffer-file-name ) \"\\n\" \"# Author: \" ( user-full-name ) \"\\n\" \"# Email: \" user-mail-address \"\\n\" \"# Created: \" ( format-time-string \"%Y-%m-%d %T (%Z)\" ( current-time )) \"\\n\" \"# Last Update: \" ( format-time-string \"%Y-%m-%d %T (%Z)\" ( current-time )) \"\\n\" \"# By: \\n\" \"# Description: \\n\" \"# **************************************************************************\\n\" ) (( c-mode . \"C program\" ) nil \"/**************************************************************************\\n\" \" Copyright © \" ( substring ( current-time-string ) -4 ) \" \" ( user-full-name ) \"\\n\" \" File Name: \" ( file-name-nondirectory buffer-file-name ) \"\\n\" \" Author: \" ( user-full-name ) \"\\n\" \" Email: \" user-mail-address \"\\n\" \" Created: \" ( format-time-string \"%Y-%m-%d %T (%Z)\" ( current-time )) \"\\n\" \" Last Update: \\n\" \" By: \\n\" \" Description: \\n\" \" **************************************************************************/\\n\" \"#include<stdio.h>\\n\" \"#include<string.h>\\n\" ) (( sh-mode . \"Shell script\" ) nil \"#!/bin/bash\\n\" \"# **************************************************************************\\n\" \"# Copyright © \" ( substring ( current-time-string ) -4 ) \" \" ( user-full-name ) \"\\n\" \"# File Name: \" ( file-name-nondirectory buffer-file-name ) \"\\n\" \"# Author: \" ( user-full-name ) \"\\n\" \"# Email: \" user-mail-address \"\\n\" \"# Created: \" ( format-time-string \"%Y-%m-%d %T (%Z)\" ( current-time )) \"\\n\" \"# Last Update: \\n\" \"# By: \\n\" \"# Description: \\n\" \"# **************************************************************************/\\n\" ))) 提取文件头公共信息 之前的模板有很多重复的内容，写一个函数把公共的信息提取出来 基础信息 ( defun maple//insert-string () ( concat ( make-string 80 ?* ) \"\\n\" \"Copyright © \" ( substring ( current-time-string ) -4 ) \" \" ( user-full-name ) \"\\n\" \"File Name: \" ( file-name-nondirectory buffer-file-name ) \"\\n\" \"Author: \" ( user-full-name ) \"\\n\" \"Email: \" user-mail-address \"\\n\" \"Created: \" ( format-time-string \"%Y-%m-%d %T (%Z)\" ( current-time )) \"\\n\" \"Last Update: \\n\" \" By: \\n\" \"Description: \\n\" ( make-string 80 ?* ))) 插入注释信息 <2018-03-16 五>更新: ( defun maple/insert-string ( &optional prefix ) ( replace-regexp-in-string \"&#94;\" ( or prefix comment-start ) ( maple//insert-string ))) 原代码: ( defun maple/insert-string ( &optional prefix ) ( or prefix ( setq prefix comment-start )) ( mapconcat ( lambda ( x ) ( concat prefix x )) ( split-string ( maple//insert-string ) \"\\n\" ) \"\\n\" )) 更改模板 ( setq auto-insert-alist ' ((( ruby-mode . \"Ruby program\" ) nil \"#!/usr/bin/env ruby\\n\" \"# -*- encoding: utf-8 -*-\\n\" ( maple/insert-string ) \"\\n\" ) (( python-mode . \"Python program\" ) nil \"#!/usr/bin/env python\\n\" \"# -*- coding: utf-8 -*-\\n\" ( maple/insert-string ) \"\\n\" ) (( c-mode . \"C program\" ) nil \"/*\" ( string-trim-left ( maple/insert-string \" \" )) \"*/\\n\" \"#include<stdio.h>\\n\" \"#include<string.h>\\n\" ) (( sh-mode . \"Shell script\" ) nil \"#!/bin/bash\\n\" ( maple/insert-string ) \"\\n\" ) (( go-mode . \"Go program\" ) nil \"/*\" ( string-trim-left ( maple/insert-string \" \" )) \"*/\\n\" ))) 相关的配置可以在我的 github 上找到","tags":"Linux","url":"https://honmaple.me/articles/2018/01/emacs自动添加文件头.html","loc":"https://honmaple.me/articles/2018/01/emacs自动添加文件头.html"},{"title":"helm与ivy简单对比","text":"我为什么放弃ivy回到了helm 说一说ivy用的不爽的地方吧 counsel-find-file counsel-find-file作为最常用的命令,ivy竟然没有把默认的find-file进行覆写，比如我在dired中想要复制文件，我习惯使用 C-h 退回上一个目录，但即使我之前已经设置了 :map counsel-find-file-map ( \"C-h\" . counsel-up-directory ) 但只有在使用 counsel-find-file 时有效,类似dired中是无效的，相比较于 helm-find-files 把 find-file 进行覆写，无论何时都能使用自己自定义的按键，这很不爽 tab键 在 helm 中，tab仅作为补全使用，想要打开选中项，则需要按一下 enter 键,而在 ivy 中，我不知道开发者怎么想的, 我需要记住两个或两个以上的按键 。 在ivy中，tab键就像命令名称 ivy-alt-done 一样，意味着按一下tab,就能得到helm中tab and enter的效果。 这很方便是不是？ 但是，如果我要在emacs中重命名一个文件，把 aaa.py 重命名为 aaa.py.bak ，这该怎么办，在helm中我可以很容易的重命名，因为tab只是补全，我在tab后输入 .bak 然后enter就行，在ivy中，我得一个字符一个字符手打，或者记住其它按键补全选中项，然后才能重命名 记忆多个按键 ivy有这样一个问题,它不会像helm一样在第一行显示用户输入的字符，在ivy的很多issue中都有人提了这个问题，如果当前目录下有名为 aaa 的目录,这是我想要创建一个 aaa.py 的文件，ivy会列出aaa这个目录，那是我该怎么创建aaa.py文件。方法是一个新的命令 ivy-immediate-done ,而不是 ivy-alt-done 模糊搜索 在helm中我可以很容易的使用模糊搜索，ivy中也一样，只要简单的设置 ( setq ivy-re-builders-alist ' (( t . ivy--regex-fuzzy ))) 但ivy中有这样一个问题，空格键不能在模糊匹配中使用，/汗，作为从helm转入ivy的人，经常会不经意间在输入时按下空格键，然后，What? ivy中搜索变成空了 候选词按使用频率排序 helm默认支持，但在ivy中我需要安装 smex ，只安装 smex ，又不需要什么配置，文档也没有提供（这是我摸索出来的），有些莫名其妙 minibuffer 这是我对ivy种草的原因，从 minibuffer 中弹出待选项，多么帅气，哪里像helm，使用一个buffer作为弹出框，还带一个\"丑丑\"的 mode-line ，但后面仔细研究后，才发现helm从当前buffer中弹出helm-buffer是多么明智的选择，视野不会移动到当前buffer以外的地方，尤其是在屏幕较大的时候 dired中复制或重命名文件 我之前想要复制或重命名一个文件，只要进入 dired 中按 C 或 R ，然后选择目标就行，但不知道为什么，使用ivy时复制重命名总是报错，不成功(后面也没有继续折腾) sudo edit 我从 spacemacs 中复制了一段代码 ( defun file/sudo-edit ( &optional arg ) ( interactive \"p\" ) ( let (( fname ( if ( or arg ( not buffer-file-name )) ( read-file-name \"File: \" ) buffer-file-name ))) ( find-file ( cond (( string-match-p \"&#94;/ssh:\" fname ) ( with-temp-buffer ( insert fname ) ( search-backward \":\" ) ( let (( last-match-end nil ) ( last-ssh-hostname nil )) ( while ( string-match \"@\\\\\\([&#94;:|]+\\\\\\)\" fname last-match-end ) ( setq last-ssh-hostname ( or ( match-string 1 fname ) last-ssh-hostname )) ( setq last-match-end ( match-end 0 ))) ( insert ( format \"|sudo:%s\" ( or last-ssh-hostname \"localhost\" )))) ( buffer-string ))) ( t ( concat \"/sudo:root@localhost:\" fname )))))) 可以很容易地使用 sudo 对文件进行进行编辑，但使用ivy时不成功，印象分又 -1 helm中也有用的不爽的地方，比如: 有个header-line是什么鬼 设置了 helm-display-header-line 为 nil 还是有，字体那么大，背景那么丑，显示出来干嘛，虽然后面设置 height 为 0.1 解决 在mode-line显示help信息干嘛 我已經对helm很熟悉了，不需要这些help info，后面设置 spaceline-helm-help-p 为 nil 解决 multi source 我不知道这对谁有用，反正对我没用 ... 另外，很多人提到的ivy速度要比helm快，这个就仁者见仁，智者见智了，如果说的是启动速度，我的emac配置已经优化为1s内启动，如果是弹出速度，我没有具体对比过，不过就个人而言，helm与ivy弹出速度感觉两者都差不多 总之，helm大而全，ivy小而精，但helm有过多的为用户做出选择，ivy在细节上打磨的不太够，哪个用得爽就选谁吧，反正我用 helm !","tags":"Linux","url":"https://honmaple.me/articles/2018/01/helm与ivy简单对比.html","loc":"https://honmaple.me/articles/2018/01/helm与ivy简单对比.html"},{"title":"关于时间与空间的猜想","text":"背景 不知道从何时开始，就听过这样一个说法: 如果人类所达到的速度超越光速,那么人类将穿越时空。前些年网文电视剧可谓穿越盛行，今天我也来胡言乱语一番! 胡言乱语 光从某一 点x 出发，在其经过的路径范围内，有一不同于光所在 空间y 的 空间z ，z的时间流速与y空间的时间流速不一样，或者说 z空间的时间流速小于于y空间的流速 ，即z空间一天，y空间一年。 由此就可发现，当y空间内的光从x点出发，在经过z空间范围内时，由于在z，y空间时间流速不一致，原本到达 k点 (x到k的距离大于x到z空间的距离)所花费的时间为1s，但z空间的存在，需要花费0.3s才能通过z空间的范围，现在只需要 远小于0.3s 的时间就能通过z空间的范围。 相对于y空间而言，原本需要花费1s才能到达k点，现在也许只需要0.8s，如果简单按照速度公式v=S/t,光速将超越299792458m/s,相对而言，y空间与z空间也会有所谓的穿越。 当然，z空间也可以看作是一个y空间里的一个介质，光速不能通过简单的线性公式算出，反正我是在胡言乱语而已","tags":"Life","url":"https://honmaple.me/articles/2018/01/关于时间与空间的猜想.html","loc":"https://honmaple.me/articles/2018/01/关于时间与空间的猜想.html"},{"title":"linux笔记","text":"记录 设置临时英文环境变量 LANG = \"en_US.UTF-8\" git branch 2 > /dev/null linux下gif播放 feh 只支持静态文件,可用 animate output.gif supervisor增加新配置不重启 supervisorctl reread supervisorctl update 文件操作 zip打包排除文件 zip -r -x=.git/* -x=*.pyc ../release.py * 获取文件压缩后的md5 tar -cf - action_plugins/ group_vars/ | md5sum ag仅查找目录 https://github.com/ggreer/the_silver_searcher/issues/379 ag -G --file-search-regex *.txt /home/username Find 参考 find /tmp -name test # 查询tmp目录下test文件 find /tmp -name test # 查询tmp目录下以test开头的文件 find /etc -name test?? # 查询tmp目录下以test开头并且文件名为6位字母的文件 find /tmp -user test # 查询test用户在tmp目录下创建的文件 find /tmp -size +204800 # 查询tmp目录下大于100MB的文件 find /tmp -size -20480 # 查询tmp目录下小于10MB的文件 find /tmp -size +20480 && -size -204800 # 查询tmp目录下大于100MB的文件并且小于10MB的文件 find /tmp -size +20480 -a -size -204800 # 同上 find /tmp -amin -10 # 查询10分钟之前访问的文件 find /tmp -mmin -10 # 查询10分钟之内修改的文件 find /tmp -cmin -10 # 查询10分钟之内属性被修改的文件 替换&#94;M字符 sed -i -e 's/&#94;M//g' file # or sed -i -e 's/&#94;M//g' directory/* 注意: 这里的 &#94;M 要使用 CTRL-V CTRL-M 生成，而不是直接键入 &#94;M NET 网络相关的笔记 SSH git clone时不提示Are you sure you want to continue connecting (yes/no)? ~/.ssh/config Host github.com StrictHostKeyChecking no curl curl请求指定IP的http域名 curl http://ip:port/test -H 'host:example.com' curl请求指定IP的https域名 curl https://example.com/test --resolve 'example.com:443:ip' curl请求搭配grep查询 curl http://192.168.60.32:9200/_cat/indices?v 2>&1 | grep updns curl请求form curl -d \"param1=value1&param2=value2\" -X POST http://localhost:3000/data 或者 curl -d \"param1=value1&param2=value2\" -H \"Content-Type: application/x-www-form-urlencoded\" -X POST http://localhost:3000/data Disk 磁盘相关笔记, 包括分区，挂载，磁盘清理修复等 thunar提示\"not authorized to perform operation\" 之前我一直参考 http://blog.chinaunix.net/uid-25906175-id-3030600.html , 通过修改 /usr/share/polkit-1/actions/org.freedesktop.udisks.policy 中 filesystem-mount-system 的 auth_admin_keep 为 yes , 但最近(2018-8-2)更新重启后这种方法无法成功 后来参考这里 https://wiki.archlinux.org/index.php/Polkit#Authentication_agents 和 https://askubuntu.com/questions/487911/thunar-not-authorized-to-acces-mounted-volumes , 通过安装 Authentication_agents 并启动 /usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1 数据库 设置mysql的密码小于8字符 ERROR 1819 (HY000): Your password does not satisfy the current policy requirements SET GLOBAL validate_password_policy = 'LOW' ; LOW 政策只测试密码长度。 密码必须至少有8个字符长。 MEDIUM 政策的条件 密码必须包含至少1数字字符,1 大写和小写字符,和1特别 (nonalphanumeric)字符。 STRONG 政策的情况 密码子字符串长度为4的或更长时间不能匹配 单词在字典文件中,如果一个人被指定。 SET GLOBAL validate_password_length = 6 ; ALTER USER 'test_user' @ 'localhost' IDENTIFIED BY 'test_password' ; 修改postgresql字段长度 :postgresql:linux: ALTER TABLE \"user\" ALTER COLUMN password TYPE character varying ( 256 );","tags":"Linux","url":"https://honmaple.me/articles/2017/12/linux笔记.html","loc":"https://honmaple.me/articles/2017/12/linux笔记.html"},{"title":"十二月十日小记","text":"今天真是不错的一天 今天出门，在电梯遇到一人，\"小伙子，你有二十了吧\"，\"我今年二十X了\"，\"我看你不到二十的样子\"，\"我以为我看起来挺老的\"，\"怎么会。。。\" 以前只是在电视新闻上看到有人直接撞到玻璃门上，其实真不怪他们，有时候玻璃门真看起来没有一样。我今天就这样直接撞上去了，说实话，还真疼 附几张今天用手机拍的照片，昨天用相机拍的raw格式暂时打不开/捂脸","tags":"Life","url":"https://honmaple.me/articles/2017/12/十二月十日小记.html","loc":"https://honmaple.me/articles/2017/12/十二月十日小记.html"},{"title":"python尾递归优化","text":"参考 这里 class TailRecurseException ( BaseException ): def __init__ ( self , args , kwargs ): self . args = args self . kwargs = kwargs def tail_call_optimized ( g ): \"\"\" This function decorates a function with tail call optimization. It does this by throwing an exception if it is it's own grandparent, and catching such exceptions to fake the tail call optimization. This function fails if the decorated function recurses in a non-tail context. \"\"\" def func ( * args , ** kwargs ): f = sys . _getframe () # 为什么是grandparent, 函数默认的第一层递归是父调用, # 对于尾递归, 不希望产生新的函数调用(即:祖父调用), # 所以这里抛出异常, 拿到参数, 退出被修饰函数的递归调用栈!(后面有动图分析) if f . f_back and f . f_back . f_back \\ and f . f_back . f_back . f_code == f . f_code : # 抛出异常 raise TailRecurseException ( args , kwargs ) else : while 1 : try : return g ( * args , ** kwargs ) except TailRecurseException as e : # 捕获异常, 拿到参数, 退出被修饰函数的递归调用栈 args = e . args kwargs = e . kwargs func . __doc__ = g . __doc__ return func 测试 @tail_call_optimized def factorial ( n , acc = 1 ): \"calculate a factorial\" from pudb import set_trace set_trace () if n == 0 : return acc return factorial ( n - 1 , n + acc ) print factorial ( 10000 )","tags":"coding","url":"https://honmaple.me/articles/2017/12/python尾递归优化.html","loc":"https://honmaple.me/articles/2017/12/python尾递归优化.html"},{"title":"使用tornado实时输出日志","text":"import tornado from tornado.web import Application from tornado.web import RequestHandler from tornado.websocket import WebSocketHandler import os import json template = '''<!doctype html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"/> <title>Document</title> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"> <script src=\"https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js\"></script> <script src=\"https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js\"></script> <link rel=\"stylesheet\" href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\"> <script type=\"text/javascript\" charset=\"utf-8\"> $(function() { if (typeof String.prototype.startsWith != 'function') { String.prototype.startsWith = function (prefix){ return this.slice(0, prefix.length) === prefix; }; } var output = $(\"#stdout-output\").html(); function addToOutput(msg) { /* output = $(\"#output\").html() + '<br/>' + msg;*/ if (msg.startsWith('stderr:')) { if (!$('a[href=\"#stderr\"]').hasClass(\"alarm-report\") && $('ul[role=\"tablist\"] li.active a').attr('href') != '#stderr') { $('a[href=\"#stderr\"]').addClass(\"alarm-report\") } output = $(\"#stderr-output\").html() + msg.replace(/&#94;stderr:/,''); $(\"#stderr-output\").html(output); $('#stderr-output').scrollTop($('#stderr-output')[0].scrollHeight); }else { if (!$('a[href=\"#stdout\"]').hasClass(\"alarm-report\") && $('ul[role=\"tablist\"] li.active a').attr('href') != '#stdout') { $('a[href=\"#stdout\"]').addClass(\"alarm-report\") } output = $(\"#stdout-output\").html() + msg.replace(/&#94;stdout:/,''); $(\"#stdout-output\").html(output); $('#stdout-output').scrollTop($('#stdout-output')[0].scrollHeight); } } $('a#clear').click(function() { var active_tab = $('ul[role=\"tablist\"] li.active a').attr('href'); $(active_tab + '-output').html(''); }) $('a#load').click(function() { var active_tab = $('ul[role=\"tablist\"] li.active a').attr('href'); ws.send(JSON.stringify({room:'load',msg:active_tab.replace(/&#94;#/,'')})); }) $('a[data-toggle=\"tab\"]').on('shown.bs.tab', function (e) { if ($(e.target).hasClass(\"alarm-report\")) { $(e.target).removeClass(\"alarm-report\") } }) if (\"MozWebSocket\" in window) { WebSocket = MozWebSocket; } if (WebSocket) { var ws = new WebSocket(\"ws:// %s /show\"); ws.onopen = function() {}; ws.onmessage = function (evt) { addToOutput(evt.data); }; ws.onclose = function() {}; } else { alert(\"WebSocket not supported\"); } }) </script> <style type=\"text/css\"> .input-group { margin-bottom: 5px; } .input-group-addon { background-color:#337ab7; color:#fff; border-color:#337ab7; } li[aria-selected=\"true\"] { display:none; } li[role=\"presentation\"] a{ border-bottom-left-radius:0; border-bottom-right-radius:0; } .well { color:#eee; border-top:0; border-top-left-radius:0; border-top-right-radius:0; } #stdout-output,#stderr-output { background-color:#333; height:600px; overflow-y:auto; padding:10px; } .alarm-report { border:2px solid #333; border-bottom:none; animation: flash 1s linear infinite; } @keyframes flash{ from { border-color: #333; } to { border-color: red; } } </style> </head> <body> <div class=\"row\"> <div class=\"col-md-offset-2 col-md-8\"> <!-- Nav tabs --> <ul class=\"nav nav-pills nav-justified\" role=\"tablist\"> <li role=\"presentation\" class=\"active\"> <a href=\"#stdout\" aria-controls=\"stdout\" role=\"tab\" data-toggle=\"tab\">标准输出</a> </li> <li role=\"presentation\"> <a href=\"#stderr\" aria-controls=\"stderr\" role=\"tab\" data-toggle=\"tab\">错误输出</a> </li> <li role=\"presentation\"> <a href=\"javascript:void(0);\" id=\"load\">载入历史</a> </li> <li role=\"presentation\"> <a href=\"javascript:void(0);\" id=\"clear\">清空</a> </li> </ul> <!-- Tab panes --> <div class=\"tab-content\"> <div role=\"tabpanel\" class=\"tab-pane active\" id=\"stdout\"> <pre contentEditable=\"false\" class=\"well\" id=\"stdout-output\"></pre> </div> <div role=\"tabpanel\" class=\"tab-pane\" id=\"stderr\"> <pre contentEditable=\"false\" class=\"well\" id=\"stderr-output\"></pre> </div> </div> </div> </div> </body> </html> ''' def create_app (): handlers = [( r \"/\" , AnsibleHandler ), ( r '/show' , CommandHandler )] app = Application ( handlers = handlers , debug = True , cookie_secret = 'asdadasdadasdasdasda' ) return app class cd ( object ): def __init__ ( self , newPath ): self . newPath = os . path . expanduser ( newPath ) def __enter__ ( self ): self . savedPath = os . getcwd () os . chdir ( self . newPath ) def __exit__ ( self , etype , value , traceback ): os . chdir ( self . savedPath ) class AnsibleHandler ( RequestHandler ): def get ( self ): self . write ( template % ( self . request . host )) class CommandHandler ( WebSocketHandler ): def open ( self ): print ( \"WebSocket opened\" ) LISTENERS . append ( self ) def on_message ( self , message ): message = json . loads ( message ) # self.write_message(u\"You said: \" + message['msg']) if message [ 'room' ] == 'load' : out_file = STDOUT_FILENAME if message [ 'msg' ] == 'stdout' else STDERR_FILENAME if os . path . getsize ( out_file ) > 10240000 : self . write_message ( 'file is too large!' ) else : with open ( out_file , 'r' ) as f : f . seek ( 0 , os . SEEK_END ) fsize = f . tell () f . seek ( max ( fsize - 1024 , 0 ), 0 ) for line in f . readlines ()[ - 800 :]: self . write_message ( '{}:{}' . format ( message [ 'msg' ], line )) def on_close ( self ): print ( \"WebSocket closed\" ) try : LISTENERS . remove ( self ) except : pass def tail_file (): where = stdout_file . tell () line = stdout_file . readline () if not line : stdout_file . seek ( where ) else : for element in LISTENERS : element . write_message ( 'stdout:{}' . format ( line )) where = stderr_file . tell () line = stderr_file . readline () if not line : stderr_file . seek ( where ) else : for element in LISTENERS : element . write_message ( 'stderr:{}' . format ( line )) if __name__ == '__main__' : STDOUT_FILENAME = 'logs/tail.log' STDERR_FILENAME = 'logs/tail_err.log' STDOUT_FILENAME = os . path . abspath ( STDOUT_FILENAME ) STDERR_FILENAME = os . path . abspath ( STDERR_FILENAME ) LISTENERS = [] stdout_file = open ( STDOUT_FILENAME ) stderr_file = open ( STDERR_FILENAME ) stdout_file . seek ( os . path . getsize ( STDOUT_FILENAME )) stderr_file . seek ( os . path . getsize ( STDERR_FILENAME )) app = create_app () http_server = tornado . httpserver . HTTPServer ( app ) http_server . listen ( 8000 , '0.0.0.0' ) tailed_callback = tornado . ioloop . PeriodicCallback ( tail_file , 5 ) tailed_callback . start () io_loop = tornado . ioloop . IOLoop . instance () try : io_loop . start () except SystemExit as KeyboardInterrupt : io_loop . stop () stdout_file . close () stderr_file . close ()","tags":"coding","url":"https://honmaple.me/articles/2017/11/使用tornado实时输出日志.html","loc":"https://honmaple.me/articles/2017/11/使用tornado实时输出日志.html"},{"title":"一个很好的想法","text":"我有这样一个想法 有这么一个 app 它可以自定义表单，然后保存到本地或者远程数据库 还可以填写一个远程url，验证的token，或者其他验证需要的header信息 填好之后就可以提交相关的表单 好吧,其实是写说说，写博客使用的 它还有另外一个功能: 上传图片 同样是先填写远程url,验证信息 填写其它相关信息 选择本地图片进行上传 上传成功后返回相应的url链接 好吧,越来越像朋友圈和QQ空间了 但是，它可以自定义发布和上传的url呀! 最后，如果要更大，更远一些，可以对使用者的博客等内容进行相应的聚合,分类,成为一个优质的移动聚合平台. 嗯，好想法，就等谁实现了","tags":"Life","url":"https://honmaple.me/articles/2017/11/一个很好的想法.html","loc":"https://honmaple.me/articles/2017/11/一个很好的想法.html"},{"title":"我走过的地方，每一处都是风景","text":"杭州还是挺美的,不过有些拍不出那种感觉","tags":"Life","url":"https://honmaple.me/articles/2017/10/我走过的地方，每一处都是风景.html","loc":"https://honmaple.me/articles/2017/10/我走过的地方，每一处都是风景.html"},{"title":"为pelican增加上一篇下一篇功能","text":"功能实现很简单, pelican 也有类似的插件实现 https://github.com/getpelican/pelican-plugins/tree/master/neighbors 不过自己实现起来更爽不是吗? 而且类似 prev_article_in_category 和 prev_article_in_subcategory 的功能我并不需要 首先参考 pelican 的文档,基础实现 def add_neighbors ( generator ): .... def register (): signals . article_generator_finalized . connect ( add_neighbors ) 然后在 generator.articles 列表上进行操作,为article增加 previous_article 和 next_article 对象 先进行排序(按时间) articles = generator . articles articles . sort ( key = ( lambda x : x . date ), reverse = True ) 然后可以使用 iter 关键字,把列表变成生成器,使用next()( python2用a.next(),python3用a.__next__() )获取下一个可迭代对象 pre_article = None articles_iter = iter ( articles [ 1 :]) for article in articles : next_article = next ( articles_iter , None ) setattr ( article , 'previous_article' , pre_article ) setattr ( article , 'next_article' , next_article ) pre_article = article 最后，在模板template中增加相关html代码，示例: {% if article.previous_article %} < li class = \"previous\" > < a href = \"{{ SITEURL }}/{{ article.previous_article.url }}\" title = \"Previous article: {{ article.previous_article.title }}\" > < i class = \"fa fa-chevron-left\" ></ i > {{ article.previous_article.title }} </ a > </ li > {% endif %} {% if article.next_article %} < li class = \"next\" > < a href = \"{{ SITEURL }}/{{ article.next_article.url }}\" title = \"Next article: {{ article.previous_article.title }}\" > {{ article.next_article.title }} < i class = \"fa fa-chevron-right\" ></ i > </ a > </ li > {% endif %} ok,就这样","tags":"Python","url":"https://honmaple.me/articles/2017/10/为pelican增加上一篇下一篇功能.html","loc":"https://honmaple.me/articles/2017/10/为pelican增加上一篇下一篇功能.html"},{"title":"时间format输出格式参考","text":"date --help %% 一个文字的 % %a 当前locale 的星期名缩写(例如： 日，代表星期日) %A 当前locale 的星期名全称 (如：星期日) %b 当前locale 的月名缩写 (如：一，代表一月) %B 当前locale 的月名全称 (如：一月) %c 当前locale 的日期和时间 (如：2005年3月3日 星期四 23:05:25) %C 世纪；比如 %Y，通常为省略当前年份的后两位数字(例如：20) %d 按月计的日期(例如：01) %D 按月计的日期；等于%m/%d/%y %e 按月计的日期，添加空格，等于%_d %F 完整日期格式，等价于 %Y-%m-%d %g ISO-8601 格式年份的最后两位 (参见%G) %G ISO-8601 格式年份 (参见%V)，一般只和 %V 结合使用 %h 等于%b %H 小时(00-23) %I 小时(00-12) %j 按年计的日期(001-366) %k hour, space padded ( 0..23); same as %_H %l hour, space padded ( 1..12); same as %_I %m month (01..12) %M minute (00..59) %n a newline %N nanoseconds (000000000..999999999) %p locale's equivalent of either AM or PM; blank if not known %P like %p, but lower case %q quarter of year (1..4) %r locale's 12-hour clock time (e.g., 11:11:04 PM) %R 24-hour hour and minute; same as %H:%M %s seconds since 1970-01-01 00:00:00 UTC %S 秒(00-60) %t 输出制表符 Tab %T 时间，等于%H:%M:%S %u 星期，1 代表星期一 %U 一年中的第几周，以周日为每星期第一天(00-53) %V ISO-8601 格式规范下的一年中第几周，以周一为每星期第一天(01-53) %w 一星期中的第几日(0-6)，0 代表周一 %W 一年中的第几周，以周一为每星期第一天(00-53) %x 当前locale 下的日期描述 (如：12/31/99) %X 当前locale 下的时间描述 (如：23:13:48) %y 年份最后两位数位 (00-99) %Y 年份 %z +hhmm 数字时区(例如，-0400) %:z +hh:mm 数字时区(例如，-04:00) %::z +hh:mm:ss 数字时区(例如，-04:00:00) %:::z 数字时区带有必要的精度 (例如，-04，+05:30) %Z 按字母表排序的时区缩写 (例如，EDT) http://www.cplusplus.com/reference/ctime/strftime/ specifier Replaced by Example %a Abbreviated weekday name * Thu %A Full weekday name * Thursday %b Abbreviated month name * Aug %B Full month name * August %c Date and time representation * Thu Aug 23 14:55:02 2001 %C Year divided by 100 and truncated to integer (00-99) 20 %d Day of the month, zero-padded (01-31) 23 %D Short MM/DD/YY date, equivalent to %m/%d/%y 08/23/01 %e Day of the month, space-padded ( 1-31) 23 %F Short YYYY-MM-DD date, equivalent to %Y-%m-%d 2001-08-23 %g Week-based year, last two digits (00-99) 01 %G Week-based year 2001 %h Abbreviated month name * (same as %b) Aug %H Hour in 24h format (00-23) 14 %I Hour in 12h format (01-12) 02 %j Day of the year (001-366) 235 %m Month as a decimal number (01-12) 08 %M Minute (00-59) 55 %n New-line character ('\\n') %p AM or PM designation PM %r 12-hour clock time * 02:55:02 pm %R 24-hour HH:MM time, equivalent to %H:%M 14:55 %S Second (00-61) 02 %t Horizontal-tab character ('\\t') %T ISO 8601 time format (HH:MM:SS), equivalent to %H:%M:%S 14:55:02 %u ISO 8601 weekday as number with Monday as 1 (1-7) 4 %U Week number with the first Sunday as the first day of week one (00-53) 33 %V ISO 8601 week number (01-53) 34 %w Weekday as a decimal number with Sunday as 0 (0-6) 4 %W Week number with the first Monday as the first day of week one (00-53) 34 %x Date representation * 08/23/01 %X Time representation * 14:55:02 %y Year, last two digits (00-99) 01 %Y Year 2001 %z ISO 8601 offset from UTC in timezone (1 minute=1, 1 hour=100),If timezone cannot be determined, no characters +100 %Z Timezone name or abbreviation *,if timezone cannot be determined, no characters CDT %% A % sign %","tags":"coding","url":"https://honmaple.me/articles/2017/10/时间format输出格式参考.html","loc":"https://honmaple.me/articles/2017/10/时间format输出格式参考.html"},{"title":"lua中匪夷所思的table长度","text":"s = { 1 , 2 , 3 , 4 , 5 , 6 } print ( # s ) -- output: 6 s [ 4 ] = nil print ( # s ) -- output: 6 s [ 7 ] = nil print ( # s ) -- output: 3 s [ 4 ] = 4 print ( # s ) -- output: 6 s [ 4 ] = nil print ( # s ) -- output: 3 print () s = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" , \"6\" } print ( # s ) -- output: 6 s [ \"4\" ] = nil print ( # s ) -- output: 6 s [ \"7\" ] = nil print ( # s ) -- output: 6 s [ \"4\" ] = \"4\" print ( # s ) -- output: 6 s [ \"4\" ] = nil print ( # s ) -- output: 6 Lua 5.3.4 输出就是这么匪夷所思,所以, 不要在Lua的table中使用nil值，如果一个元素要删除，直接remove","tags":"Linux","url":"https://honmaple.me/articles/2017/10/lua中匪夷所思的table长度.html","loc":"https://honmaple.me/articles/2017/10/lua中匪夷所思的table长度.html"},{"title":"ansible快速部署加速方案","text":"ansible是基于Python的 自动化部署 方案,但是目前只是通过命令行 ansible -i hosts all -a 'uptime' # or ansible-playbook -i hosts playbook.yml -e 'args' -t deploy 实现自动化部署. 长此以往，虽然可以实现所谓的自动化，但产品业务线多且杂的情况下，项目很难维护，更不用说以文件为存储的表现形式很差,针对目前使用ansible的经验以及使用中的困难,可以针对性的提出一些解决方案 加速 问题 自动化部署其中最大的障碍就是 网络 的原因 其中需要通过网络上传一些模板文件,有的甚至还需要上传一些压缩包,虽然说几MB的东西很快就能上传成功，但如果把这上传文件所需要的2秒乘以上百，上千台主机呢,更不用说ansible的表现形式就是一个任务一个任务的往下执行,假如在上传模板这一步卡住(等待所有服务器上传成功),这时某台未模板化的服务器的某服务需要重启，是不是会出问题呢 方案 针对这一问题,目前想到的解决方案如下: 适当增加fork数 目前fork数默认为50，可以适当增加 大文件使用内网(外网)下载 从部署机上上传文件可能会出现这样那样的问题，尤其是上传到国外服务器时经常会出现ansible playbook的任务卡住问题(其实是正在以几KB/s的龟速运行)，所以其中大于xxMB的文件(压缩包)全部使用从远程服务器上下载方式,并且全部进行加密处理 把超过几百台服务器的节点分组多进程运行 服务器一旦多了，对应任务的等待时间也就多了，所以将500台的节点分为十组，每组50台,使用多进程分别同时运行，这样可以有效减少任务等待时间,需要注意每组运行失败的服务器。 把经常出问题或者网络不太好的节点放到最后运行 像中国移动以及香港，国外的某些节点在运行ansible playbook的时候总会或多或少的出些问题,这些节点可以考虑放到最后,并且需要找出问题原因进行优化 目标 web界面 使用过ansible的同学一定知道ansible-tower，它是ansible的web方式部署，通过web界面就可以添加删除任务,并且运行ansible playbook,可惜，它是收费的 /捂脸 任务队列 把ansible playbook放到任务队列里，由消费者去消费对应的任务 未完待续...","tags":"Linux","url":"https://honmaple.me/articles/2017/10/ansible快速部署加速方案.html","loc":"https://honmaple.me/articles/2017/10/ansible快速部署加速方案.html"},{"title":"ansible-playbook中tasks单进程","text":"之前有一个需求,ansible-playbook中需要某一步单步执行,也就是说在有多台服务器时,某个任务只能一台服务器执行完后,另一台服务器才能执行,否者对应集群的服务会出问题 这是一个很简单的需求,ansible中也有对应的实现, --fork 1 或者 使用 serial 但是如果有人忘记加 --fork 1 了呢，而且该任务是在子任务中，使用 include 加载, serial 关键字无法在某一特定任务中使用,只能与 hosts 同级 所幸，在这里 https://www.bountysource.com/issues/26342862-support-for-serial-on-an-individual-task 找到了解决办法,使用 delegate_to - name : service restart # serial: 1 would be the proper solution here, but that can only be set on play level # upstream issue: https://github.com/ansible/ansible/issues/12170 run_once : true with_items : '{{play_hosts}}' delegate_to : \"{{ item }}\" command : \"/bin/service restart\"","tags":"Linux","url":"https://honmaple.me/articles/2017/09/ansible-playbook中tasks单进程.html","loc":"https://honmaple.me/articles/2017/09/ansible-playbook中tasks单进程.html"},{"title":"那里有座山","text":"这里有座山 那里有座山 你在那里 我在这里 我们都有着自己的骄傲 谁都不想为谁低头 这里有座山 那里有座山 至少 我还可以远远的看到你 你在那里 你在哪里 而我 一直都在这里 一直都在这里","tags":"love","url":"https://honmaple.me/articles/2017/09/那里有座山.html","loc":"https://honmaple.me/articles/2017/09/那里有座山.html"},{"title":"redis集群搭建","text":"参考资料 Redis 集群是一个提供在多个Redis间 节点间共享数据 的程序集 准备 集群开始需要运行redis集群实例，而且要让集群正常运作至少需要三个主节点,这里创建六个节点，三个为主节点，三个为从节点,端口号分别为9001,9002,9003,9004,9005,9006 并创建六个以端口号为名字的目录， 在每个目录中运行一个Redis实例 mkdir -p redis/9001 cd redis mkdir 9002 mkdir 9003 mkdir 9004 mkdir 9005 mkdir 9006 然后将对应的配置 redis.conf 放入相应的目录中(记得修改端口号) 最小配置选项: port 9001 cluster-enabled yes cluster-config-file node9001.conf cluster-node-timeout 5000 appendonly yes 然后就可以启动redis实例了 redis-server redis/9001/redis.conf redis-server redis/9002/redis.conf redis-server redis/9003/redis.conf redis-server redis/9004/redis.conf redis-server redis/9005/redis.conf redis-server redis/9006/redis.conf 由于这个过程很简单而且重复,所以我写了一个脚本进行创建: @cli.command () @click.option ( '--dirs' , '-d' , default = DEFAULT_PATH ) @click.option ( '--port' , '-p' , default = 9001 ) def create ( dirs , port ): for i in range ( 6 ): path = os . path . join ( dirs , str ( port + i )) if not os . path . exists ( path ): os . makedirs ( path ) conf = os . path . join ( path , 'redis.conf' ) with open ( conf , 'w+' ) as f : text = '''port {0} cluster-enabled yes cluster-config-file nodes{0}.conf cluster-node-timeout 5000 appendonly yes ''' . format ( port + i ) f . write ( text ) with cd ( dirs ): os . system ( 'redis-server {}' . format ( conf )) 创建集群 使用redis的官方脚本 redis-trib 进行创建 ruby redis-trib.rb create --replicas 1 127 .0.0.1:9001 127 .0.0.1:9002 127 .0.0.1:9003 127 .0.0.1:9004 127 .0.0.1:9005 127 .0.0.1:9006 或者接上面的脚本 ports = [ '127.0.0.1:{}' . format ( port + i ) for i in range ( 6 )] os . system ( 'ruby redis-trib.rb create --replicas 1 {}' . format ( ' ' . join ( ports ))) –replicas 1 :表示为集群中的每个主节点创建一个从节点 结果如图所示: 输入 yes 最后查看集群是否启动成功 测试集群 -c 选项以集群方式启动 $ redis-cli -c -p 7000 127 .0.0.1:9001> keys * ( empty list or set ) 127 .0.0.1:9001> set hello world OK 127 .0.0.1:9001> get hello \"world\" 127 .0.0.1:9001> set hello1 world1 -> Redirected to slot [ 11613 ] located at 127 .0.0.1:9003 OK 127 .0.0.1:9003> get hello1 \"world1\" 127 .0.0.1:9003> set hello2 world2 -> Redirected to slot [ 7486 ] located at 127 .0.0.1:9002 OK 127 .0.0.1:9002> get hello2 \"world2\" 进入另一个实例 $ redis-cli -c -p 9002 127 .0.0.1:9002> get hello -> Redirected to slot [ 866 ] located at 127 .0.0.1:9001 \"world\" 127 .0.0.1:9001> get hello1 -> Redirected to slot [ 11613 ] located at 127 .0.0.1:9003 \"world1\" 127 .0.0.1:9003> get hello2 -> Redirected to slot [ 7486 ] located at 127 .0.0.1:9002 \"world2\" ok,先这样","tags":"Linux","url":"https://honmaple.me/articles/2017/08/redis集群搭建.html","loc":"https://honmaple.me/articles/2017/08/redis集群搭建.html"},{"title":"tornado中session实现","text":"tornado中默认没有session的实现,虽然默认的 set_secure_cookie 已经足够安全了,但更安全的应该是客户端保存session_id,服务端保存对应的信息 注:保存在redis中的经测试是可以的,保存在内存中的貌似还不行 给出源码: from uuid import uuid4 from redis import StrictRedis from functools import wraps from datetime import datetime , timedelta from pytz import timezone def singleton ( cls ): instances = {} @wraps ( cls ) def getinstance ( * args , ** kw ): if cls not in instances : instances [ cls ] = cls ( * args , ** kw ) return instances [ cls ] return getinstance def current_time ( tz = None ): if tz is None : tz = 'UTC' return datetime . now ( timezone ( tz )) class CoreSession ( object ): def __setitem__ ( self , key , value ): ''' session['username'] = 'hello' ''' return self . set ( key , value ) def __getitem__ ( self , key ): return self . get ( key ) def get_or_set ( self , key , value ): if not self . get ( key ): self . set ( key , value ) return self . get ( key ) @singleton class MemorySession ( CoreSession ): def __init__ ( self ): ''' self._client = {'session_id1':{key:value}, 'session_id2':{key:value}} ''' self . _client = {} def init ( self , session_id , expires_days = 30 ): self . session_id = 'session:{}' . format ( session_id ) self . expires_days = expires_days if self . session_id not in self . _client : self . _client [ self . session_id ] = { 'is_authenticated' : False , 'expire' : current_time () + timedelta ( days = self . expires_days ) } print ( self . session_id ) def set ( self , key , value ): self . _client [ self . session_id ][ key ] = value def get ( self , key ): return self . _client [ self . session_id ] . get ( key ) def pop ( self , key ): return self . _client [ self . session_id ] . pop ( key , None ) def remove_expires ( self ): expire_sessions = [] for key , value in self . _client . items (): if value [ 'expire' ] > current_time (): expire_sessions . append ( key ) def clear ( self ): del self . _client [ self . session_id ] @singleton class RedisSession ( CoreSession ): def __init__ ( self ): self . _client = StrictRedis ( host = 'localhost' , port = 6379 , db = 0 , password = 'redis' , decode_responses = True ) def init ( self , session_id , expires_days = 30 ): self . session_id = 'session:{}' . format ( session_id ) self . expires_days = expires_days if not self . _client . exists ( self . session_id ): self . _client . hset ( self . session_id , 'is_authenticated' , 0 ) self . _client . expire ( self . session_id , self . expires_days * 30 * 3600 ) def set ( self , key , value ): return self . _client . hset ( self . session_id , key , value ) def get ( self , key ): return self . _client . hget ( self . session_id , key ) def pop ( self , key ): return self . _client . hdel ( self . session_id , key ) def clear ( self ): return self . _client . delete ( self . session_id ) class Session ( object ): def __init__ ( self , request_handler ): self . request_handler = request_handler self . session_id = self . request_handler . get_secure_cookie ( \"session\" ) if not self . session_id : self . session_id = str ( uuid4 ()) self . request_handler . set_secure_cookie ( \"session\" , self . session_id ) # get cookies is bytes if isinstance ( self . session_id , bytes ): self . session_id = self . session_id . decode () self . _session = RedisSession () # self._session = MemorySession() self . _session . init ( self . session_id ) def __setitem__ ( self , key , value ): self . _session [ key ] = value def __getitem__ ( self , key ): return self . _session [ key ] def clear ( self ): self . request_handler . clear_cookie ( self . session_id ) return self . _session . clear ()","tags":"coding","url":"https://honmaple.me/articles/2017/08/tornado中session实现.html","loc":"https://honmaple.me/articles/2017/08/tornado中session实现.html"},{"title":"明明你也很爱我","text":"你怎么那么冷漠 你怎么就不怕错过我 明明你也很爱我 为什么爱不到结果 咫尺层城留不住 久相忘 到此偏相忆","tags":"love","url":"https://honmaple.me/articles/2017/08/明明你也很爱我.html","loc":"https://honmaple.me/articles/2017/08/明明你也很爱我.html"},{"title":"手机与Linux桌面文件共享","text":"手机: 某米 电脑: archlinux 环境: 同一wifi下 手机共享文件到电脑 最近才发现手机可以开启ftp服务对文件进行共享,直接进入文件管理器开启就行,电脑上使用 ftp target 进行连接 注： get 下载 put 上传 电脑共享文件到手机 这里采用python搭建一个简单的web服务(python3)供手机下载文件 # 首先 cd 到要共享的目录 python -m http.server --bind 0.0.0.0 查看本机IP ifconfig # 或者 ip addr 重要 : 请确保关闭防火墙,否则手机无法连接 sudo systemctl stop iptables 然后手机浏览器访问 ip:8000 就能下载电脑端的文件了 非同一wifi环境下 : 可以先在电脑端开启wifi热点(可以不联网),我是直接使用networkmanger进行创建的","tags":"Linux","url":"https://honmaple.me/articles/2017/07/手机与Linux桌面文件共享.html","loc":"https://honmaple.me/articles/2017/07/手机与Linux桌面文件共享.html"},{"title":"一个简单的数据分组算法","text":"之前有这么一个需求 将数据按照时间分组，比如说每5分钟为一组，或者每30分钟为一组，开始时间如果分钟数大于等于30分钟，则设置为30,如果小于30,则设置为0（也可以设置为更复杂的逻辑） 当然中间还有一些数据的统计，分析和计算暂时不管 获取开始时间 def get_start_date ( start_date ): time = datetime . fromtimestamp ( int ( start_date ) / 1000 ) if time . minute >= 30 : minute = 30 else : minute = 0 start_date = datetime ( time . year , time . month , time . day , time . hour , minute , 0 ) start_date = mktime ( start_date . timetuple ()) * 1000 return start_date 开始时间很简单，需要注意的是设置分钟，需要将时间戳转换为datetime，设置分钟数后再将datetime转为时间戳 time = datetime . fromtimestamp ( int ( start_date ) / 1000 ) start_date = datetime ( time . year , time . month , time . day , time . hour , minute , 0 ) start_date = mktime ( start_date . timetuple ()) * 1000 时间分组 直接给出源码 def gen_date_group ( start_date , datas , interval ): # datas是一组含时间戳的数据 interval = int ( interval ) # 获取开始时间 start_date = get_start_date ( start_date ) end_date = start_date + interval count = 0 type_count = 0 for data in datas : if data [ 'date' ] >= end_date : yield ( start_date , get_count_average ( type_count , count )) # 一些数据统计与计算 type_count = data [ 'type_count' ] count = data [ 'count' ] start_date = end_date end_date = start_date + interval # 注意这里，即使dates里没有某个时间区间的数据，也要不断循环分组 while data [ 'date' ] >= end_date : yield ( start_date , 0 ) start_date = end_date end_date = start_date + interval else : type_count += data [ 'type_count' ] count += data [ 'count' ]","tags":"Python","url":"https://honmaple.me/articles/2017/07/一个简单的数据分组算法.html","loc":"https://honmaple.me/articles/2017/07/一个简单的数据分组算法.html"},{"title":"Linux总结(草稿)","text":"Linux发展历史 Linux是由BSD发展而来，BSD又起源于UNIX。UNIX由贝尔实验室开发， 后来开放给各大学教学使用,其中伯克利大学通过对UNIX源码的研究以及不断的改进与扩展, 推出BSD,并于BSD 4.3版本加入网络模块,极大推进UNIX的发展。但后面由于版权等原因, UNIX与BSD之间发生冲突与法律纠纷,直到1998年,在此期间,芬兰大学生Linus Torvalds 于1991年发布首个Linux版本,linux也趁UNIX与BSD纠纷之际,得到非常快速的发展 Linux的最小组成 Linux最小由内核kernel,文件层次结构FHS,系统启动器bootloader组成,其中内存调度， 进程调度等由内核管理,内核可单独运行，但需要与其它组成相配合。 语言:一般有头文件与库文件,头文件为实现,库文件为声明 Linux的安装与启动 当linux启动时，首先启动内核，内核调用init来完成引导进程，init启动时，它会在/etc/inittab内查找默认的运行级别, 然后运行/etc/rc.d/init.d中运行级别的启动脚本。 分区:一般分根分区/与swap交换分区,根分区的设置是为了备份方便 文件系统:在存储设备上组织文件的方法,负责文件的增删改查,linux上常用文件系统有ext2,ext3,ext4,xfs,btrfs等, 其中ext4单个分区最大可管理16TB磁盘,xfs单分区最大支持2PB磁盘 内存管理：当内存不够时,linux会杀死内存占用最高的进程,像mongodb就是一个占内存大户 常用命令: file: 识别文件类型与编码格式 ldd:用于打印程序或者库文件所依赖的共享库列表 运行级别: 0: 停机 1: 单用户模式 2: 多用户，没有 NFS 3: 完全多用户模式(标准的运行级) 4: 没有用到 5: X11 6: 重新启动","tags":"Linux","url":"https://honmaple.me/articles/2017/07/Linux伪总结.html","loc":"https://honmaple.me/articles/2017/07/Linux伪总结.html"},{"title":"celery动态添加任务","text":"celery是一个基于Python的分布式调度系统， 文档在这 ,最近有个需求,想要动态的添加任务而不用重启celery服务,找了一圈没找到什么好办法(也有可能是文档没看仔细)，所以只能自己实现囉 为celery动态添加任务，首先我想到的是传递一个函数进去，让某个特定任务去执行这个传递过去的函数，就像这样 @app.task def execute ( func , * args , ** kwargs ): return func ( * args , ** kwargs ) 很可惜，会出现这样的错误 kombu.exceptions.EncodeError: Object of type 'function' is not JSON serializable 换一种序列化方式 @app.task ( serializer = 'pickle' ) def execute ( func , * args , ** kwargs ): return func ( * args , ** kwargs ) 结果又出现一大串错误信息 ERROR/MainProcess] Pool callback raised exception: ContentDisallowed('Refusing to deserialize untrusted content of type pickle (application/x-python-serialize)',) Traceback (most recent call last): File \"/home/jl/.virtualenvs/test/lib/python3.6/site-packages/kombu/utils/objects.py\", line 42, in __get__ return obj.__dict__[self.__name__] KeyError: 'chord' During handling of the above exception, another exception occurred: Traceback (most recent call last): File \"/home/jl/.virtualenvs/test/lib/python3.6/site-packages/kombu/utils/objects.py\", line 42, in __get__ return obj.__dict__[self.__name__] KeyError: '_payload' 换一种思路 func = import_string ( func ) 不知道这样是否可以，结果测试: No 哎，流年不利. 最后一直测试，一直测试，终于找到了一种办法,直接上代码 from importlib import import_module , reload app . conf . CELERY_IMPORTS = [ 'task' , 'task.all_task' ] def import_string ( import_name ): import_name = str ( import_name ) . replace ( ':' , '.' ) modules = import_name . split ( '.' ) mod = import_module ( modules [ 0 ]) for comp in modules [ 1 :]: if not hasattr ( mod , comp ): reload ( mod ) mod = getattr ( mod , comp ) return mod @app.task def execute ( func , * args , ** kwargs ): func = import_string ( func ) return func ( * args , ** kwargs ) 项目结构是这样的 ├── celery_app.py ├── config.py ├── task │ ├── all_task.py │ ├── init__.py 注意: 任务必须大于等于两层目录 以后每次添加任务都可以先添加到 all_task.py 里，调用时不用再重启celery服务 # task/all_task.py def ee ( c , d ): return c , d , '你好' # example from celery_app import execute execute . delay ( 'task.all_task.ee' , 2 , 444 ) ok，另外发现celery也支持任务定时调用,就像这样 execute . apply_async ( args = [ 'task.all_task.aa' ], eta = datetime ( 2017 , 7 , 9 , 8 , 12 , 0 )) 简单实现一个任务重复调用的功能 @app.task def interval ( func , seconds , args = (), task_id = None ): next_run_time = current_time () + timedelta ( seconds = seconds ) kwargs = dict ( args = ( func , seconds , args ), eta = next_run_time ) if task_id is not None : kwargs . update ( task_id = task_id ) interval . apply_async ( ** kwargs ) func = import_string ( func ) return func ( * args ) 大概意思就是先计算下次运行的时间,然后把任务添加到celery队列里,这里有个task_id有些问题,因为假设添加了每隔3s执行一个任务, 它的task_id默认会使用uuid生成，如果想要再移除这个任务就不太方便，自定task_id可能会好一些，另外也许需要判断task_id是否存在 AsyncResult ( task_id ) . state ok,再献上一个好用的函数 from inspect import getmembers , isfunction def get_tasks ( module = 'task' ): return [{ 'name' : 'task:{}' . format ( f [ 1 ] . __name__ ), 'doc' : f [ 1 ] . __doc__ , } for f in getmembers ( import_module ( module ), isfunction )] 就这样.","tags":"Linux","url":"https://honmaple.me/articles/2017/07/celery动态添加任务.html","loc":"https://honmaple.me/articles/2017/07/celery动态添加任务.html"},{"title":"我的Linux历程","text":"Linux 是一种计算机操作系统内核,以C语言和汇编语言写成，匹配POSIX标准，以GNU通用公共许可证(GPL2)发布,最早是由林纳斯·托瓦兹开发的类UNIX系统 Linux与UNIX的区别: UNIX系统大多是与硬件配套的，而Linux则可运行在多种硬件平台上。UNIX是商业软件，而Linux自由免费。 Linux发行版 简单的来说将Linux内核与一些系统软件，应用软件进行整合，有的发行版还包括图形界面(x11，wayland),目前所说的Linux大多代表Linux发行版 Linux历程 曾经在某论坛看到linux这个名词，立马装上虚拟机然后安装了我的第一个Linux版本--centos，并且装上了gnome桌面环境，随后开始了Linux折腾之旅, 大概是这样的 centos --> kali --> ubuntu --> fedora --> ubuntu kylin --> mint --> debian --> fedora --> archlinux ......,Linux发行版大概分为3系, debain系,包括ubuntu,mint,kali等,使用包管理器apt-get、aptitude、dpkg;centos或者说红帽系，包括众所周知的小白鼠版本fedora， 如果不是每半年要重装一次，我会一直使用它,而不是archlinux,所使用的包管理器yum,fedora已更换成dnf; 还有其它系，因为它们所占份额太小,包括archlinux,gentoo等 Linux的娱乐性 说实话，Linux上的游戏对比windows上就是渣，大致是因为Linux上驱动的问题，这也难怪Linus会对nvidia竖中指，虽说有开源的实现,但与nvidia在windows上性能的对比还相差甚远， 不过Linux上还是有很多可玩的游戏的,steam对Linux的支持尤为重要, 推荐几个steam上的游戏,正好这几天夏促打折:无主之地2,饥荒，cs:go等 Linux上的实用性 Linux在个人桌面上属于小众市场,使用Linux的大多是程序员，或者是工作需要才会使用，虽说对比windows，Linux也足够应付日常生活,但并不是所有公司都会照顾这小众的Linux用户, 非常感谢网易云音乐与深度团队合作开发了网易云音乐Linux客户端，非常鄙视腾讯放弃对LinuxQQ的维护 深入了解Linux linux由内核,shell,文件系统和应用软件组成，没有扩展名的概念，分为普通文件，目录，链接，设备,管道文件,其文件系统结构: bin 存放二进制可执行文件(ls,cat,mkdir等) boot 存放用于系统引导时使用的各种文件 dev 用于存放设备文件 etc 存放系统配置文件 home 存放所有用户文件的根目录 lib 存放跟文件系统中的程序运行所需要的共享库及内核模块 mnt 系统管理员安装临时文件系统的安装点 opt 额外安装的可选应用程序包所放置的位置 proc 虚拟文件系统，存放当前内存的映射 root 超级用户目录 sbin 存放二进制可执行文件，只有root才能访问 tmp 用于存放各种临时文件 usr 用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录 var 用于存放运行时需要改变数据的文件","tags":"Linux","url":"https://honmaple.me/articles/2017/07/我的Linux历程.html","loc":"https://honmaple.me/articles/2017/07/我的Linux历程.html"},{"title":"关于网易云音乐个性推荐无法显示的问题","text":"最近在使用网易云音乐时首页的个性推荐总是无法显示，一直在 正在为你生成个性化推荐 ,网上也没找到什么办法,偶然间使用 ┌─ [ jianglin ] ─ [ ~ ] └──╼ rm -rf .cache/netease-cloud-music/ ┌─ [ jianglin ] ─ [ ~ ] └──╼ rm -rf .config/netease-cloud-music/ 重新打开登陆后个性推荐就出现了，特此记录","tags":"Linux","url":"https://honmaple.me/articles/2017/06/关于网易云音乐个性推荐无法显示的问题.html","loc":"https://honmaple.me/articles/2017/06/关于网易云音乐个性推荐无法显示的问题.html"},{"title":"方便的切换emacs主题","text":"作为一个主题控，经常会切换主题，之前切换主题的方式是这样的，*M-x*,`load-theme`,选中,但是个人认为不够便捷，正好前几天发现了 hydra 这个插件,也想实践一下 获取主题列表 ( setq maple-cycle-themes ( mapcar 'symbol-name ( custom-available-themes ))) 获取当前主题索引 ( cl-position ( car ( mapcar 'symbol-name custom-enabled-themes )) maple-cycle-themes :test 'equal ) 获取下一个主题 ( setq maple-current-theme-index ( + 1 maple-current-theme-index )) ( setq maple-current-theme ( nth maple-current-theme-index maple-cycle-themes )) 加载主题 ( load-theme ( intern maple-current-theme ) t ) 最后得到这样的函数 ( defun maple/cycle-theme ( num ) ( interactive ) ( setq maple-current-theme-index ( + num ( cl-position ( car ( mapcar 'symbol-name custom-enabled-themes )) maple-cycle-themes :test 'equal ))) ( when ( >= maple-current-theme-index ( length maple-cycle-themes )) ( setq maple-current-theme-index 0 )) ( setq maple-current-theme ( nth maple-current-theme-index maple-cycle-themes )) ( mapc 'disable-theme custom-enabled-themes ) ( let (( progress-reporter ( make-progress-reporter ( format \"Loading theme %s...\" maple-current-theme )))) ( load-theme ( intern maple-current-theme ) t ) ( progress-reporter-done progress-reporter ))) ( defun maple/next-theme () ( interactive ) ( maple/cycle-theme 1 )) ( defun maple/previous-theme () ( interactive ) ( maple/cycle-theme -1 )) ( defhydra maple/cycle-themes () ( \"n\" maple/next-theme \"next theme\" ) ( \"p\" maple/previous-theme \"prev theme\" )) ok,绑定一个快捷键吧","tags":"Linux","url":"https://honmaple.me/articles/2017/05/方便的切换emacs主题.html","loc":"https://honmaple.me/articles/2017/05/方便的切换emacs主题.html"},{"title":"那些年我们一起写的诗","text":"其实世界上本没有试，考得人多了，也便成了试 喝自己的水，让别人喝酒去吧！ 春游只是一场旅行，不在乎目的地（呈贡新校区）在乎的只是周末的作业和做作业的心情，让作业去旅行… 忘记或是失忆…都是一场美丽 黑夜如此短暂，仅在闭眼睁眼之间，却不知黑暗之中，已有人迷失方向，正在苦苦寻觅黎明前的光亮 人生总有欢乐，亦有痛苦，我们本是为了活着而活着，活着，才有希望，死亡，或许能够躲避痛苦，但也将永远长眠于墓地，无法品味人生的酸甜苦辣 问君能有几多愁，恰似一江春水向东流；问君能有几多愁，恰似一群太监上青楼；问君能有几多愁，恰似一代天骄热泪流 ；问君能有几多愁，恰似三中作业多如牛。作业多，愁啊！ 对内宣传实力如虎，对外抗议胆小如鼠 天朗、气清、月明、人中：夜迹…血月 众人皆白，唯我独黑 众人皆醉，唯我独醒 战争中出英雄，和平中出贪官，不在战争中爆发，就在和平中灭亡 人生就像是在走一条很长很长的路，两只脚唯有不断超越对方，才能前进；两只脚不断躲避对方，只能后退 生命如鸡肋，食之无味，弃之可惜 拎起屠刀，让佛祖说去吧 山脚有雨山无雨，眼中有泪眼无泪。山顶无雨山有雨，心头无泪心有泪 -- 题目《心雨》 世界没有真正意义上的阴天，只有被乌云遮住的蓝天 風中无叶楓中叶，铃中无音林中音。 冬天到了，春天还早吗？春天来了，冬天还不走吗？ 风中无叶枫中叶，磷中无龙林中龙 战争中出英雄，战争中更出汉奸 夜观风象起，星河四海一。八方欲归队，人道几时回？ 人生何处不逢君，天蓝海自清。 我本将心向光明，奈何光明不待人：朝朝窗帘起，时时四海一。浮云遮望眼，天道似无心。梦醒君莫问，谁言伤心泪。帘外窗更明，只是在人间。 无情之路有情惘，有情之苦无情殇 无情之路无情殇，有情之苦有情惘。 两袖清风拂黄泉，半缕微光照奈何。 今夜无过后月明，是故还情总相生。 夜很美，月很美。有夜而无月，有月而无夜，前生有夜而后生无月，后生有月而前生无夜。有夜何月，有月何夜，夜月何存！ 城市的喧嚣渐渐影响着森林的寂静，叨扰着森林里的生物。 天道轮回为权，人道轮回为忍，修罗道轮回为无，饿鬼道轮回为贪，畜生道轮回为邪，地狱道轮回为苦 大地一摇，四川跌倒全国扶;天空三怒，云南渴死无人问 其天坚若此，其心不可为，其民坚若此，有道者何谁？ 世人皆知吾为汉唐人，然焉知宋乃吾心之所向者也，心之所向，道之所依，人之所为，根之所存。 今朝有酒今朝醉，今夜有泪今夜流。 天不再蓝，海不再清，即使没有窗帘的遮挡，光明也将隐于天岸 夜游梦醒不知路，寻问琴声行何处 我看到了希望，却隐藏于黑暗，我看到了曙光，却消失在彼岸。 所谓天，为之天，所谓人，为之人。 天不蓝，海不深，心不静，脑不清，手不稳，愤不平 刀已折，人已弯，魂已断…… 你已经忘记我是谁，我已经忘记你是谁，你已经忘记你是谁，我已经忘记我是谁 今夜梦醒君莫问，明月当空，何日返故乡？昨日忆兮难言语，为此，时时到天明。 人生似无意，落花流水，通向天梯。 梦想终成空，梦醒梦落，开往地狱。 无迟疑为无过，无过汝云定错，定错无外分寸，分寸识为务心 风儿总在帮助蓝天反抗窗帘的遮挡好让阳光照耀每个人的心房风儿反抗了窗帘的遮挡却无法反抗人类躲避阳光的欲望 何民清理近天零，轻盈湖畔汝为饮 没有阳光的日子里，我的身体变得虚弱不堪，即使内心黑暗，也阻挡不了我享受阳光的欲望。 云分，等雨，云聚，临雨，云淡，不见雨 雨还是那雨，雷还是那雷，只是不同的时间，不同的地点，没有泥土的芳香，没有朦胧的山影，更没有雷雨中畅快的奔跑，有的只是这颗心，经历了沧海桑田，阻隔了天涯海角。 伤人者，人恒伤之;杀人者，得不偿失。 一出门，就是鸟叫蝉躁蛙鸣，这是家乡的声音，一出门，便是晴空万里，蓝天高挂，这是家乡的景象，一出门，便是泥土的芳香，这是家乡的味道…… 人生就如这月亮，即使没有乌云白云的遮挡，也总是这般模糊不清。 若相遇，需无意，若有意，何时遇？凭天意。 爬山爬山，一爬便是山，不爬也是山，爬山不是山，爬山还是山。 医者老矣，尚医心否？ 空即是色，色即是空，空无一色，色无一空，空即是空，色即是色，空空色色，岂乎我哉。 人生多梦，光明泪，夜自多情，友为罪。 醉池轻舞种欢笑，怨柳飘飞祈逍遥。酒酣闻雨不知泪，梦醒晓月痕将退。 醉问天涯何处留，天变，无明月，笑看红尘柳。拂风晓月众芳树，无觅处，寻归路，墨中归宿，问谁墓？ 山风归来，抚柳掩面朝阳好，黯然离去，仰天长叹落日殇。 拂晓闻雨心管弦，日出江山难忘言。天上人间寻何处，雨过天晴有蓝天。 天若有情天亦老，少不更事，何处无芳草 时间，为谁而成长，又为谁而孤单……,更为谁而悲伤 酒不醉人人自醉，夜不迷人人自迷，落花无情，流水无意…… 他爱她，她爱他，原来不是她，原来不是他 雨中漫步行，夜深無人听。悄然歸故裡，卧龍不知情。 月光墓，塞上霜，黑夜明，杜康殤…… 原来错过了便真的是错过了，他爱她，她爱他，原来不是他，原来不是她 黑暗中前行，却不知，那是永远的黑夜；光明中静止，却不知，那是短暂的白昼…… 寻路不问路，追梦不留梦。爱恨一念间，相失一片天。 我是寻路者，却不是问路人！ 我是追梦者，却不是留梦人！ 夜尽天明，何人眠，悔不当初，竟惹柳树，望断天涯无觅路，奈何自掘坟墓 静流风动谁能狂，杀心渐起染风云，封欲离人平如漠，断袖为仇似生袍，道望无涯天明云，剑芒一指斩红尘，刀横黄河断流水，心系天下有奈何。 大漠孤烟无边关，地上重楼忘记人，天涯海角难磨灭，夜迹血月(万千奴隶)怎奈何 星空太美，手机拍不了也放不下，只能放在记忆里，看不清也摸不着，最后只能慢慢流逝，留不了也抓不到 焚舟破釜天，唯命弃我岸上前，惘顾神州情碎，山水一念，勿镜天下红尘，在人间","tags":"recall","url":"https://honmaple.me/articles/2017/05/那些年我们一起写的诗.html","loc":"https://honmaple.me/articles/2017/05/那些年我们一起写的诗.html"},{"title":"vue笔记","text":"vue分页 需要参数: page : 当前页码 total_page : 总页数 代码片段 < ul class = \"pagination\" v-if = \"total_page > 1\" > < li v-if = \"page > 1\" class = \"previous\" > < a href = \"javascript:void(0);\" v-on:click = \"paginate_to(1);\" > « </ a > </ li > < template v-for = \"p in total_page\" > < template v-if = \"p == page\" > < li class = \"active\" > < a href = \"javascript:void(0);\" > {{ p }} </ a > </ li > </ template > < template v-else-if = \"(page - 2 < p && p < page + 2) || p <= 3 || p > total_page - 3 \" > < li > < a href = \"javascript:void(0);\" v-on:click = \"paginate_to(p);\" > {{ p }} </ a > </ li > </ template > < template v-else-if = \"(page - 3 < p && p < page + 1) || p <= 2 || p > total_page - 4 \" > < li > < a href = \"javascript:void(0);\" v-on:click = \"paginate_to(p);\" > ..... </ a > </ li > </ template > </ template > < li v-if = \"page < total_page\" class = \"previous\" > < a href = \"javascript:void(0);\" v-on:click = \"paginate_to(total_page);\" > » </ a > </ li > </ ul >","tags":"coding","url":"https://honmaple.me/articles/2017/05/vue笔记.html","loc":"https://honmaple.me/articles/2017/05/vue笔记.html"},{"title":"晒晒我的Linux及桌面","text":"ps:真TM的闲着蛋疼","tags":"Linux","url":"https://honmaple.me/articles/2017/05/晒晒我的Linux及桌面.html","loc":"https://honmaple.me/articles/2017/05/晒晒我的Linux及桌面.html"},{"title":"emacs笔记","text":"Evil 粘贴替换的时候会复制替换的文本 ( defun evil-paste-after-from-0 () ( interactive ) ( let (( evil-this-register ?0 )) ( call-interactively 'evil-paste-after ))) ( define-key evil-visual-state-map \"p\" 'evil-paste-after-from-0 ) 自动搜索已选中的字符 经常使用 evil 中的 =/= 进行搜索, 但有时候想要搜索已有的字符, 在 evil-visual-state 下选中某个字符,按 =/= 时自动把选中的字符填入待搜索项中 ( use-package isearch :ensure nil :init ( defun maple/evil-search-paste () ( when ( region-active-p ) ( isearch-yank-string ( save-excursion ( buffer-substring-no-properties ( region-beginning ) ( 1+ ( region-end ))))) ( deactivate-mark ))) :hook ( isearch-mode . maple/evil-search-paste ) :bind ( :map isearch-mode-map ([ remap isearch-delete-char ] . isearch-del-char ))) evil-mc不忽略大小写 evil-mc 默认会通过 evil-ex-search 进行搜索，可以通过设置 (setq evil-ex-search-case 'sensitive) 来不忽略大小写, 但我只想在使用 evil-mc 时不忽略，其他时间忽略 ;; ignore case in evil-mc ( add-hook 'evil-mc-before-cursors-created ( lambda () ( setq evil-ex-search-case 'sensitive ))) ( add-hook 'evil-mc-after-cursors-deleted ( lambda () ( setq evil-ex-search-case 'smart ))) Font 设置中英文字体 ;; 中英文表格对齐 ( defvar emacs-english-font \"DejaVu Sans Mono\" \"The font name of English.\" ) ( defvar emacs-cjk-font \"WenQuanYi Micro Hei Mono\" \"The font name for CJK.\" ) ( defvar emacs-font-size-pair ' ( 15 . 18 ) \"Default font size pair for (english . chinese)\" ) ( defvar emacs-font-size-pair-list ' (( 5 . 6 ) ( 10 . 12 ) ( 13 . 16 ) ( 15 . 18 ) ( 17 . 20 ) ( 19 . 22 ) ( 20 . 24 ) ( 21 . 26 ) ( 24 . 28 ) ( 26 . 32 ) ( 28 . 34 ) ( 30 . 36 ) ( 34 . 40 ) ( 36 . 44 )) \"This list is used to store matching (englis . chinese) font-size.\" ) ( defun font-exist-p ( fontname ) \"Test if this font is exist or not.\" ( if ( or ( not fontname ) ( string= fontname \"\" )) nil ( if ( not ( x-list-fonts fontname )) nil t ))) ( defun maple/set-font ( english chinese size-pair ) \"Setup emacs English and Chinese font on x window-system.\" ( if ( font-exist-p english ) ( set-frame-font ( format \"%s:pixelsize=%d\" english ( car size-pair )) t )) ( if ( font-exist-p chinese ) ( dolist ( charset ' ( kana han symbol cjk-misc bopomofo )) ( set-fontset-font ( frame-parameter nil 'font ) charset ( font-spec :family chinese :size ( cdr size-pair )))))) ;; (add-hook 'ctbl:table-mode-hook ;; (maple/set-font emacs-english-font emacs-cjk-font emacs-font-size-pair)) Ivy 指定目录或文件进行搜索 ( defun maple/counsel-ag-file () ( interactive ) ( counsel-ag nil ( read-file-name \"Search in file(s): \" ))) 查找当前目录以及子目录的某个文件 ( defun maple/counsel-find-file () ( interactive ) ( ivy-read \"Find file: \" ( mapcar 'file-relative-name ( directory-files-recursively default-directory \"\" )) :matcher #' counsel--find-file-matcher :action #' counsel-find-file-action :preselect ( counsel--preselect-file ) :require-match 'confirm-after-completion :history 'file-name-history :keymap counsel-find-file-map :caller 'counsel-find-file )) 当选中单词时，swiper使用已选单词进行搜索 ( defun maple/ivy-search-at-point ( func ) ( let* (( region ( region-active-p )) ( string ( if ( not region ) \"\" ( buffer-substring-no-properties ( region-beginning ) ( region-end )))) ( ivy-initial-inputs-alist ( list ( cons func string )))) ( when region ( deactivate-mark )) ( funcall func ))) ( defun maple/swiper () ( interactive ) ( maple/ivy-search-at-point 'swiper )) File 获取文件或目录的basename ( defun maple/basename ( fname ) ( if ( or ( file-directory-p fname ) ( string-match \"/$\" fname )) ( let (( dirname ( directory-file-name fname ))) ( file-name-nondirectory dirname )) ( file-name-nondirectory fname ))) Elisp golang自动增加注释 因为 flycheck 使用了 golint , flycheck 总是显示代码没有注释的警告 exported method Raw should have comment or be unexported (go-golint) 也没找到什么方法来禁止它, 作为强迫症受不了，总不能一个一个去注释, 所以写了一个函数来自动注释整个文件的所有未注释函数: ( defun maple/go-auto-comment () ( interactive ) ( unless ( featurep 'imenu ) ( require 'imenu nil t )) ( let* (( imenu-auto-rescan t ) ( imenu-auto-rescan-maxout ( if current-prefix-arg ( buffer-size ) imenu-auto-rescan-maxout )) ( items ( imenu--make-index-alist t )) ( items ( delete ( assoc \"*Rescan*\" items ) items ))) ( cl-mapcan ( lambda ( item ) ( cl-mapcan ( if ( string= ( car item ) \"func\" ) 'maple/go-func-comment 'maple/go-type-comment ) ( cdr item ))) items ))) ( defun maple/go-add-comment ( func point ) ( save-excursion ( goto-char point ) ( forward-line -1 ) ( when ( not ( looking-at ( concat \"// \" func ))) ( end-of-line ) ( newline-and-indent ) ( insert ( concat \"// \" func \" ..\" ))))) ( defun maple/go-func-comment ( f ) ( let (( func ( car f ))) ( if ( and ( string-prefix-p \"(\" func ) ( string-match \"[)] \\\\(.*\\\\)[(]\\\\(.*\\\\)[)]\\\\(.*\\\\)$\" func )) ( maple/go-add-comment ( match-string 1 func ) ( cdr f )) ( if ( string-match \"\\\\(.*\\\\)[(]\\\\(.*\\\\)[)]\\\\(.*\\\\)$\" func ) ( maple/go-add-comment ( match-string 1 func ) ( cdr f )) ( maple/go-add-comment ( car f ) ( cdr f )))))) ( defun maple/go-type-comment ( f ) ( maple/go-add-comment ( car f ) ( cdr f ))) 相关配置将持续更新: init-go.el 增加到hook但仅调用一次 ( defmacro maple/add-hook-once ( hook f &optional append local ) \"Like `add-hook`, remove after call with HOOK F &OPTIONAL APPEND LOCAL.\" ( let (( func ( intern ( format \"maple/run-once-%s\" ( symbol-name f ))))) ` ( progn ( defun , func () ( remove-hook ',hook ',func , local ) ( funcall ',f )) ( add-hook ',hook ',func , append , local )))) 迭代并获取列表索引 ( defmacro maple/dolist ( spec &rest body ) \"Like dolist but get INDEX, SPEC &REST BODY.\" ( declare ( indent 1 ) ( debug (( symbolp form &optional form ) body ))) ` ( let (( num 0 )) ( dolist , ( cdr spec ) ( let (( , ( car spec ) num )) ,@ body ( setq num ( + num 1 )))))) 这样就可以使用 ( maple/dolist ( index item ' ( \"aaa\" \"bbb\" )) ( print index )) 深拷贝function https://www.gnu.org/software/emacs/manual/html_node/elisp/Function-Cells.html ( fset 'maple/put-text-property ( symbol-function 'put-text-property ))","tags":"Linux","url":"https://honmaple.me/articles/2017/04/emacs笔记.html","loc":"https://honmaple.me/articles/2017/04/emacs笔记.html"},{"title":"emacs实现智能注释","text":"之前使用emacs时遇到这么一个问题 当前行存在代码折叠时,如果想要注释,必须先选中当前行,否则只能注释代码折叠块的第一行 就像这样 基础注释函数来源于 stackoverflow ( defun comment-or-uncomment-region-or-line () \"Comments or uncomments the region or the current line if there's no active region.\" ( interactive ) ( let ( beg end ) ( if ( region-active-p ) ( setq beg ( region-beginning ) end ( region-end )) ( setq beg ( line-beginning-position ) end ( line-end-position ))) ( comment-or-uncomment-region beg end ))) 在此函数的位置上进行修改,刚开始使用 ( when ( hs-already-hidden-p ) ( evil-visual-line )) 但是一直没得到想要的效果,后来修改了一下,使用 ( when ( hs-already-hidden-p ) ( progn ( end-of-visual-line ) ( evil-visual-state ) ( beginning-of-visual-line ))) 意思就是如果当前位置存在代码折叠,先选中当前行,然后注释整个选中区域 因为光标被移动到首位,我对这个不太在意,如果有在意的话,可以使用 save-excursion ( save-excursion ( when ( hs-already-hidden-p ) ( progn ( end-of-visual-line ) ( evil-visual-state ) ( beginning-of-visual-line ))) ...... ) 完整代码 ( defun comment-or-uncomment-region-or-line () \"Comments or uncomments the region or the current line if there's no active region.\" ( interactive ) ( save-excursion ( when ( hs-already-hidden-p ) ( progn ( end-of-visual-line ) ( evil-visual-state ) ( beginning-of-visual-line ))) ( let ( beg end ) ( if ( region-active-p ) ( setq beg ( region-beginning ) end ( region-end )) ( setq beg ( line-beginning-position ) end ( line-end-position ))) ( comment-or-uncomment-region beg end )))) ok,就这样","tags":"Linux","url":"https://honmaple.me/articles/2017/04/emacs实现智能注释.html","loc":"https://honmaple.me/articles/2017/04/emacs实现智能注释.html"},{"title":"基于whoosh实现的flask全文搜索插件","text":"flask 貌似很少全文搜索的插件,有一个 https://github.com/gyllstromk/Flask-WhooshAlchemy , 但试了几次都用不了,所以参考 Flask-WhooshAlchemy 自己写了一个 Quickstart 插件基于 whoosh,纯 python 编写,使用上很简单 from flask_msearch import Search [ ... ] search = Search () search . init_app ( app ) # models.py class Post ( db . Model ): __tablename__ = 'post' __searchable__ = [ 'title' , 'content' ] # views.py @app.route ( \"/search\" ) def w_search (): keyword = request . args . get ( 'keyword' ) results = search . whoosh_search ( Post , query = keyword , fields = [ 'title' ], limit = 20 ) return '' Usage 创建更新删除索引 如果要对已存在的数据创建索引(全部) # 创建 search . create_index () # 更新 search . create_index ( update = True ) # 删除 search . create_index ( delete = True ) 如果只想要为指定的表创建索引 search . create_index ( Model ) 自定义analyzer 比如使用jieba的中文分词 from jieba.analyse import ChineseAnalyzer search = Search ( analyzer = ChineseAnalyzer ()) Configure WHOOSH_BASE = 'whoosh_index' WHOOSH_ENABLE = True 项目地址:https://github.com/honmaple/flask-msearch","tags":"Python","url":"https://honmaple.me/articles/2017/04/基于whoosh实现的flask全文搜索插件.html","loc":"https://honmaple.me/articles/2017/04/基于whoosh实现的flask全文搜索插件.html"},{"title":"心死","text":"心死了, 没事, 只要人没事, 心死了, 人怎么可能没事。 人死了， 没事， 只要心没事, 人死了， 心怎么可能没事。 人不可无心, 心不可无人, 人心可有， 心人可有。","tags":"recall","url":"https://honmaple.me/articles/2017/04/心死.html","loc":"https://honmaple.me/articles/2017/04/心死.html"},{"title":"himawari8图片下载改进版","text":"第一版下载图片后设为壁纸,四周都是黑黑的不好看, 所以结合本地壁纸将两张图片进行合成 只要计算一下要缩减的大小与要放置的位置 我的方法是:打开 gimp ,合成两张图片,记下缩减的大小(214,214)与位置(160,160) 每次只要运行一下 python himawari8.py 源码 from PIL import Image , ImageOps , ImageDraw from io import BytesIO from urllib.request import Request , urlopen from datetime import datetime , timedelta import json SCALE = 2 WIDTH = 1368 HEIGHT = 768 def get_info (): url = \"http://himawari8-dl.nict.go.jp/himawari8/img/D531106/latest.json\" request = Request ( url ) response = urlopen ( request , timeout = 10 ) return json . loads ( response . read ()) def download (): png = Image . new ( 'RGB' , ( 550 * SCALE , 550 * SCALE )) # desktop = Image.new('RGB', (WIDTH, HEIGHT)) desktop = Image . open ( '/home/jianglin/Pictures/308556.png' ) url_format = 'http://himawari8-dl.nict.go.jp/himawari8/img/D531106/{}d/{}/{}_{}_{}.png' info = get_info () # date = datetime.strptime(info['date'], '%Y-%m-%d %H:%M:%S') + timedelta( # hours=-8) date = datetime . strptime ( info [ 'date' ], '%Y-%m- %d %H:%M:%S' ) for x in range ( SCALE ): for y in range ( SCALE ): url = url_format . format ( SCALE , 550 , date . strftime ( \"%Y/%m/ %d /%H%M%S\" ), x , y ) print ( url ) request = Request ( url ) response = urlopen ( request , timeout = 10 ) img = Image . open ( BytesIO ( response . read ())) png . paste ( img , ( 550 * x , 550 * y , 550 * ( x + 1 ), 550 * ( y + 1 ))) png = circle ( png ) desktop . paste ( png , ( 160 , 160 ), png ) desktop . save ( '/tmp/earth.png' , \"PNG\" ) set_background () def circle ( img ): width = SCALE * 550 height = SCALE * 550 size = ( width , height ) mask = Image . new ( 'L' , size , 0 ) draw = ImageDraw . Draw ( mask ) draw . ellipse (( 3 , 3 , width - 3 , height - 3 ), fill = 255 ) output = ImageOps . fit ( img , mask . size , centering = ( 0.5 , 0.5 )) output . putalpha ( mask ) output . thumbnail (( 214 , 214 ), Image . ANTIALIAS ) return output def convert (): # size = (768, 768) # mask = Image.new('L', size, 0) # draw = ImageDraw.Draw(mask) # draw.ellipse((3, 3, 765, 765), fill=255) # im = Image.open('/tmp/earth.png') # output = ImageOps.fit(im, mask.size, centering=(0.5, 0.5)) # output.putalpha(mask) # output.thumbnail((256, 256), Image.ANTIALIAS) # output.save('output.png') # output.convert(\"RGBA\") output = Image . open ( 'output.png' ) output . thumbnail (( 214 , 214 ), Image . ANTIALIAS ) desktop = Image . open ( '/home/jianglin/Pictures/308556.png' ) desktop . paste ( output , ( 160 , 160 ), output ) desktop . save ( '/tmp/earch.png' , \"PNG\" ) def set_background (): import os os . system ( 'feh --bg-scale /tmp/earth.png' ) if __name__ == '__main__' : download ()","tags":"Python","url":"https://honmaple.me/articles/2017/03/himawari8图片下载改进版.html","loc":"https://honmaple.me/articles/2017/03/himawari8图片下载改进版.html"},{"title":"火影忍者","text":"火影TV也完结了,仅以此贴纪念我逝去的青春","tags":"Life","url":"https://honmaple.me/articles/2017/03/火影忍者.html","loc":"https://honmaple.me/articles/2017/03/火影忍者.html"},{"title":"下载Himawari8拍摄的实时地球图片","text":"直接给出源码 设置壁纸 feh --bg-scale /tmp/earth.png 设置桌面大小,及图片放大倍数 SCALE = 4 WIDTH = 1368 HEIGHT = 768 from PIL import Image from io import BytesIO from urllib.request import Request , urlopen from datetime import datetime import json SCALE = 4 WIDTH = 1368 HEIGHT = 768 def get_info (): url = \"http://himawari8-dl.nict.go.jp/himawari8/img/D531106/latest.json\" request = Request ( url ) response = urlopen ( request , timeout = 10 ) return json . loads ( response . read ()) def download (): png = Image . new ( 'RGB' , ( 550 * SCALE , 550 * SCALE )) desktop = Image . new ( 'RGB' , ( WIDTH , HEIGHT )) url_format = 'http://himawari8-dl.nict.go.jp/himawari8/img/D531106/{}d/{}/{}_{}_{}.png' info = get_info () date = datetime . strptime ( info [ 'date' ], '%Y-%m- %d %H:%M:%S' ) for x in range ( SCALE ): for y in range ( SCALE ): url = url_format . format ( SCALE , 550 , date . strftime ( \"%Y/%m/ %d /%H%M%S\" ), x , y ) print ( url ) request = Request ( url ) response = urlopen ( request , timeout = 10 ) img = Image . open ( BytesIO ( response . read ())) png . paste ( img , ( 550 * x , 550 * y , 550 * ( x + 1 ), 550 * ( y + 1 ))) png . thumbnail (( HEIGHT , HEIGHT ), Image . ANTIALIAS ) desktop . paste ( png , (( WIDTH - HEIGHT ) // 2 , 0 )) desktop . save ( '/tmp/earth.png' , \"PNG\" ) if __name__ == '__main__' : download () 或许应该找一张有星星的照片","tags":"Python","url":"https://honmaple.me/articles/2017/03/下载Himawari8拍摄的实时地球图片.html","loc":"https://honmaple.me/articles/2017/03/下载Himawari8拍摄的实时地球图片.html"},{"title":"拟挽歌辞·荒草何茫茫","text":"拟挽歌辞·荒草何茫茫 -- 陶渊明 荒草何茫茫，白杨亦萧萧。 严霜九月中，送我出远郊。 四面无人居，高坟正嶕峣。 马为仰天鸣，风为自萧条。 幽室一已闭，千年不复朝。 千年不复朝，贤达无奈何。 向来相送人，各自还其家。 亲戚或余悲，他人亦已歌。 死去何所道，托体同山阿。","tags":"Life","url":"https://honmaple.me/articles/2017/03/拟挽歌辞·荒草何茫茫.html","loc":"https://honmaple.me/articles/2017/03/拟挽歌辞·荒草何茫茫.html"},{"title":"sqlalchemy使用上的小tips","text":"sqlalchemy object序列化为json 灵感来源于 Django REST framework 多个实例 posts = Post . query . all () serializer = Seralizer ( posts , many = True ) data = serializer . data 单个实例 post = Post . query . first () serializer = Seralizer ( post , many = False ) data = serializer . data 排除字段 serializer = Seralizer ( post , exclude = [ 'title' ]) 仅包括字段 serializer = Seralizer ( post , include = [ 'title' ]) 关系查询深度 serializer = Seralizer ( post , depth = 3 ) depth 默认为2 增加一些自定义的函数 serializer = Serializer ( post , extra = [ 'get_post_count' ]) Post class Post ( Model ): ...... def get_post_count ( self ): return 11 可传递参数的函数 class PostSerializer ( Serializer ): count = Field ( source = 'get_post_count' , args = { 'name' : 'hello' }, default = 20 ) class Meta : include = [] depth = 2 include = [] exclude = [] extra = [ 'count' ] 像django orm一样使用sqlalchemy djang orm 与sqlalchemy相比,为什么很多人都认为django orm更好用,大概就是因为django orm更方便 基本查询(已实现) gt lt lte gte contains in exact iexact startswith istartswith iendswith endswith isnull range year month day 示例: Post . query . filter_by ( title__contains = 'sql' ) . all () Post . query . exclude_by ( title__contains = 'sql' ) . all () 关系查询 Post . query . filter_by ( tags__name__contains = 'sql' ) . all () 其它 Post . query . filter_by ( tags__name__contains = 'sql' ) . or ( Post . id == 1 , Post . id == 2 ) . all () Post . query . filter_by ( tags__name__contains = 'sql' ) . and ( Post . id == 1 , Post . id == 2 ) . all () Post . query . filter_by ( tags__name__contains = 'sql' ) . exists () Post . query . load_only ( 'title' ) 去掉一些sqlalchemy的重复工作 以 flask-sqlalchemy 为例,通过继承 models.py 中的 Mixin ,就可以去除部分重复工作 ModelMixin 自增ID -- id post = Post ( ····· ) post . save () # 保存 post . delete () # 保存 批量操作 bulk_insert bulk_update bulk_save ModelTimeMixin 增加两字段 created_at 数据创建时间 updated_at 数据更新时间 ModelUserMixin 关联用户表,与 User 表现为 多对一 关系(即一个用户有多个post) class Post ( ModelUserMixin , Model ): user_related_name = 'posts' titile = ...","tags":"Python","url":"https://honmaple.me/articles/2017/03/sqlalchemy使用上的小tips.html","loc":"https://honmaple.me/articles/2017/03/sqlalchemy使用上的小tips.html"},{"title":"使用flask实现一个简单的图片上传存储服务","text":"GitHub地址: https://github.com/honmaple/maple-file maple-file 使用flask实现的一个简单的图片上传服务 设计初衷 对于图片的存储,有很多选择,一般采用云服务如(七牛,又拍等),但是国内的服务像七牛 自定义域名竟然需要域名备案( Excuse me ,当初就是因为备案麻烦才选择国外的),而且浪费了我十块钱, 而我又想像七牛一样可以直接在本地就可以上传图片,找来找去，没有找到一个比较合适的，所以花两天时间自己写了一个 使用 由于初衷是本地脚本就可以发布,所以没有前端界面,等以后有时间了再加上 API /api/login POST 登录 /api/logout GET 注销 /api/albums GET 获取相册列表 POST 新建相册 name 相册名称 description 相册描述 /api/albums/ pk 相册ID GET 获取相册信息 PUT 修改相册信息 name 相册名称 description 相册描述 DELETE 删除相册 /api/images GET 获取图片列表 POST 上传图片 images 上传图片列表 album 相册ID(默认会新建一个 default 相册) /api/images/ GET 获取图片信息 PUT 修改图片信息 name 图片名称 description 图片描述 DELETE 删除图片 配置 class Config ( object ): DEBUG = True # 生产环境设置为False SECRET_KEY = 'ccc' # import os;os.urandom(24) SECRET_KEY_SALT = 'ssss' JSON_AS_ASCII = False PERMANENT_SESSION_LIFETIME = timedelta ( days = 3 ) PER_PAGE = 10 # 分页 ADMIN_URL = '/admin/aaaaa' # 后台地址 LOGIN_TOKEN_HEADER = 'Api-Key' # 将会影响到后面headers设置 LOGIN_TOKEN = 'api_key' #url?api_key=21312313 MIDDLEWARE = [ 'storage.common.middleware.CommonMiddleware' ] SQLALCHEMY_TRACK_MODIFICATIONS = False SQLALCHEMY_DATABASE_URI = 'sqlite:///test.db' # SQLALCHEMY_ECHO = DEBUG UPLOAD_ALLOWED_EXTENSIONS = set ([ 'png' , 'jpg' , 'jpeg' ]) # 允许上传的扩展名 UPLOAD_FOLDER_ROOT = os . path . dirname ( os . path . abspath ( __file__ )) UPLOAD_FOLDER_PATH = 'images' # 相对于当前文件路径的地址 UPLOAD_FOLDER = os . path . join ( UPLOAD_FOLDER_ROOT , UPLOAD_FOLDER_PATH ) 创建账户 python manager.py create_user 将同时创建一个 default 的相册 python manager.py key 显示用户key 上传 上传后图片保存路径 原图路径: UPLOAD_FOLDER + 'username' + 'photo' + %Y + %m + (时间戳+随机数).png 缩略图路径: UPLOAD_FOLDER + 'username' + 'thumb' + %Y + %m + (时间戳+随机数).png example 使用 requests 本地上传 import requests def images (): url = 'http://127.0.0.1:8000/api/images' files = { 'images' : open ( 'desktop.png' , 'rb' )} multiple_files = [ ( 'images' , ( '11.png' , open ( '11.png' , 'rb' ), 'image/png' )), ( 'images' , ( 'desktop.png' , open ( 'desktop.png' , 'rb' ), 'image/png' )) ] headers = { 'Api-Key' : 'InhpeWFuZzA4MDdJBtx4AWlPpI_Oxx1Ki8' , 'User-Agent' : 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36' } # r = requests.post(url, files=multiple_files, headers=headers) r = requests . post ( url , files = files , headers = headers ) print ( r . text )","tags":"Python","url":"https://honmaple.me/articles/2017/03/使用flask实现一个简单的图片上传存储服务.html","loc":"https://honmaple.me/articles/2017/03/使用flask实现一个简单的图片上传存储服务.html"},{"title":"修改agetty启动参数自动登陆linux","text":"环境: archlinux 参考 需求 想要Linux启动后默认以指定用户登陆,不用输入用户名,可以直接输入密码进入系统 实现 man agetty 修改以下文件 /sudo:root@localhost:/etc/systemd/system/getty.target.wants/getty@tty1.service 自动登陆系统(用户名密码都不用输) ExecStart=-/sbin/agetty -a username --noclear %I $TERM 自动登陆系统(仅输入密码) ExecStart=-/sbin/agetty --skip-login --login-options \"username\" --noclear %I $TERM","tags":"Linux","url":"https://honmaple.me/articles/2017/02/修改agetty启动参数自动登陆linux.html","loc":"https://honmaple.me/articles/2017/02/修改agetty启动参数自动登陆linux.html"},{"title":"linux终端常用快捷键","text":"移动光标快捷键 ctrl+f 向前移动一个字符 ctrl+b 向后移动一个字符 alt+f 向前移动一个单词 alt+b 向后移动一个单词 ctrl+a 移动到当前行首 ctrl+e 移动到当前行尾 ctrl+l 清屏，并在屏幕最上面开始一个新行 编辑命令行快捷键 ctrl+d 删除当前的字符 ctrl+t 交换当前字符和前一个字符的位置 alt+t 交换当前单词和前一个单词的位置 alt+u 把当前单词变成大写 alt+l 把当前单词变成小写 alt+c 把当前单词变成首字母大写的单词 ctrl+v 添加一个特殊字符，例如，要添加一个制表符，按ctrl+v+tab 剪切、粘贴快捷键 ctrl+k 剪切文本直到行的末尾 ctrl+u 剪切文本直到行的起始 ctrl+w 剪切光标前的单词 alt+d 剪切光标后的单词 ctrl+y 粘贴最近剪切的文本 alt+y 回退到先前剪切的文本并粘贴它 ctrl+c 删除整行","tags":"Linux","url":"https://honmaple.me/articles/2017/02/linux终端常用快捷键.html","loc":"https://honmaple.me/articles/2017/02/linux终端常用快捷键.html"},{"title":"python笔记","text":"TIME GMT时间格式 GMT_FORMAT = '%a, %d %b %Y %H:%M:%S GMT' 获取某个时间的时间戳 import datetime import time string = \"2018-03-31\" date_time = datetime . datetime . strptime ( string , '%Y-%m- %d ' ) time_time = time . mktime ( date_time . timetuple ()) print ( time_time ) 得到当天0点时间 today = datetime . datetime . today () b = datetime . datetime ( today . year , today . month , today . day , 0 , 0 , 0 ) print ( b ) now = time . time () midnight = now - ( now % 86400 ) + time . timezone itime = time . ctime ( midnight ) print ( itime ) 时间或时间戳与字符串转换 #把datetime转成字符串 def datetime_toString ( dt ): return dt . strftime ( \"%Y-%m- %d -%H\" ) #把字符串转成datetime def string_toDatetime ( string ): return datetime . strptime ( string , \"%Y-%m- %d -%H\" ) #把字符串转成时间戳形式 def string_toTimestamp ( strTime ): return time . mktime ( string_toDatetime ( strTime ) . timetuple ()) #把时间戳转成字符串形式 def timestamp_toString ( stamp ): return time . strftime ( \"%Y-%m- %d -%H\" , time . localtime ( stamp )) #把时间戳转成datetime def timestamp_toDatetime ( stamp ): return datetime . fromtimestamp ( stamp ) #把datetime类型转外时间戳形式 def datetime_toTimestamp ( dateTim ): return time . mktime ( dateTim . timetuple ()) 秒转化为时分秒 def time_string ( seconds ): hours , _minutes = divmod ( seconds , 3600 ) minutes , seconds = divmod ( _minutes , 60 ) return ( hours , minutes , seconds ) 获取上个月开始与结束时间 from datetime import datetime , timedelta def gen_zero_time (): ''' 生成当天零点时间 ''' today = datetime . today () b = datetime ( today . year , today . month , today . day , 0 , 0 , 0 ) return b d = gen_zero_time () end_date = d . replace ( day = 1 ) start_date = ( d . replace ( day = 1 ) + timedelta ( days =- 1 )) . replace ( day = 1 ) print ( start_date ) print ( end_date ) 获取上周星期天与星期六 from datetime import datetime , timedelta from dateutil import relativedelta today = datetime . now () start = today - timedelta (( today . weekday () + 1 ) % 7 ) sat = start + relativedelta . relativedelta ( weekday = relativedelta . SA ( - 1 )) sun = sat + relativedelta . relativedelta ( weekday = relativedelta . SU ( - 1 )) print ( sat ) print ( sun ) 获取上周时间(星期天零点到星期天零点) from datetime import datetime , timedelta def gen_zero_time (): ''' 生成当天零点时间 ''' today = datetime . today () b = datetime ( today . year , today . month , today . day , 0 , 0 , 0 ) return b a = gen_zero_time () start_date = a + timedelta ( days =- a . weekday () - 1 , weeks =- 1 ) end_date = start_date + timedelta ( days = 7 ) print ( start_date ) print ( end_date ) HTTP 在网址中加入参数 import urllib import urlparse def url_add_params ( url , ** params ): \"\"\" 在网址中加入新参数 \"\"\" pr = urlparse . urlparse ( url ) query = dict ( urlparse . parse_qsl ( pr . query )) query . update ( params ) prlist = list ( pr ) prlist [ 4 ] = urllib . urlencode ( query ) return urlparse . ParseResult ( * prlist ) . geturl () if __name__ == \"__main__\" : url = 'http://bbs.163.com' print url_add_params ( url , token = 123 , site = \"bbs\" ) urllib2发送json数据 POST请求 import json import urllib2 data = { 'ids' : [ 12 , 3 , 4 , 5 , 6 ] } req = urllib2 . Request ( 'http://example.com/api/posts/create' ) req . add_header ( 'Content-Type' , 'application/json' ) response = urllib2 . urlopen ( req , json . dumps ( data )) urllib2发送PUT或DELETE请求 import urllib2 opener = urllib2 . build_opener ( urllib2 . HTTPHandler ) request = urllib2 . Request ( 'http://example.org' , data = 'your_put_data' ) request . add_header ( 'Content-Type' , 'your/contenttype' ) request . get_method = lambda : 'PUT' url = opener . open ( request ) # 或者使用httplib import httplib conn = httplib . HTTPConnection ( 'www.foo.com' ) conn . request ( 'PUT' , '/myurl' , body ) resp = conn . getresponse () content = resp . read () Syntax 解析赋值字符串 即把 a=b c=d e=f g.a=1 g.a.b=2 g.c.d=3 h=\"a b c\" i='sss' 解析成 {'a': 'b', 'c': 'd', 'e': 'f', 'g': {'a': {'b': '2'}, 'c': {'d': '3'}}, 'h': 'a b c', 'i': 'sss'} regex = re . compile ( r \"([\\w.]+| \\\" [&#94;=]*|'[&#94;=]*)=( \\\" [&#94; \\\" ]* \\\" |'[&#94;']*'|.*?)(\\s|$)\" ) def parse_string ( string ): r = {} def _get ( key ): key = key . strip () if key [ 0 ] == key [ - 1 ] in [ \"'\" , \" \\\" \" ]: return key [ 1 : - 1 ] return key def _update ( value , nvalue ): if not isinstance ( nvalue , dict ) or not isinstance ( value , dict ): return nvalue for k , v in nvalue . items (): value . setdefault ( k , dict ()) if isinstance ( v , dict ): v = _update ( value [ k ], v ) value [ k ] = v return value def _set ( key , value ): for i in key . split ( \".\" )[:: - 1 ]: value = { i : value } return value for key , value in regex . findall ( string ): r = _update ( r , _set ( _get ( key ), _get ( value ))) return r 字典递归更新 即当更新 dict 的value也是一个 dict 时，递归更新相应内容 def update ( value , nvalue ): if not isinstance ( nvalue , dict ) or not isinstance ( value , dict ): return nvalue for k , v in nvalue . items (): if isinstance ( v , dict ): v = update ( value [ k ], v ) value . update ({ k : v }) return value 字典使用dot class dotdict ( dict ): __setattr__ = dict . __setitem__ __delattr__ = dict . __delitem__ def __getattr__ ( self , name ): value = self [ name ] if isinstance ( value , dict ): return dotdict ( value ) return value a = { 'a' : 1 , 'b' : 2 , 'c' : 3 , 'd' : { 'a' : '1' , '1' : 1 }} c = dotdict ( a ) print ( c . a ) print ( c . d . a ) 或者 class dotdict ( object ): def __init__ ( self , ** kwargs ): for key , value in kwargs . items (): setattr ( self , key , value ) 单例模式 from functools import wraps from threading import Lock def singleton ( class_ ): instances = {} _lock = Lock () @wraps ( class_ ) def _instance ( * args , ** kwargs ): with _lock : if class_ not in instances : instances [ class_ ] = class_ ( * args , ** kwargs ) instances [ class_ ] . __init__ ( * args , ** kwargs ) return instances [ class_ ] return _instance @singleton class AA ( object ): def __init__ ( self , a ): self . a = a def aa ( self ): print ( self . a ) a = AA ( 'ccc' ) . aa () b = AA ( 'baabb' ) . aa () print ( id ( a ) == id ( b )) Pip pip更新所有的packages pip freeze --local | grep -v '&#94;\\-e' | cut -d = -f 1 | xargs -n1 pip install -U 如果是更新 sudo 安装的packages pip freeze --local | grep -v '&#94;\\-e' | cut -d = -f 1 | xargs -n1 sudo pip install -U 判斷是否激活virtualenv import sys if hasattr ( sys , 'real_prefix' ): return True Django model得到所有field name MyModel . _meta . get_all_field_names () python运行超时设置 import signal class TimeoutError ( Exception ): pass def timeout ( seconds = 10 , error_message = \"Timer expired\" ): def _timeout ( func ): def _handle_timeout ( signum , frame ): raise TimeoutError ( error_message ) def wrapper ( * args , ** kwargs ): signal . signal ( signal . SIGALRM , _handle_timeout ) signal . alarm ( seconds ) try : result = func ( * args , ** kwargs ) finally : signal . alarm ( 0 ) return result return wrapper return _timeout 库 http://www.grokcode.com/864/snakefooding-python-code-for-complexity-visualization/ 其它 获取文件最后n行数据 import mmap def getlastline ( fname , n = 1 ): with open ( fname ) as source : mapping = mmap . mmap ( source . fileno (), 0 , prot = mmap . PROT_READ ) cursor = - 1 while n > 0 : n -= 1 cursor = mapping . rfind ( b ' \\n ' , 0 , cursor ) return mapping [ cursor :] . decode () . split ( \" \\n \" ) python列表中去除烦人的\"u\" # !/usr/bin/env python2 # -*- coding: utf-8 -*- s = [ u \"python\" , u \"golang\" , u \"lua\" ] print ( s ) #+RESULTS: : [u'python', u'golang', u'lua'] python script s = [ u \"python\" , u \"golang\" , u \"lua\" ] print ([ str ( i ) for i in s ]) #+RESULTS: : ['python', 'golang', 'lua'] jinja2 from jinja2 import Template template = Template ( '[{ % f or i in consul_join %}\"{{ i | string }}\"{ % i f not loop.last %},{ % e ndif %}{ % e ndfor %}]' ) template . render ( consul_join = [ u \"python\" , u \"golang\" , u \"lua\" ]) #+RESULTS: : u'[\"python\"\", \"golang\", \"lua\"]'","tags":"coding","url":"https://honmaple.me/articles/2017/01/python笔记.html","loc":"https://honmaple.me/articles/2017/01/python笔记.html"},{"title":"升级至python3.6导致环境出错解决","text":"最近archlinux升级至了 python3.6 ，直接导致了我的开发环境失效,唉 archlinux 果然不适合开发 虽然后面都已经解决了 事故（一） virtualenv不可用 ,原先使用python3.5创建的环境直接不能用了,只好删了原有了东西,重新使用python3.6创建 pip freeze > requestments . txt pip install - r requestments . txt 事故（二） py3status 报错 Traceback ( most recent call last ): File \"/usr/bin/py3status\" , line 11 , in < module > load_entry_point ( 'py3status==3.3' , 'console_scripts' , 'py3status' )() File \"/usr/lib/python3.6/site-packages/pkg_resources/__init__.py\" , line 561 , in load_entry_point return get_distribution ( dist ) . load_entry_point ( group , name ) File \"/usr/lib/python3.6/site-packages/pkg_resources/__init__.py\" , line 2631 , in load_entry_point return ep . load () File \"/usr/lib/python3.6/site-packages/pkg_resources/__init__.py\" , line 2291 , in load return self . resolve () File \"/usr/lib/python3.6/site-packages/pkg_resources/__init__.py\" , line 2297 , in resolve module = __import__ ( self . module_name , fromlist = [ '__name__' ], level = 0 ) File \"/usr/lib/python3.6/site-packages/py3status/__init__.py\" , line 4 , in < module > from py3status.core import Py3statusWrapper File \"/usr/lib/python3.6/site-packages/py3status/core.py\" , line 22 , in < module > from py3status.parse_config import process_config File \"/usr/lib/python3.6/site-packages/py3status/parse_config.py\" , line 23 , in < module > from py3status.private import PrivateHide , PrivateBase64 File \"/usr/lib/python3.6/site-packages/py3status/private.py\" , line 124 , in < module > class PrivateBase64 ( Private ): TypeError : _catch () missing 1 required positional argument : 's' py3status是i3wm status的python 替代品,用着还成,找了一下,在 https://github.com/ultrabug/py3status/pull/610 找到解决办法,在以下目录 /sudo:root@localhost:/usr/lib/python3.6/site-packages/py3status/private.py 修改 116行 EXCLUDE = [ '__init__' , '__getattribute__' , '__new__' , '__setattr__' ] 为 EXCLUDE = [ '__init__' , '__getattribute__' , '__new__' , '__setattr__' , '__init_subclass__' ] super + shift + r 重载i3wm 不管怎样，恭喜python发布新的版本","tags":"Linux","url":"https://honmaple.me/articles/2017/01/升级至python3.6导致环境出错解决.html","loc":"https://honmaple.me/articles/2017/01/升级至python3.6导致环境出错解决.html"},{"title":"我的毕业设计--数据库设计之站内信","text":"站内信设计 逻辑实现 点对点(私信) 发送方 sender 接收方 receiver 状态 status 信息内容 message 信息分类 message_type 发送时间 created_at 点对点发送消息比较简单,每次发送为单表时插入 sender , receiver , message , created_at (伪代码) 获取未读信息 select message from message where reveiver_id == 'user.id' and status = 'unread' ; 获取系统未读信息 select message from message where reveiver_id == 'user.id' and status = 'unread' and message_type = 'sys' 获取已读信息 status = 'read' 点对面(系统消息) 点对面实现不能像 点对点 一样为每一个用户创建一条数据(如果数以十万百万计) 具体实现看这里 http://www.cnblogs.com/grenet/archive/2010/04/09/1708008.html 简单讲一下我理解的逻辑(伪代码): 发送私信(点对点) # 先保存消息主体内容 message_text = MessageText ( sender = sender , message = message , message_type = message_type ( 私信 ) ) # 保存接受方，并关联消息主体 message = Message ( message_text_id = message_text . id , receiver = receiver , status = 'unread' ) 获取未读信息 messages = Message . query . filter_by ( receiver = current_user , status = 'unread' ) 系统消息 # 只保存消息主体内容 message_text = MessageText ( sender = sender , message = message , message_type = message_type ( 系统消息 ) ) 获取未读信息 判断 message 表中 message_text_id 是否存在于 message_text_id__list (receiver = current_user) 不存在 ,标记为 系统未读 存在,判断是否未读 获取具体未读信息 如上 不存在 时 # 保存消息 message = Message ( receiver = current_user , status = 'read' , message_text_id = message_text . id ) 存在 时, message.status = 'read' 数据库设计 信息表(关联) tablename : message 字段名 字段类型 字段描述 是否为空 是否unique 默认值 receiver_id integer 接收方外键ID False False receiver 接收方 False False message_text_id integer 站内信主体内容外键ID False False message_text 站内信主体内容 False False status string 站内信状态 False False 0(未读) 信息内容表 tablename : message_text 字段名 字段类型 字段描述 是否为空 是否unique 默认值 title string(128) 站内信标题 False False content text(1024) 站内信内容 False False message_type string 站内信类别 False False 2(系统信息) sender_id integer 发送方外键ID False False sender 发送方 False False","tags":"Life","url":"https://honmaple.me/articles/2016/12/我的毕业设计--数据库设计之站内信.html","loc":"https://honmaple.me/articles/2016/12/我的毕业设计--数据库设计之站内信.html"},{"title":"我的毕业设计--数据库设计之登陆注册","text":"登陆注册数据库设计 共同字段: id 主键,自增ID 用户表 tablename : user 字段名 字段类型 字段描述 是否为空 是否unique 默认值 username string(20) 用户名 False True password string(100) 密码 False False email string(49) 邮箱 False True is_superuser bool 是否为超级管理员 False False False is_confirmed bool 邮箱是否验证 False False False register_time datetime 注册时间 False False UTC时间 last_login datetime 上次登陆 True False 用户信息表 tablename : userinfo 字段名 字段类型 字段描述 是否为空 是否unique 默认值 avatar string(128) 头像路径 True False company string(128) 公司 True False website string(128) 网址 True False user_id integer 关联用户表外键 True True user 与用户信息成一对一关系 用户设置表 tablename : usersetting 字段名 字段类型 字段描述 是否为空 是否unique 默认值 locale string(49) 语言设置 False False zh timezone string(49) 时区设置 False False UTC user_id integer 关联用户表外键 True True user 与用户设置成一对一关系 用户token表 tablename : usertoken 字段名 字段类型 字段描述 是否为空 是否unique 默认值 token string(128) token False False available bool token是否有效 False False True created_at datetime token创建时间 False False UTC时间 updated_at datetime token更新时间 False False UTC时间(自动更新) user_id integer 关联用户表外键 True True user 与用户token成一对一关系 数据库实现 用户表 class User ( db . Model ): __tablename__ = 'user' id = db . Column ( db . Integer , primary_key = True ) username = db . Column ( '用户名' , db . String ( 49 ), unique = True , nullable = False ) email = db . Column ( '邮箱' , db . String ( 81 ), unique = True , nullable = False ) password = db . Column ( '密码' , db . String ( 81 ), nullable = False ) is_superuser = db . Column ( '是否超级管理员' , db . Boolean , default = False ) is_confirmed = db . Column ( '是否验证' , db . Boolean , default = False ) register_time = db . Column ( '注册时间' , db . DateTime , default = datetime . now ()) last_login = db . Column ( '上次登陆' , db . DateTime , nullable = True ) 用户信息表 class UserInfo ( db . Model ): __tablename__ = 'userinfo' id = db . Column ( db . Integer , primary_key = True ) avatar = db . Column ( db . String ( 128 )) school = db . Column ( db . String ( 128 ), nullable = True ) word = db . Column ( db . Text , nullable = True ) introduce = db . Column ( db . Text , nullable = True ) user_id = db . Column ( db . Integer , db . ForeignKey ( 'user.id' , ondelete = \"CASCADE\" )) user = db . relationship ( User , backref = db . backref ( \"info\" , uselist = False , cascade = 'all,delete' , lazy = 'joined' ), uselist = False , lazy = 'joined' ) 用户设置表 class UserSetting ( db . Model ): LOCALE_CHINESE = 'zh' LOCALE_ENGLISH = 'en' LOCALE = (( 'zh' , 'Chinese' ), ( 'en' , 'English' )) TIMEZONE_UTC = 'UTC' TIMEZONE = [( i , i ) for i in all_timezones ] __tablename__ = 'usersetting' id = db . Column ( db . Integer , primary_key = True ) locale = db . Column ( db . String ( 32 ), nullable = False , default = LOCALE_CHINESE ) timezone = db . Column ( db . String ( 32 ), nullable = False , default = TIMEZONE_UTC ) user_id = db . Column ( db . Integer , db . ForeignKey ( 'user.id' , ondelete = \"CASCADE\" )) user = db . relationship ( User , backref = db . backref ( \"setting\" , uselist = False , cascade = 'all,delete' , lazy = 'joined' ), uselist = False , lazy = 'joined' ) 用户token表 class UserToken ( db . Model ): __tablename__ = 'usertoken' id = db . Column ( db . Integer , primary_key = True ) token = db . Column ( db . String ( 128 ), nullable = False ) available = db . Column ( db . Boolean , nullable = False , default = True ) created_at = db . Column ( db . DateTime , default = datetime . utcnow (), nullable = False ) updated_at = db . Column ( db . DateTime , default = datetime . utcnow (), onupdate = datetime . utcnow ()) user_id = db . Column ( db . Integer , db . ForeignKey ( 'user.id' , ondelete = \"CASCADE\" )) user = db . relationship ( User , backref = db . backref ( \"token\" , uselist = False , cascade = 'all,delete' , lazy = 'joined' ), uselist = False , lazy = 'joined' ) 以后可能对表进行扩展","tags":"Life","url":"https://honmaple.me/articles/2016/12/我的毕业设计--数据库设计之登陆注册.html","loc":"https://honmaple.me/articles/2016/12/我的毕业设计--数据库设计之登陆注册.html"},{"title":"emacs预览图片时禁止smooth-scrolling","text":"需求 在使用 org-mode 写文档时，插入图片后默认不显示，想要直接在 org 文件中预览图片，可以使用 org-toggle-inline-images 但是问题来了，开启预览模式后，移动光标跳过文件内容，找了一下 参考链接 1 那么问题来了，如何只在开启 org-toggle-inline-images 后关闭 smooth-scrooling , 关闭 org-toggle-inline-images 后开启 smooth-scrooling 解决 给出代码,使用 defadvice ( defadvice org-toggle-inline-images ( after org-open-at-point activate ) ( if smooth-scrolling-mode ( smooth-scrolling-mode -1 ) ( smooth-scrolling-mode 1 ))) Footnotes 1 https://github.com/syl20bnr/spacemacs/issues/3824","tags":"Linux","url":"https://honmaple.me/articles/2016/12/emacs预览图片时禁止smooth-scrolling.html","loc":"https://honmaple.me/articles/2016/12/emacs预览图片时禁止smooth-scrolling.html"},{"title":"Python中的__main__函数","text":"__main__ 转自 这里 很多新手刚开始学习python的时候经常会看到python 中 __name__ = '__main__' 这样的代码，可能很多新手一开始学习的时候都比较疑惑，python 中 name__ = '__main__' 的作用，到底干嘛的？ 有句话经典的概括了这段代码的意义： \"Make a script both importable and executable\" 意思就是说让你写的脚本模块既可以导入到别的模块中用，另外该模块自己也可执行。 这句话，可能一开始听的还不是很懂。下面举例说明： 先写一个模块： #module.py def main (): print ( \"we are in %s \" % __name__ ) if __name__ == '__main__' : main () 这个函数定义了一个main函数，我们执行一下该py文件发现结果是打印出 we are in __main__ 说明我们的if语句中的内容被执行了，调用了 main()： 但是如果我们从另我一个模块导入该模块，并调用一次 main() 函数会是怎样的结果呢？ #anothermodle.py from module import main main () 其执行的结果是： we are in module 但是没有显示 \"we are in __main__\" 也就是说模块 name__ = '__main__' 下面的函数没有执行。 这样既可以让\"模块\"文件运行，也可以被其他模块引入，而且不会执行函数2次。这才是关键。 总结一下： 如果我们是直接执行某个.py文件的时候，该文件中那么 __name__ == '__main__' 是 True , 但是我们如果从另外一个.py文件通过import导入该文件的时候，这时 name__的值就是我们这个py文件的名字而不是 main__。 这个功能还有一个用处：调试代码的时候，在 if __name__ == '__main__' 中加入一些我们的调试代码， 我们可以让外部模块调用的时候不执行我们的调试代码，但是如果我们想排查问题的时候，直接执行该模块文件，调试代码能够正常运行！","tags":"Python","url":"https://honmaple.me/articles/2016/12/Python中的__main__函数.html","loc":"https://honmaple.me/articles/2016/12/Python中的__main__函数.html"},{"title":"flask使用token进行验证","text":"为什么需要用token验证 原因呢是因为写博客时已经在本地写好了，但是要发表到网站上还需要这么几步: 打开浏览器 打开我的网站 进入登陆页 登陆 进入后台页 进入文章发表页 复制粘贴 发表 所以使用 token 验证成为必然 如何使用token? 生成token 使用 itsdangerous 对token进行加密 class User ( model ): ...... @property def token ( self ): config = current_app . config secret_key = config . setdefault ( 'SECRET_KEY' ) salt = config . setdefault ( 'SECURITY_PASSWORD_SALT' ) serializer = URLSafeTimedSerializer ( secret_key ) # column = self.(需要加密的字段) token = serializer . dumps ( column , salt = salt ) return token 请保管好 SECRET_KEY 和 SECURITY_PASSWORD_SALT ,不要泄露 验证token class User ( Model ): ...... @staticmethod def check_token ( token , max_age = 86400 ): config = current_app . config secret_key = config . setdefault ( 'SECRET_KEY' ) salt = config . setdefault ( 'SECURITY_PASSWORD_SALT' ) serializer = URLSafeTimedSerializer ( secret_key ) try : column = serializer . loads ( token , salt = salt , max_age = max_age ) except BadSignature : return False except SignatureExpired : return False max-age 最大过期时间 如果验证成功查找 该用户 是否存在 user = User . query . filter_by ( column = column ) . first () if user is None : return False return user 示例: @staticmethod def check_token ( token , max_age = 86400 ): config = current_app . config secret_key = config . setdefault ( 'SECRET_KEY' ) salt = config . setdefault ( 'SECURITY_PASSWORD_SALT' ) serializer = URLSafeTimedSerializer ( secret_key ) try : username = serializer . loads ( token , salt = salt , max_age = max_age ) except BadSignature : return False except SignatureExpired : return False user = User . query . filter_by ( username = username ) . first () if user is None : return False return user 使用flask-login flask-login是flask的一个登陆扩展,自带token验证, 但是请一定要设 login_manager . session_protection = \"basic\" 这是我在试验了n次后,读了flask-login的源码后才发现的（其实后面发现文档有写☹） 然后设置 request_loader @login_manager.request_loader def user_loader_from_request ( request ): token = request . args . get ( 'your_token' ) if token is not None : user = User . check_token ( token ) if user : return user return login_manager 这是简单的从 url 中获取 token 进行验证,也可以从 header 中获取(更安全) token = request . headers . get ( 'your_token' ) 设置csrf白名单 非常不幸的是，假设你开启了 csrf 保护,本地使用脚本验证时会报 400 错误,设置 csrf 白名单 csrf . exempt 使用脚本发表 直接给出代码 from urllib import request import json content = ''' ,* adssad ,** adasd ,*** adsad ''' data = { 'title' : 'hello world' , 'content' : content } data = json . dumps ( data ) data = bytes ( data , 'utf8' ) url = 'xxxxx' + '?your_token=' req = request . Request ( url , data = data ) req . add_header ( 'Content-Type' , 'application/json' ) req . add_header ( 'User-Agent' , 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/44.0.2403.107 Safari/537.36' ) result = request . urlopen ( req ) . read () . decode ( 'utf-8' ) print ( result ) 现在的步骤是: 复制粘贴 发表 ok,后续可能还需要将 复制粘贴 这一步也去了 本篇文章就是采用这种方式发表","tags":"Python","url":"https://honmaple.me/articles/2016/12/flask使用token进行登陆.html","loc":"https://honmaple.me/articles/2016/12/flask使用token进行登陆.html"},{"title":"sqlalchemy序列化为json","text":"为什么需要这个需求? sqlalchemy 是个好东西,虽然其文档犹如/老太婆的裹脚布--又臭又长/,饱受诟病 使用 restful 时sqlalchemy返回的是一个 object 类，假设前后端分离,前端无法处理 如何实现? 直接给出代码 class Serializer ( object ): def __init__ ( self , instance , many = False , include = [], exclude = [], depth = 2 ): self . instance = instance self . many = many self . include = include self . exclude = exclude self . depth = depth @property def data ( self ): if self . include and self . exclude : raise ValueError ( 'include and exclude can \\' t work together' ) if self . many : if isinstance ( self . instance , list ): return self . _serializerlist ( self . instance , self . depth ) pageinfo = { 'items' : True , 'pages' : self . instance . pages , 'has_prev' : self . instance . has_prev , 'page' : self . instance . page , 'has_next' : self . instance . has_next , 'iter_pages' : list ( self . instance . iter_pages ( left_edge = 1 , left_current = 2 , right_current = 3 , right_edge = 1 )) } return { 'data' : self . _serializerlist ( self . instance . items , self . depth ), 'pageinfo' : pageinfo } return self . _serializer ( self . instance , self . depth ) def _serializerlist ( self , instances , depth ): results = [] for instance in instances : result = self . _serializer ( instance , depth ) if result : results . append ( result ) return results def _serializer ( self , instance , depth ): result = {} if depth == 0 : return result depth -= 1 model_class = self . get_model_class ( instance ) inp = self . get_inspect ( model_class ) model_data = self . _serializer_model ( inp , instance , depth ) relation_data = self . _serializer_relation ( inp , instance , depth ) result . update ( model_data ) result . update ( relation_data ) return result def _serializer_model ( self , inp , instance , depth ): result = {} model_columns = self . get_model_columns ( inp ) for column in model_columns : result [ column ] = getattr ( instance , column ) return result def _serializer_relation ( self , inp , instance , depth ): result = {} relation_columns = self . get_relation_columns ( inp ) for relation in relation_columns : column = relation . key if relation . direction in [ ONETOMANY , MANYTOMANY ]: children = getattr ( instance , column ) if relation . lazy == 'dynamic' : children = children . all () result [ column ] = Serializer ( children , many = True , exclude = [ relation . back_populates ], depth = depth ) . data else : child = getattr ( instance , column ) if relation . lazy == 'dynamic' : child = child . first () result [ column ] = Serializer ( child , many = False , exclude = [ relation . back_populates ], depth = depth ) . data return result def get_model_class ( self , instance ): return getattr ( instance , '__class__' ) def get_inspect ( self , model_class ): return inspect ( model_class ) def get_model_columns ( self , inp ): if self . include : model_columns = [ column . name for column in inp . columns if column . name in self . include ] elif self . exclude : model_columns = [ column . name for column in inp . columns if column . name not in self . exclude ] else : model_columns = [ column . name for column in inp . columns ] return model_columns def get_relation_columns ( self , inp ): if self . include : relation_columns = [ relation for relation in inp . relationships if relation . key in self . include ] elif self . exclude : relation_columns = [ relation for relation in inp . relationships if relation . key not in self . exclude ] else : relation_columns = [ relation for relation in inp . relationships ] return relation_columns 具体使用 使用上很简单(以flask-sqlalchemy为例),原生 sqlalchemy 类似 多个实例 posts = Post . query . all () serializer = Seralizer ( posts , many = True ) data = serializer . data 单个实例 post = Post . query . first () serializer = Seralizer ( post , many = False ) data = serializer . data 排除字段 serializer = Seralizer ( post , exclude = [ 'title' ]) 仅包括字段 serializer = Seralizer ( post , include = [ 'title' ]) 关系查询深度 serializer = Seralizer ( post , depth = 3 ) depth 默认为2","tags":"Python","url":"https://honmaple.me/articles/2016/12/sqlalchemy序列化为json.html","loc":"https://honmaple.me/articles/2016/12/sqlalchemy序列化为json.html"},{"title":"利用网易云api获取歌曲信息","text":"最近是增加了一个 aplayer 在网站上,但原本想要使用qiniu存储，最后觉得太麻烦了,直接利用网易云api获取歌曲 使用 python标准库urllib 直接给出代码 from urllib import request import json id = '28819878' url = \"http://music.163.com/api/song/detail/?id=\" + id + \"&ids=%5B\" + id + \"%5D&csrf_token\" rep = request . urlopen ( url ) . read () . decode ( 'UTF-8' ) rep = json . loads ( rep )[ 'songs' ][ 0 ] name = rep [ 'name' ] artist = rep [ 'artists' ][ 0 ][ 'name' ] mp3url = rep [ 'mp3Url' ] picurl = rep [ 'album' ][ 'blurPicUrl' ] print ( 'name:' , name ) print ( 'artists:' , artist ) print ( 'mp3:' , mp3url ) print ( 'pic:' , picurl ) url = 'http://music.163.com/api/song/media?id=' + id rep = request . urlopen ( url ) . read () . decode ( 'UTF-8' ) lyric = json . loads ( rep )[ 'lyric' ] print ( 'lyric: \\n ' , json . dumps ( lyric )) #+RESULTS: : name: 轨迹 : artists: 徐小薇 : mp3: http://m2.music.126.net/1vGFlmmY1NeHEZy_1QuYhA==/5898879883333738.mp3 : pic: http://p4.music.126.net/EMS4GE-ojql3azwxXYPT3w==/3264450024433079.jpg : lyric: : \"[00:12.98]\\u600e\\u4e48\\u9690\\u85cf\\u6211\\u7684\\u60b2\\u4f24\\n[00:19.10]\\u5931\\u53bb\\u4f60\\u7684\\u5730\\u65b9\\n[00:25.61]\\u4f60\\u7684\\u53d1\\u9999\\u6563\\u7684\\u5306\\u5fd9\\n[00:32.06]\\u6211\\u5df2\\u7ecf\\u8ddf\\u4e0d\\u4e0a\\n[00:38.49]\\u95ed\\u4e0a\\u773c\\u775b\\u8fd8\\u80fd\\u770b\\u89c1\\n[00:44.90]\\u4f60\\u79bb\\u53bb\\u7684\\u75d5\\u8ff9\\n[00:51.21]\\u5728\\u6708\\u5149\\u4e0b\\u4e00\\u76f4\\u627e\\u5bfb\\u90a3\\u60f3\\u5ff5\\u7684\\u8eab\\u5f71\\n[01:04.48]\\u5982\\u679c\\u8bf4\\u5206\\u624b\\u662f\\u82e6\\u75db\\u7684\\u8d77\\u70b9\\n[01:09.98]\\u90a3\\u5728\\u7ec8\\u70b9\\u4e4b\\u524d\\n[01:13.25]\\u6211\\u613f\\u610f\\u518d\\u7231\\u4e00\\u904d\\n[01:17.25]\\u60f3\\u8981\\u5bf9\\u4f60\\u8bf4\\u7684\\n[01:19.89]\\u4e0d\\u6562\\u8bf4\\u7684\\u7231\\n[01:23.52]\\u4f1a\\u4e0d\\u4f1a\\u6709\\u4eba\\u53ef\\u4ee5\\u660e\\u767d\\n[01:29.54]\\u6211\\u4f1a\\u53d1\\u7740\\u5446\\u7136\\u540e\\u5fd8\\u8bb0\\u4f60\\n[01:35.83]\\u63a5\\u7740\\u7d27\\u7d27\\u95ed\\u4e0a\\u773c\\n[01:42.27]\\u60f3\\u7740\\u90a3\\u4e00\\u5929\\u4f1a\\u6709\\u4eba\\u4ee3\\u66ff\\n[01:49.10]\\u8ba9\\u6211\\u4e0d\\u518d\\u60f3\\u5ff5\\u4f60\\n[01:55.10]\\u6211\\u4f1a\\u53d1\\u7740\\u5446\\u7136\\u540e\\u5fae\\u5fae\\u7b11\\n[02:01.51]\\u63a5\\u7740\\u7d27\\u7d27\\u95ed\\u4e0a\\u773c\\n[02:07.81]\\u53c8\\u60f3\\u4e86\\u4e00\\u904d\\u4f60\\u6e29\\u67d4\\u7684\\u8138\\n[02:14.54]\\u5728\\u6211\\u5fd8\\u8bb0\\u4e4b\\u524d\\n[02:30.42]\\u600e\\u4e48\\u9690\\u85cf\\u6211\\u7684\\u60b2\\u4f24\\n[02:36.77]\\u5931\\u53bb\\u4f60\\u7684\\u5730\\u65b9\\n[02:43.17]\\u4f60\\u7684\\u53d1\\u9999\\u6563\\u7684\\u5306\\u5fd9\\n[02:49.56]\\u6211\\u5df2\\u7ecf\\u8ddf\\u4e0d\\u4e0a\\n[02:56.09]\\u95ed\\u4e0a\\u773c\\u775b\\u8fd8\\u80fd\\u770b\\u89c1\\n[03:02.20]\\u4f60\\u79bb\\u53bb\\u7684\\u75d5\\u8ff9\\n[03:08.81]\\u5728\\u6708\\u5149\\u4e0b\\u4e00\\u76f4\\u627e\\u5bfb\\u90a3\\u60f3\\u5ff5\\u7684\\u8eab\\u5f71\\n[03:21.81]\\u5982\\u679c\\u8bf4\\u5206\\u624b\\u662f\\u82e6\\u75db\\u7684\\u8d77\\u70b9\\n[03:27.53]\\u90a3\\u5728\\u7ec8\\u70b9\\u4e4b\\u524d\\n[03:34.82]\\u6211\\u613f\\u610f\\u518d\\u7231\\u4e00\\u904d\\n[03:34.68]\\u60f3\\u8981\\u5bf9\\u4f60\\u8bf4\\u7684\\n[03:37.69]\\u4e0d\\u6562\\u8bf4\\u7684\\u7231\\n[03:41.11]\\u4f1a\\u4e0d\\u4f1a\\u6709\\u4eba\\u53ef\\u4ee5\\u660e\\u767d\\n[03:47.07]\\u6211\\u4f1a\\u53d1\\u7740\\u5446\\u7136\\u540e\\u5fd8\\u8bb0\\u4f60\\n[03:53.54]\\u63a5\\u7740\\u7d27\\u7d27\\u95ed\\u4e0a\\u773c\\n[03:59.73]\\u60f3\\u7740\\u90a3\\u4e00\\u5929\\u4f1a\\u6709\\u4eba\\u4ee3\\u66ff\\n[04:06.86]\\u8ba9\\u6211\\u4e0d\\u518d\\u60f3\\u5ff5\\u4f60\\n[04:12.96]\\u6211\\u4f1a\\u53d1\\u7740\\u5446\\u7136\\u540e\\u5fae\\u5fae\\u7b11\\n[04:19.08]\\u63a5\\u7740\\u7d27\\u7d27\\u95ed\\u4e0a\\u773c\\n[04:25.53]\\u53c8\\u60f3\\u4e86\\u4e00\\u904d\\u4f60\\u6e29\\u67d4\\u7684\\u8138\\n[04:32.24]\\u5728\\u6211\\u5fd8\\u8bb0\\u4e4b\\u524d\\n\\n[04:38.34]\\u6211\\u4f1a\\u53d1\\u7740\\u5446\\u7136\\u540e\\u5fd8\\u8bb0\\u4f60\\n[04:45.05]\\u63a5\\u7740\\u7d27\\u7d27\\u95ed\\u4e0a\\u773c\\n[04:51.10]\\u60f3\\u7740\\u90a3\\u4e00\\u5929\\u4f1a\\u6709\\u4eba\\u4ee3\\u66ff\\n[04:58.01]\\u8ba9\\u6211\\u4e0d\\u518d\\u60f3\\u5ff5\\u4f60\\n[05:03.89]\\u6211\\u4f1a\\u53d1\\u7740\\u5446\\u7136\\u540e\\u5fae\\u5fae\\u7b11\\n[05:10.25]\\u63a5\\u7740\\u7d27\\u7d27\\u95ed\\u4e0a\\u773c\\n[05:16.70]\\u53c8\\u60f3\\u4e86\\u4e00\\u904d\\u4f60\\u6e29\\u67d4\\u7684\\u8138\\n[05:23.50]\\u5728\\u6211\\u5fd8\\u8bb0\\u4e4b\\u524d\\n\\n[05:29.62]\\u5fc3\\u91cc\\u7684\\u773c\\u6cea\\n[05:32.81]\\u6a21\\u7cca\\u4e86\\u89c6\\u7ebf\\n[05:36.57]\\u4f60\\u5df2\\u5feb\\u770b\\u4e0d\\u89c1\" 结果格式化什么的看着格式吧，这些信息对我来说足够了","tags":"Python","url":"https://honmaple.me/articles/2016/12/利用网易云api获取歌曲信息.html","loc":"https://honmaple.me/articles/2016/12/利用网易云api获取歌曲信息.html"},{"title":"常用正则表达式","text":"校验数字的表达式 数字: &#94;[0-9]*$ n位的数字： &#94;\\d{n}$ 至少n位的数字： &#94;\\d{n,}$ m-n位的数字： &#94;\\d{m,n}$ 零和非零开头的数字： &#94;(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字： &#94;([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数： &#94;(\\-)?\\d+(\\.\\d{1,2})?$ 正数、负数、和小数： &#94;(\\-|\\+)?\\d+(\\.\\d+)?$ 有两位小数的正实数： &#94;[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数： &#94;[0-9]+(.[0-9]{1,3})?$ 非零的正整数： &#94;[1-9]\\d*$ 或 &#94;([1-9][0-9]*){1,3}$ 或 &#94;\\+?[1-9][0-9]*$ 非零的负整数： &#94;\\-[1-9][]0-9\"*$ 或 &#94;-[1-9]\\d*$ 非负整数： &#94;\\d+$ 或 &#94;[1-9]\\d*|0$ 非正整数： &#94;-[1-9]\\d*|0$ 或 &#94;((-\\d+)|(0+))$ 非负浮点数： &#94;\\d+(\\.\\d+)?$ 或 &#94;[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 非正浮点数： &#94;((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 &#94;(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ 正浮点数： &#94;[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 &#94;(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 负浮点数： &#94;-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 &#94;(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 浮点数： &#94;(-?\\d+)(\\.\\d+)?$ 或 &#94;-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 校验字符的表达式 汉字： &#94;[\\u4e00-\\u9fa5]{0,}$ 英文和数字： &#94;[A-Za-z0-9]+$ 或 &#94;[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符： &#94;.{3,20}$ 由26个英文字母组成的字符串： &#94;[A-Za-z]+$ 由26个大写英文字母组成的字符串： &#94;[A-Z]+$ 由26个小写英文字母组成的字符串： &#94;[a-z]+$ 由数字和26个英文字母组成的字符串： &#94;[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串： &#94;\\w+$ 或 &#94;\\w{3,20}$ 中文、英文、数字包括下划线： &#94;[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号： &#94;[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 &#94;[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有&#94;%&',;=?$\\\"等字符： [&#94;%&',;=?$\\x22]+ 禁止输入含有~的字符： [&#94;~\\x22]+ 特殊需求表达式 Email地址： &#94;\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 域名： [a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL： [a-zA-z]+://[&#94;\\s]* 或 &#94;http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&=]*)?$ 手机号码： &#94;(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 电话号码(\"XXX-XXXXXXX\"、\"XXXX-XXXXXXXX\"、\"XXX-XXXXXXX\"、\"XXX-XXXXXXXX\"、\"XXXXXXX\"和\"XXXXXXXX)： &#94;(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)： \\d{3}-\\d{8}|\\d{4}-\\d{7} 身份证号(15位、18位数字)： &#94;\\d{15}|\\d{18}$ 短身份证号码(数字、字母x结尾)： &#94;([0-9]){7,18}(x|X)?$ 或 &#94;\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)： &#94;[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)： &#94;[a-zA-Z]\\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)： &#94;(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 日期格式： &#94;\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)： &#94;(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)： &#94;((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 有四种钱的表示形式我们可以接受:\"10000.00\" 和 \"10,000.00\", 和没有 \"分\" 的 \"10000\" 和 \"10,000\"： &#94;[1-9][0-9]*$ 这表示任意一个不以0开头的数字,但是,这也意味着一个字符\"0\"不通过,所以我们采用下面的形式： &#94;(0|[1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号： &#94;(0|-?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分： &#94;[0-9]+(.[0-9]+)?$ 必须说明的是,小数点后面至少应该有1位数,所以\"10.\"是不通过的,但是 \"10\" 和 \"10.2\" 是通过的： &#94;[0-9]+(.[0-9]{2})?$ 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样： &#94;[0-9]+(.[0-9]{1,2})?$ 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样： &#94;[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须： &#94;([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ xml文件： &#94;([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$ 中文字符的正则表达式： [\\u4e00-\\u9fa5] 双字节字符： [&#94;\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式： \\n\\s*\\r (可以用来删除空白行) HTML标记的正则表达式： < (\\S*?)[&#94;>]*>.*? < /\\1>| <. *? /> 首尾空白字符的正则表达式： &#94;\\s*|\\s*$或(&#94;\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号： [1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码： [1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) IP地址： \\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用) IP地址： ((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))","tags":"Python","url":"https://honmaple.me/articles/2016/11/常用正则表达式.html","loc":"https://honmaple.me/articles/2016/11/常用正则表达式.html"},{"title":"世界这么大，我想去看看","text":":世界那么大，我想去看看··· :我得养家······","tags":"Life","url":"https://honmaple.me/articles/2016/10/世界这么大，我想去看看.html","loc":"https://honmaple.me/articles/2016/10/世界这么大，我想去看看.html"},{"title":"thunar不显示回收站解决","text":"最近打开虚拟机中的thunar时总是不能在界面上显示回收站，而我将 rm 修改成了 mv to Trash 经常会清空回收站,所以找了一下解决办法 参考问题 办法很简单 sudo pacman -S gvfs ok","tags":"Linux","url":"https://honmaple.me/articles/2016/10/thunar不显示回收站解决.html","loc":"https://honmaple.me/articles/2016/10/thunar不显示回收站解决.html"},{"title":"virtualbox挂载共享文件夹","text":"设置 --> 共享文件夹 固定分配 自动挂载 共享文件夹名称 Share sudo mkdir /mnt/share sudo mount -t vboxsf Share /mnt/share","tags":"Linux","url":"https://honmaple.me/articles/2016/10/virtualbox挂载共享文件夹.html","loc":"https://honmaple.me/articles/2016/10/virtualbox挂载共享文件夹.html"},{"title":"世界总是充满杯具","text":"独自旅行的杯子 <2017-10-20 五 18:53> 世界总是充满杯具,正如陪伴了我大学三年多的水杯,独自坐上了开往广州的火车,离我而去 注 :运动是相对的 忘记背包的英文 世界总是充满杯具,正如帮助一名忘记拉上背包拉链的外国友人,\"Your...Your\"了半天，最后一句\"I help you\"换来的却是一句中文的\"谢(sei)谢(sei)\" 注 : 背包 backpack <2017-10-23 一 18:58> 错过的火车 世界总是充满杯具,正如那错过的火车，刚到月台，火车刚开走,只要再给我30s,不，就20s······ 注 : 结果坐上了左边的动车(我买的可是高铁票)","tags":"Life","url":"https://honmaple.me/articles/2016/10/世界总是充满杯具.html","loc":"https://honmaple.me/articles/2016/10/世界总是充满杯具.html"},{"title":"工作有感","text":"先空着，最近有些忙,忙啊，忙 从校园到工作岗位 从学生到公司职员 从活着到活着","tags":"Life","url":"https://honmaple.me/articles/2016/10/工作有感.html","loc":"https://honmaple.me/articles/2016/10/工作有感.html"},{"title":"python复习--装饰器","text":"一个装饰器 from functools import wrapper def log ( func ): @wraps ( func ) def wrapper ( * args , ** kw ): print ( 'call %s ():' % func . __name__ ) return func ( * args , ** kw ) return wrapper 或者针对带参数的decorator： def log ( text ): def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kw ): print ( ' %s %s ():' % ( text , func . __name__ )) return func ( * args , ** kw ) return wrapper return decorator","tags":"Python","url":"https://honmaple.me/articles/2016/07/python复习--装饰器.html","loc":"https://honmaple.me/articles/2016/07/python复习--装饰器.html"},{"title":"python的os模块学习","text":"Process Parameters os.environ(环境变量) >>> os . environ [ 'HOME' ] '/home/xxx' os.getenv(key, default=None) >>> os . getenv ( \"HOME\" ) '/home/xxx' os.path os.path.abspath(path) #返回绝对路径 >>> os . path . abspath ( 'aa.py' ) '/home/jianglin/test/aa.py' os.path.basename(path) #返回文件名 >>> os . path . basename ( 'aa.py' ) 'aa.py' os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。 >>> os . path . commonprefix ([ 'aa.py' , 'a.py' ]) 'a' >>> os . path . commonprefix ([ 'aa.py' , 'c.py' ]) '' >>> os . path . commonprefix ([ '~/test/aa.py' , '~/test/c.py' ]) '~/test/' >>> os . path . commonprefix ([ '~/test/aa.py' , '~/test/c.py' , '~/test/git/.git/config' ]) '~/test/' os.path.dirname(path) #返回文件路径 >>> os . path . dirname ( '~/test/aa.py' ) '~/test' os.path.exists(path) #路径存在则返回True,路径不存在返回False os.path.exists('aa.py') True >>> os . path . exists ( 'aa.pp' ) False os.path.lexists #路径存在则返回True,路径不存在也返回False >>> os . path . lexists ( 'aa.py' ) True >>> os . path . lexists ( 'aa.pp' ) False os.path.expanduser(path) #把path中包含的\"~\"和\"~user\"转换成用户目录 >>> os . path . expanduser ( 'aa.py' ) 'aa.py' >>> os . path . expanduser ( '~/test/aa.py' ) '/home/jianglin/test/aa.py' os.path.expandvars(path) #根据环境变量的值替换path中包含的\"(name\"和\"){name}\" os.path.getatime(path) #返回最后一次进入此path的时间。 >>> os . path . getatime ( 'aa.py' ) 1461933601.0809627 >>> os . path . getatime ( '~/git/' ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > File \"/usr/lib/python3.5/genericpath.py\" , line 60 , in getatime return os . stat ( filename ) . st_atime FileNotFoundError : [ Errno 2 ] No such file or directory : '~/git/' >>> os . path . getatime ( '~/git/maple-bbs/.gitignore' ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > File \"/usr/lib/python3.5/genericpath.py\" , line 60 , in getatime return os . stat ( filename ) . st_atime FileNotFoundError : [ Errno 2 ] No such file or directory : '~/git/maple-bbs/.gitignore' >>> os . path . getatime ( 'a.py' ) 1461418983.486829 >>> os . path . getatime ( '~/git' ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > File \"/usr/lib/python3.5/genericpath.py\" , line 60 , in getatime return os . stat ( filename ) . st_atime FileNotFoundError : [ Errno 2 ] No such file or directory : '~/git' >>> os . path . getatime ( './git/.git/config' ) 1461856107.9136002 os.path.getmtime(path) #返回在此path下最后一次修改的时间。 >>> os . path . getmtime ( 'aa.py' ) 1461933858.6676357 os.path.getctime(path) >>> os . path . getctime ( 'aa.py' ) 1461933858.6676357 os.path.getsize(path) #返回文件大小，如果文件不存在就返回错误 >>> os . path . getsize ( 'aa.py' ) 448 os.path.isabs(path) #判断是否为绝对路径 >>> os . path . isabs ( 'aa.py' ) False >>> os . path . isabs ( '~/test/aa.py' ) False >>> os . path . isabs ( '/home/jianglin/test/aa.py' ) True os.path.isfile(path) #判断路径是否为文件 >>> os . path . isfile ( 'aa.py' ) True >>> os . path . isfile ( '~/test' ) False os.path.isdir(path) #判断路径是否为目录 >>> os . path . isdir ( '~/test' ) False >>> os . path . isdir ( '/home/jianglin/test/aa.py' ) False >>> os . path . isdir ( '/home/jianglin/test' ) True os.path.islink(path) #判断路径是否为链接 os.path.ismount(path) #判断路径是否为挂载点（） os.path.join(path1[, path2[, …]]) #把目录和文件名合成一个路径 >>> os . path . join ( '/home/jianglin/test' , 'aa.py' ) '/home/jianglin/test/aa.py' >>> os . path . join ( '/home/jianglin' , 'test/aa.py' ) '/home/jianglin/test/aa.py' >>> os . path . join ( '~' , 'test/aa.py' ) '~/test/aa.py' os.path.normcase(path) #转换path的大小写和斜杠 os.path.normpath(path) #规范path字符串形式 os.path.realpath(path) #返回path的真实路径 os.path.relpath(path[, start]) #从start开始计算相对路径 os.path.samefile(path1, path2) #判断目录或文件是否相同 os.path.sameopenfile(fp1, fp2) #判断fp1和fp2是否指向同一文件 os.path.samestat(stat1, stat2) #判断stat tuple stat1和stat2是否指向同一个文件 os.path.split(path) #把路径分割成dirname和basename，返回一个元组 >>> os . path . split ( '~/test/aa.py' ) ( '~/test' , 'aa.py' ) os.path.splitdrive(path) #一般用在windows下，返回驱动器名和路径组成的元组 os.path.splitext(path) #分割路径，返回路径名和文件扩展名的元组 os.path.splitunc(path) #把路径分割为加载点与文件 os.path.walk(path, visit, arg) #遍历path，进入每个目录都调用visit函数，visit函数必须有 3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有 文件名，args则为walk的第三个参数 os.path.supportsunicodefilenames #设置是否支持unicode路径名","tags":"Python","url":"https://honmaple.me/articles/2016/07/python的os模块学习.html","loc":"https://honmaple.me/articles/2016/07/python的os模块学习.html"},{"title":"sqlalchemy常见数据类型及配置","text":"类型名称 python类型 描述 Integer int 常规整形，通常为32位 SmallInteger int 短整形，通常为16位 BigInteger int或long 精度不受限整形 Float float 浮点数 Numeric decimal.Decimal 定点数 String str 可变长度字符串 Text str 可变长度字符串，适合大量文本 Unicode unicode 可变长度Unicode字符串 Boolean bool 布尔型 Date datetime.date 日期类型 Time datetime.time 时间类型 Interval datetime.timedelta 时间间隔 Enum str 字符列表 PickleType 任意Python对象 自动Pickle序列化 LargeBinary str 二进制 可选参数 描述 primarykey 如果设置为True，则为该列表的主键 unique 如果设置为True，该列不允许相同值 index 如果设置为True，为该列创建索引，查询效率会更高 nullable 如果设置为True，该列允许为空。如果设置为False，该列不允许空值 default 定义该列的默认值","tags":"Python","url":"https://honmaple.me/articles/2016/07/sqlalchemy常见数据类型及配置.html","loc":"https://honmaple.me/articles/2016/07/sqlalchemy常见数据类型及配置.html"},{"title":"honmaple社区程序config介绍","text":"DEBUG 生产环境选择False 测试环境选择True SECRET_KEY 安全密钥,可通过下面方法生成: >>> import os >>> os . urandom ( 24 ) b ' \\xdf r \\xff\\xd1\\xbc O \\xc1\\xa9 _ \\xcb\\x18\\x04\\xa6 ZVJ \\xf8\\xd2 6] \\x07 _HE' SECURITY_PASSWORD_SALT 加盐,主要用于生成邮箱验证url REMEMBER_COOKIE_DURATION PERMANENT_SESSION_LIFETIME 设置记住我之后cookies保存时间 使用 datetime.timedelta(days=3) PER_PAGE 设置每页显示多少条主题 定制缓存 缓存这块暂时还有一些问题 主要设置 CACHE_REDIS_HOST = '127.0.0.1' CACHE_REDIS_PORT = '6379' CACHE_REDIS_PASSWORD = '' CACHE_REDIS_DB = 1 CACHE_DEFAULT_TIMEOUT = 60 CACHE_KEY_PREFIX = 'cache:' SERVER_NAME 设置域名,本地测试使用 SERVER_NAME = 'localhost:5000' 生产环境使用 SERVER_NAME = '你的域名' /注意/ : 该论坛程序默认使用的是 forums.example.com 子域名,并且启用了 docs.example.com子域名 如果想要使用 example.com 作为论坛域名,需要注释 maple/__init__.py app . url_map . _rules . clear () app . url_map . _rules_by_endpoint . clear () app . url_map . default_subdomain = 'forums' app . add_url_rule ( app . static_url_path + '/<path:filename>' , endpoint = 'static' , view_func = app . send_static_file , subdomain = 'forums' ) 不想启用 docs 子域名 请修改 maple/urls.py app . register_blueprint ( docs_site , subdomain = 'docs' ) 改成 app . register_blueprint ( docs_site , url_prefix = '/docs) ONLINE_LAST_MINUTES 记录在线时间,默认为5分钟 邮箱设置 MAIL_SERVER = MAIL_PORT = MAIL_USE_TLS = True MAIL_USE_SSL = False MAIL_USERNAME = MAIL_PASSWORD = MAIL_DEFAULT_SENDER = 数据库设置 SQLALCHEMY_DATABASE_URI = '' 时区及语言设置 LANGUAGES = {'en': 'English', 'zh': 'Chinese'}","tags":"Life","url":"https://honmaple.me/articles/2016/07/honmaple社区程序config介绍.html","loc":"https://honmaple.me/articles/2016/07/honmaple社区程序config介绍.html"},{"title":"tar打包排除目录","text":"使用 --exclude + 需要排除的目录 示例: tar zcvf hello.tar.gz --exclude = \"**/__pycache__\" maple/ manager.py 注意 : --exclude 参数需要在要打包的文件或目录前,否则不起作用,另外排除的目录后不能加 */* --exclude 同样用于 排除文件 tar zcvf hello . tar . gz -- exclude = \"*.pyc\" maple / manager . py","tags":"Linux","url":"https://honmaple.me/articles/2016/07/tar打包排除目录.html","loc":"https://honmaple.me/articles/2016/07/tar打包排除目录.html"},{"title":"如何安装及使用honmaple社区程序","text":"如何安装及使用 安装需要的package pip install -r requirements.txt 配置config 查看配置详细介绍 注释下面代码 因为如果不注释的话 初始化数据库 会报错 文件位置: maple/topic/forms.py category = SelectField( _('Category:'), choices=[(b.id, b.board + ' --' + b.parent_board) for b in Board.query.all()], coerce=int) 初始化数据库 python manage.py db init python manage.py db migrate -m \"first migrate\" python manage.py db upgrade ok,将第三步中注释的内容恢复 创建管理员账户 python manager.py create_user 本地搭建 登陆并进入后台 python manager.py runserver Visit http://forums.localhost:5000/admin 服务端搭建 参考 http://flask.pocoo.org/docs/0.11/deploying/ 以我的配置为例: 配置nginx server { listen 80 ; server_name _ ; access_log /var/log/nginx/access.log ; error_log /var/log/nginx/error.log ; location / { proxy_pass http : // 127.0.0.1 : 8000 / ; proxy_redirect off ; proxy_set_header Host $host ; proxy_set_header X-Real-IP $remote_addr ; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for ; proxy_set_header X-Forwarded-Proto $scheme ; } } 配置supervior [program:forums] user = www command = /home/www/forums/venv/bin/gunicorn run:app -c /home/www/forums/gunicorn.conf directory = /home/www/forums autostart = true autorestart = true stdout_logfile = /home/www/forums/logs/gunicorn_supervisor.log 配置gunicorn workers = 2 bind = '127.0.0.1:8000' 启动 确定配置无误后 supervisord -c /etc/supervisord.conf supervisorctl -c /etc/supervisord.conf reload","tags":"Life","url":"https://honmaple.me/articles/2016/07/如何安装及使用honmaple社区程序.html","loc":"https://honmaple.me/articles/2016/07/如何安装及使用honmaple社区程序.html"},{"title":"virtualbox中使用U盘等usb设备","text":"主系统:archlinux + virtualbox 5.0.24-1 虚拟机:windows 安装VirtualBox Extension Pack 下载 先从官网下载扩展包 https://www.virtualbox.org/wiki/Downloads 注意 :版本要一致 └──╼ pacman -Qi virtualbox 名字 : virtualbox 版本 : 5 .0.24-1 描述 : Powerful x86 virtualization for enterprise as well as home use 架构 : x86_64 所以下载 5.0 版本的pack 安装 参考 https://wiki.archlinux.org/index.php/VirtualBox $ sudo VBoxManage extpack install Oracle_VM_VirtualBox_Extension_Pack-5.0.24-108355.vbox-extpack 安装不一致的版本会 └──╼ sudo VBoxManage extpack install Oracle_VM_VirtualBox_Extension_Pack-5.1.0-108711.vbox-extpack 0 %... Progress state: NS_ERROR_FAILURE VBoxManage: error: Failed to install \"/home/jianglin/VirtualBox VMs/extpack/Oracle_VM_VirtualBox_Extension_Pack-5.1.0-108711.vbox-extpack\" VBoxManage: error: VBoxExtPackRegister returned VERR_VERSION_MISMATCH, pReg = 0000000000000000 ErrInfo = 'VirtualBox version mismatch - expected 5.1 got 5.0' VBoxManage: error: Details: code NS_ERROR_FAILURE ( 0x80004005 ) , component ExtPackManagerWrap, interface IExtPackManager VBoxManage: error: Context: \"RTEXITCODE handleExtPack(HandlerArg*)\" at line 1158 of file VBoxManageMisc.cpp 卸载 参考 https://www.virtualbox.org/manual/ch08.html#vboxmanage-extpack 不是 └──╼ sudo VBoxManage extpack uninstall Oracle_VM_VirtualBox_Extension_Pack-5.0.24-108355.vbox-extpack 0 %... Progress state: NS_ERROR_FAILURE VBoxManage: error: Failed to uninstall \"Oracle_VM_VirtualBox_Extension_Pack-5.0.24-108355.vbox-extpack\" VBoxManage: error: Invalid extension pack name specified VBoxManage: error: Details: code NS_ERROR_FAILURE ( 0x80004005 ) , component ExtPackManagerWrap, interface IExtPackManager VBoxManage: error: Context: \"RTEXITCODE handleExtPack(HandlerArg*)\" at line 1199 of file VBoxManageMisc.cpp 而是 └──╼ sudo VBoxManage extpack uninstall \"Oracle VM VirtualBox Extension Pack\" 0 %...10%...20%...30%...40%...50%...60%...70%...80%...90%...100% Successfully uninstalled \"Oracle VM VirtualBox Extension Pack\" . 启用usb设备 虚拟机需要 关机 设置->USB设备->启用USB控制器->勾选3.0 开机:顶部 设备 里选择 USB OK,就这样","tags":"Linux","url":"https://honmaple.me/articles/2016/07/virtualbox中使用U盘等usb设备.html","loc":"https://honmaple.me/articles/2016/07/virtualbox中使用U盘等usb设备.html"},{"title":"centos7安装python3及pip3","text":"安装Python3 安装python3很简单 下载源码并且编译 安装epel 这里采用第二种方法: yum install epel-release 安装完成之后,yum list python3*,你就可以看见 python34 yum install python34 安装pip3 参考问题 如果在上述安装 python3 时采用了第二种方法,pip默认未安装,而且无法通过`yum install python34-pip`来安装 正确的方法应该是: yum install python34-setuptools easy_install-3.4 pip # 这里可能有一些出入,总之是使用python3的easy_install ok,就这样","tags":"Python","url":"https://honmaple.me/articles/2016/07/centos7安装python3及pip3.html","loc":"https://honmaple.me/articles/2016/07/centos7安装python3及pip3.html"},{"title":"记录pip安装时报的错","text":"Pillow ValueError: jpeg is required unless explicitly disabled using --disable-jpeg, aborting ---------------------------------------- Command \"/home/***/***/venv/bin/python3.4 -u -c \" import setuptools, tokenize ; __file__ = '/tmp/pip-build-k9djbrwk/Pillow/setup.py' ; exec ( compile ( getattr ( tokenize, 'open' , open )( __file__ ) .read () .replace ( '\\r\\n' , '\\n' ) , __file__, 'exec' )) \" install --record /tmp/pip-i_zr9z4a-record/install-record.txt --single-version-externally-managed --compile --install-headers /home/***/***/venv/include/site/python3.4/Pillow\" failed with error code 1 in /tmp/pip-build-k9djbrwk/Pillow 解决办法: # yum install libjpeg-turbo-devel 其实这个办法也不太准确, 参考 pillow文档 ,安装 $ sudo yum install libtiff-devel libjpeg-devel libzip-devel freetype-devel lcms2-devel libwebp-devel tcl-devel tk-devel misaka error: Setup script exited with error: command ‘gcc' failed with exit status 1 我使用 pip3 install misaka 报错 error: Setup script exited with error: command ‘gcc' failed with exit status 1 ， 上 google 搜了半天,结果都是 python-devel 没装，实际上我的已经装上了， 我以为是因为我自己编译安装的python3没有安装python3-devel,又搜了半天，什么也没搜到， 后来心血来潮使用 easy_install misaka 不用多说，还是报错，但是报错原因成了 No package 'libffi' found ,好吧， yum list libffi\\*之后，发现libffi已安装，但是libffi-devel未安装， yum install libffi-devel 试一试，结果。。。成功了 psycopg2 psycopg2安装之前需要安装 postgresql-devel ,此外,正确的安装方式是 PATH = $PATH :/usr/pgsql-9.3/bin/ pip install psycopg2 /注意postgresql目录/ 报错信息 pysqlite dialects/sqlite/pysqlite.py \", line 339, in dbapi raise e werkzeug.utils.ImportStringError: import_string() failed for 'config'. Possible reasons are: - missing __init__.py in a package; - package or module path not included in sys.path; - duplicated package or module name taking precedence in sys.path; - missing module, class, function or variable; Debugged import: - 'config' not found. Original exception: ImportError: No module named pysqlite2 pip install pysqlite src/connection.h:33:21: fatal error: sqlite3.h: No such file or directory #include \"sqlite3.h\" &#94; compilation terminated. error: command 'gcc' failed with exit status 1 ---------------------------------------- Command \"/home/exingcai/.Envs/iotschedule/bin/python -u -c \" import setuptools, tokenize ; __file__ = '/tmp/pip-build-aT3yRf/pysqlite/setup.py' ; exec ( compile ( getattr ( tokenize, 'open' , open )( __file__ ) .read () .replace ( '\\r\\n' , '\\n' ) , __file__, 'exec' )) \" install --record /tmp/pip-1MtibC-record/install-record.txt --single-version-externally-managed --compile --install-headers /home/exingcai/.Envs/iotschedule/include/site/python2.7/pysqlite\" failed with error code 1 in /tmp/pip-build-aT3yRf/pysqlite/ 解决办法: sudo yum install sqlite-devel","tags":"Python","url":"https://honmaple.me/articles/2016/07/记录pip安装时报的错.html","loc":"https://honmaple.me/articles/2016/07/记录pip安装时报的错.html"},{"title":"emacs解决windowns文件乱码","text":"最近在看windows文件时总是乱码，查了资料后才知道windowns下的编码为 gb2312 , 而linux下的编码为 utf-8 ,所以打开文件会乱码 如何解决? 换系统 这不是废话吗! 修改language环境 在配置文件中加入这么一行 (set-language-environment 'Chinese-GB) 重启就行,结果····打开 linux下的文件乱码 重新以gb2312的编码载入文件(推荐) 参考这里 M-x revert-buffer-with-coding-system 选择chinese-gb2312,确认载入(不需要重启) ok,是不是很简单","tags":"Linux","url":"https://honmaple.me/articles/2016/06/emacs解决windowns文件乱码.html","loc":"https://honmaple.me/articles/2016/06/emacs解决windowns文件乱码.html"},{"title":"黑客丛林之旅","text":"无意间看到，试了一下,结果 http://www.fj543.com/hack/ 第一关 没什么好说的,查看源码 第二关 还是查看源码,结果发现 onSubmit=\"return chkPassword()\" Ok,f12进入 console ,输入 function chkPassword (){ alert ( 'adas' ); } 覆盖原有js 第三关 这关我也没想到，后来百度之，原来是cookie的原因 还是进 console document . cookie = \"login=yes\" 第四关 看到这里是不是很熟悉，摩尔斯密码,google一下 对应的密码就是 iamok 第五关 根据提示,密文为成 YmFzZTY0aXNvaw== 或 ad93c1d102ae60f4 第一个很熟悉为base64加密,第二个为md5加密,解密后的密文为 └──╼ base64 -d YmFzZTY0aXNvaw == ( C-D ) base64isok 第六关 what?这是什么,实在是想不出来,百度一下, 原来 password = sum(port) 密码为各数据库port之和 password = MSSQL(1433)+MySQL(3306)+Oracle(1521) = 6260 第七关 很明显,考察的是对图片的处理,但是我不会,不会，会.... 文本打开,拉到最后面你会发现\"爸鼻我们去哪儿\"(vim打开乱码,emacs打开还是图片,C-c C-c转换后乱码) feh打开，发现\"8b\" OK,key应该就是 8bwmqne （待会儿试试将emacs的编码转成windows的） 第八关 社工,百度 其实只要右上角，查看作者介绍就能知道 吴世昌的弟弟叫吴其昌,网名 fj573 第九关 提示语 ：使用IE 5.43版本的浏览器访问?level=9token可以得到令牌。(Use IE 5.43 version to browse ?level=9token) 直接访问 http://www.fj543.com/hack/?level=9token 得到提示:您的浏览器不是IE 5.43版本！(Your browser is not IE 5.43) OK，知道了，这关考察 user-agent 修改 *user-agent* f12，关闭按钮旁边 More tools 选择 Network conditions 选择IE7,将MSIE 7.0改成MSIE 5.43. \\注意\\:直接点击无法复制,选择Nerwork,刷新后随意点一个查看 Headers 第十关 需要下载运行文件，算了","tags":"Security","url":"https://honmaple.me/articles/2016/06/黑客丛林之旅.html","loc":"https://honmaple.me/articles/2016/06/黑客丛林之旅.html"},{"title":"flask时间格式化","text":"在前端显示为该问题 \"几分钟前发表或几天前发表\" 后端通过filter注册 参考资料 设计需求 如果问题发表超过 10天 ,则显示为 /%Y-%m-%d %H:%M/ 如果小于 10天 ，但是大于 1天 ，则显示为 /n天前/ 发表 如果小于 1天 ，但是大于 1小时 ，则显示为 /n小时前/ 发表 如果小于 1小时 ，但是大于 90秒 ，则显示为 /n分钟前/ 发表 如果小于 90秒 ，则显示为 /刚刚/ 发表 具体实现 通过 `diff.days` 和 `diff.seconds` 实现 比如，大于10天 if diff . days > 10 : return dt . strftime ( '%Y-%m- %d %H:%M' ) 大于90秒,小于1小时 if diff . seconds <= 3600 and diff . seconds > 90 : periods = (( diff . seconds / 60 , \"minute\" , \"minutes\" ), ) 具体代码 def timesince ( dt , default = \"just now\" ): now = datetime . now () diff = now - dt if diff . days > 10 : return dt . strftime ( '%Y-%m- %d %H:%M' ) if diff . days <= 10 and diff . days > 0 : periods = (( diff . days , \"day\" , \"days\" ), ) if diff . days <= 0 and diff . seconds > 3600 : periods = (( diff . seconds / 3600 , \"hour\" , \"hours\" ), ) if diff . seconds <= 3600 and diff . seconds > 90 : periods = (( diff . seconds / 60 , \"minute\" , \"minutes\" ), ) if diff . seconds <= 90 : return default for period , singular , plural in periods : if period : return \" %d %s ago\" % ( period , singular if period == 1 else plural ) return default ok,之后就可以 app . jinja_env . filters [ 'timesince' ] = timesince 来实现几分钟前发表的功能了","tags":"Python","url":"https://honmaple.me/articles/2016/06/flask时间格式化.html","loc":"https://honmaple.me/articles/2016/06/flask时间格式化.html"},{"title":"linux下串口读写权限问题","text":"方法很简单，将用户加入串口所对应的group，需要 注意 的是不同的系统对应的group可能不同 按照网上说的加入 dialout , └──╼ sudo usermod -a -G dialout username 结果提示 /dialout\"组不存在/ 查看对应的组 └──╼ ls -al /dev/ttyUSB0 crw-rw---- 1 root uucp 188 , 0 6月 15 23 :09 /dev/ttyUSB0 └──╼ sudo usermod -a -G uucp username ok,之后重启一下","tags":"Linux","url":"https://honmaple.me/articles/2016/06/linux下串口读写权限问题.html","loc":"https://honmaple.me/articles/2016/06/linux下串口读写权限问题.html"},{"title":"linux下烧写文件到单片机","text":"python stcflash.py %s --lowbaud %d","tags":"Linux","url":"https://honmaple.me/articles/2016/06/linux下烧写文件到单片机.html","loc":"https://honmaple.me/articles/2016/06/linux下烧写文件到单片机.html"},{"title":"archlinux更换默认内核为linux-lts","text":"前几天更新内核到了 4.6.2 ，结果很不幸,电脑变得非常卡(貌似只有我遇到这个问题?), 实在是找不到解决办法了，于是将内核更改为 linux-lts 更改办法很简单，重装 linux-lts $ sudo pacman -S linux-lts 重启之前，请确认安装了 (注：我的是双显卡，还需要安装 bbswitch-lts )","tags":"Linux","url":"https://honmaple.me/articles/2016/06/archlinux更换默认内核为linux-lts.html","loc":"https://honmaple.me/articles/2016/06/archlinux更换默认内核为linux-lts.html"},{"title":"基于restful的flask权限管理","text":"为什么需要restful形式的权限管理 最近在写flask应用时使用了 restful 形式的 flask.views.MethodView ，但是在对其进行权限管理时遇到了一些问题 flask文档上介绍说用 decorators = [] 添加装饰器,但实际使用上,比如 get 和 post 采用不同的权限 get 不使用 login_required post 需要 login_required 这样就不能使用 decorators 对视图进行装饰 post , delete , put 都需要 login_required,但是 get 不需要 而 delete 又需要更高级别的权限,我们可以这样 class AAA ( MethodView ) : def get ( self , uid ) : ... @login_required def post ( self ) : ... @login_required def put ( self , uid ) : ... @login_required @more_required def delete ( self , uid ) : ... 是不是看起来还不错, 但是 ,如果再加上 类似EditBlogPostPermission 这样的权限管理呢? 是不是还需要这样 @login_required def put(self,uid): permission = EditBlogPostPermission(uid) if permission.can(): # Save the edits ... return render_template('edit_post.html') ... 先不论样式丑不丑，最重要的代码的 可维护性 极差,所以我增加了如下代码 怎么实现restful形式的权限管理 同样采用装饰器实现,调用 BasePermission 时会自动调用 call 函数 class BasePermission ( object ) : def __call__ ( self , func ) : @wraps ( func ) def decorator ( * args , ** kwargs ) : meth = getattr ( self , request . method . lower (), None ) if meth is None and request . method == 'HEAD' : meth = getattr ( self , 'get' , None ) assert meth is not None , 'Unimplemented method %r' % request . method check = meth ( * args , ** kwargs ) if check : return check else : pass return func ( * args , ** kwargs ) return decorator 举个例子,get方式不需要用户登陆,而其它方式需要,并且put方式需要创建主题的作者才能更改 class TopicPermission ( BasePermission ) : @login_required def post ( self ) : pass def get ( self , uid ) : pass @login_required def put ( self , uid ) : permission = EditTopicPermission ( uid ) if not permission . can () : flash ( '你没有权限' ) return redirect ( url_for ( 'topic.topic' , uid = uid )) @login_required def delete ( self , uid ) : pass topic_permission = TopicPermission () 假设四种方式都需要同一种权限,都需要用户登陆,总不能每个函数前都加上装饰器吧 所以稍加修改 decorators = () def __call__(self, func): if self.decorators: for dec in self.decorators: return dec(func) OK,这样就可以添加 decorators = [login_required] 来实现四种请求方式采用同一种权限 最后,你就可以在 AAA 这个类里添加 decorators = [topic_permission] 实现restful形式的权限管理 ok，就这样,可能还不完善或有一些问题，如有问题请联系我","tags":"Python","url":"https://honmaple.me/articles/2016/06/基于restful的flask权限管理.html","loc":"https://honmaple.me/articles/2016/06/基于restful的flask权限管理.html"},{"title":"i3wm在virtualbox中剪贴版激活","text":"参考这个回答 前几天装了虚拟机，但是虚拟机里无法与主机共享剪贴板(xfce4是可以的),于是搜索了一下， 找到了答案,原来是vbox的功能没有全部开启 进入i3,输入以下命令即可 $ VBoxClient-all ok,就这样","tags":"Linux","url":"https://honmaple.me/articles/2016/06/i3wm在virtualbox中剪贴版激活.html","loc":"https://honmaple.me/articles/2016/06/i3wm在virtualbox中剪贴版激活.html"},{"title":"培根密码","text":"第一种方式 A aaaaa B aaaab C aaaba D aaabb E aabaa F aabab G aabba H aabbb I abaaa J abaab K ababa L ababb M abbaa N abbab O abbba P abbbb Q baaaa R baaab S baaba T baabb U babaa V babab W babba X babbb Y bbaaa Z bbaab 第二种方式 a AAAAA g AABBA n ABBAA t BAABA b AAAAB h AABBB o ABBAB u-v BAABB c AAABA i-j ABAAA p ABBBA w BABAA d AAABB k ABAAB q ABBBB x BABAB e AABAA l ABABA r BAAAA y BABBA f AABAB m ABABB s BAAAB z BABBB","tags":"Security","url":"https://honmaple.me/articles/2016/05/培根密码.html","loc":"https://honmaple.me/articles/2016/05/培根密码.html"},{"title":"wireshark解决权限问题","text":"参考 以 sudo 或者 root 打开 wireshark 是不安全的,毕竟我不是root敢死队 如何以普通用户运行 wireshark 添加wireshark用户组 $ sudo groupadd wireshark 将dumpcap更改为wireshark用户组 $ sudo chgrp wireshark /usr/bin/dumpcap 让wireshark用户组有root权限使用dumpcap $ sudo chmod 4755 /usr/bin/dumpcap (注意:如果设为4754 Wireshark还是会提示没有权限 ) 将用户加入wireshark组 $ sudo gpasswd -a username wireshark 或者 $ sudo usermod -a -G wireshark username","tags":"Security","url":"https://honmaple.me/articles/2016/05/wireshark解决权限问题.html","loc":"https://honmaple.me/articles/2016/05/wireshark解决权限问题.html"},{"title":"flask日志处理","text":"使用文档上的一句话: Applications fail, servers fail. Sooner or later you will see an exception in production. Even if your code is 100% correct, you will still see exceptions from time to time. Why? Because everything else involved will fail. 应用发生错误时发送邮件 这里文档上个人认为说的不清不楚,毕竟想要使用还要看 logging的文档 原文档 ADMINS = [ 'yourname@example.com' ] if not app . debug : import logging from logging.handlers import SMTPHandler mail_handler = SMTPHandler ( '127.0.0.1' , 'server-error@example.com' , ADMINS , 'YourApplication Failed' ) mail_handler . setLevel ( logging . ERROR ) app . logger . addHandler ( mail_handler ) 实际上这里的好多参数没有交代清楚,具体可以看 https://docs.python.org/2/library/logging.handlers.html#smtp-handler 具体代码 import logging from logging.handlers import SMTPHandler from logging import Formatter config = app . config credentials = ( config [ 'MAIL_USERNAME' ], config [ 'MAIL_PASSWORD' ]) mail_handler = SMTPHandler ( secure = (), mailhost = ( config [ 'MAIL_SERVER' ], config [ 'MAIL_PORT' ]), fromaddr = '' , toaddrs = '' , subject = 'YourApplication Failed' , credentials = credentials ) mail_handler . setFormatter ( Formatter ( ''' Message type: %(levelname)s Location: %(pathname)s : %(lineno)d Module: %(module)s Function: %(funcName)s Time: %(asctime)s Message: %(message)s ''' )) mail_handler . setLevel ( logging . ERROR ) app . logger . addHandler ( mail_handler ) 其他方面不多说，这个多了一个 secure = () ，这是因为我的smtp服务需要使用TLS， 如果不加这行，会出现连接被拒绝的报错 smtplib.SMTPServerDisconnected: Connection unexpectedly closed 记录应用错误到文件 这个是google到的, 参考资料 具体代码 import logging from logging.handlers import RotatingFileHandler file_handler = RotatingFileHandler ( 'python.log' , maxBytes = 1024 * 1024 * 100 , backupCount = 20 ) file_handler . setLevel ( logging . ERROR ) formatter = logging . Formatter ( \" %(asctime)s - %(name)s - %(levelname)s - %(message)s \" ) file_handler . setFormatter ( formatter ) app . logger . addHandler ( file_handler )","tags":"Linux","url":"https://honmaple.me/articles/2016/05/flask日志处理.html","loc":"https://honmaple.me/articles/2016/05/flask日志处理.html"},{"title":"解决evil-escape下visual-state不能使用'jj'的问题","text":"在一个多月前我给 evil-escape 开发者提了一个issue,但是不幸的是，没人理我，人理我，理我，我····· 于是这一个多月来我使用visual-state下选择段落的方式是: 跳到段落最后,按k从下往上选择 , 现如今都快成为习惯了,今天终于有人解决了我的问题,非常感谢 ZzAntares 之前我用 (setq evil-escape-excluded-major-modes '(dired-mode neotree-mode evil-visual-state)) 解决了'jj'在 dired-mode neotree-mode 下的问题,但是遗憾的是 visual-state 下的选择问题仍然没有解决 现在终于解决了, issue (setq evil-escape-inhibit-functions '(evil-visual-state-p)) ok ,就这样","tags":"Linux","url":"https://honmaple.me/articles/2016/05/解决evil-escape下visual-state不能使用'jj'的问题.html","loc":"https://honmaple.me/articles/2016/05/解决evil-escape下visual-state不能使用'jj'的问题.html"},{"title":"flask中生成atom","text":"参考资料1 参考资料2 下面是具体代码 # from urlparse import urljoin #python2 from urllib.parse import urljoin from flask import request from werkzeug.contrib.atom import AtomFeed def make_external ( url ): return urljoin ( request . url_root , url ) @site.route ( '/atom.xml' ) def feed (): feed = AtomFeed ( 'Recent Articles' , feed_url = request . url , url = request . url_root , subtitle = 'I like solitude, yearning for freedom' ) articles = Articles . query . limit ( 15 ) . all () for article in articles : feed . add ( article . title , article . content , content_type = 'html' , author = article . author , url = make_external ( url_for ( 'blog.view' , id = article . id )), updated = article . publish , published = article . publish ) return feed . get_response ()","tags":"Linux","url":"https://honmaple.me/articles/2016/05/flask中生成atom.html","loc":"https://honmaple.me/articles/2016/05/flask中生成atom.html"},{"title":"ssh连接virtualbox中的虚拟机","text":"参考文档 虚拟机设置 从机设置 $ sudo pacman -S openssh $ sudo systemctl start sshd # 可能还需要一些其他的安全设置，这里不再多说 虚拟机设置 设置里，选择网络,端口转发，主机端口9022,从机端口22 连接虚拟机 主机 $ ssh - p 9022 username @127.0.0.1","tags":"Linux","url":"https://honmaple.me/articles/2016/05/ssh连接virtualbox中的虚拟机.html","loc":"https://honmaple.me/articles/2016/05/ssh连接virtualbox中的虚拟机.html"},{"title":"Linux下的一些使用","text":"$ dmesg $ cat /var/log/messag 查看启动日志 $ dmesg $ cat /var/log/messages","tags":"Linux","url":"https://honmaple.me/articles/2016/05/Linux下的一些使用.html","loc":"https://honmaple.me/articles/2016/05/Linux下的一些使用.html"},{"title":"emacs解决evil-visual下剪贴板问题","text":"参考问题 其实也就是加一行代码就行 (fset 'evil-visual-update-x-selection 'ignore) 注意 需要加载 evil 后增加 也就是 (require 'evil) (fset 'evil-visual-update-x-selection 'ignore)","tags":"Linux","url":"https://honmaple.me/articles/2016/04/emacs解决evil-visual下剪贴板问题.html","loc":"https://honmaple.me/articles/2016/04/emacs解决evil-visual下剪贴板问题.html"},{"title":"archlinux安装steam","text":"最近想要玩会儿游戏，但是又不想切换到windows,所以准备安装steam,在linux下玩游戏, 参考文档 Steam 准备工作 因为我的是64位操作系统,所以需要启用 multilib $ sudo vim /etc/pacman.conf # 取消下面注释 [ multilib ] Include = /etc/pacman.d/mirrorlist 双显卡bumblebee 我的又是双显卡,需要安装32位驱动 lib32-nvidia-utils lib32-mesa-libgl lib32-mesa 注意 除此之外，参考 bumblebee报错信息 还需要安装 virtualgl-libs:i386 ( arch上是lib32-virtualgl ) 否则报错 ERROR : ld . so : object 'libdlfaker.so' from LD_PRELOAD cannot be preloaded : ignored . 安装steam $ sudo pacman -Syu steam 打开steam 直接启动报错 $ steam /home/jianglin/.local/share/Steam/steam.sh:行161: VERSION_ID: 未绑定的变量 /home/jianglin/.local/share/Steam/steam.sh:行161: VERSION_ID: 未绑定的变量 Running Steam on arch 64 -bit /home/jianglin/.local/share/Steam/steam.sh:行161: VERSION_ID: 未绑定的变量 STEAM_RUNTIME is enabled automatically Installing breakpad exception handler for appid ( steam ) /version ( 1459463254 ) libGL error: unable to load driver: i965_dri.so libGL error: driver pointer missing libGL error: failed to load driver: i965 libGL error: unable to load driver: swrast_dri.so libGL error: failed to load driver: swrast .... 换个方式启动 $ optirun steam 虽然也有报错，但是总算能启动了 /home/jianglin/.local/share/Steam/steam.sh:行161: VERSION_ID: 未绑定的变量 /home/jianglin/.local/share/Steam/steam.sh:行161: VERSION_ID: 未绑定的变量 Running Steam on arch 64-bit /home/jianglin/.local/share/Steam/steam.sh:行161: VERSION_ID: 未绑定的变量 STEAM_RUNTIME is enabled automatically Installing breakpad exception handler for appid(steam)/version(1459463254) Installing breakpad exception handler for appid(steam)/version(1459463254) Installing breakpad exception handler for appid(steam)/version(1459463254) Fontconfig error: \"/etc/fonts/conf.d/10-scale-bitmap-fonts.conf\", line 72: non-double matrix element Fontconfig error: \"/etc/fonts/conf.d/10-scale-bitmap-fonts.conf\", line 72: non-double matrix element Fontconfig warning: \"/etc/fonts/conf.d/10-scale-bitmap-fonts.conf\", line 80: saw unknown, expected number [0425/180353:ERROR:main_delegate.cc(777)] Could not load cef_extensions.pak [0425/180353:ERROR:browser_main_loop.cc(203)] Running without the SUID sandbox! See https://code.google.com/p/chromium/wiki/LinuxSUIDSandboxDevelopment for more information on developing with the sandbox on. .... ok，就这样","tags":"Linux","url":"https://honmaple.me/articles/2016/04/archlinux安装steam.html","loc":"https://honmaple.me/articles/2016/04/archlinux安装steam.html"},{"title":"flask实现分页","text":"数据库实现分页 offset 使用offset可以实现数据库分页功能 questions = Questions.query.offset(num) # 从num开始 limit 使用limit实现限制每页的文章数量 questions = Questions.query.offset(num).limit(6) #每页显示6篇文章 前端实现分页 需求设计 是使用上一页，下一页，用表单进行跳转,还是使用数字显示 获得文章数量 pages ,和当前页码 number 简单的上一页，下一页 因为我的设计不是这个，所以简单说一下 下一页,上一页 jinja2 代码 <a href= \" {{ url_for ( 'blog.index' , number = number + 1 ) }} \" > 下一页 </a> <a href= \" {{ url_for ( 'blog.index' , number = number - 1 ) }} \" > 下一页 </a> 首页没有上一页，尾页没有下一页 {% if number == pages %} no next page {% else %} <a href= \" {{ url_for ( 'blog.index' , number = number + 1 ) }} \" > 下一页 </a> {% endif %} {% if number == 1 %} no previous page {% else %} <a href= \" {{ url_for ( 'blog.index' , number = number - 1 ) }} \" > 上一页 </a> {% endif %} 显示各个页码的分页 搞了一下午,终于搞定了 设计 总页码小于7,显示所有页码,总页码大于7，显示当前页码以及当前页码前两页和后两页. 当页码大于7时,当前页码小于4,显示1~6页的页码····· 使用 {{ import 'base/page.html' as page }} number为当前页码 , pages为总共的页码 {{ page . page ( 'blog.index' , number = number , pages = pages )}} 如果 url_for需要加参数 ，使用 {{ page . page ( 'blog.index' , number = number , pages = pages , kw = dict ( tag = tag ))}} 源码 给出源码 { % macro page(url,number=1,pages=1,kw=None) -%} <div style= \"text-align:center;margin-top:-15px\" > < ul class= \"pagination\" > { %- if number == 1 %} < li class= \"disabled\" > < a aria - label= \"Previous\" > < span aria - hidden= \"true\" >&laquo ; </span > </a > </li > { %- else -%} < li > { % if not kw %} < a href= \"{{ url_for(url,number=number-1) }}\" aria - label= \"Previous\" > < span aria - hidden= \"true\" >&laquo ; </span > </a > { % else %} < a href= \"{{ url_for(url,number=number-1,**kw) }}\" aria - label= \"Previous\" > < span aria - hidden= \"true\" >&laquo ; </span > </a > { % endif -%} </li > { % endif -%} { % if pages < 7 %} { % for page in range(1,pages + 1) %} {{ page_url ( url , page , number , kw ) }} { % endfor %} { % else %} { % if number <= 4 %} { % for page in range(1,6) %} {{ page_url ( url , page , number , kw ) }} { % endfor %} { %- if number <= pages - 2 %} < li class= \"disabled\" ><a>···</a></li > { %- endif -%} {{ page_url ( url , pages , number , kw ) }} { % else %} {{ page_url ( url , 1 , number , kw ) }} {{ page_url ( url , 2 , number , kw ) }} {{ page_dot_start ( number )}} { % if number >= pages - 3 %} { % for page in range(number-2,pages + 1) %} {{ page_url ( url , page , number , kw ) }} { % endfor %} { % else %} { % for page in range(number-2,number + 3) %} {{ page_url ( url , page , number , kw ) }} { % endfor %} {{ page_dot_end ( pages , number ) }} {{ page_url ( url , pages , number , kw ) }} { % endif %} { % endif %} { % endif %} { %- if number == pages %} < li class= \"disabled\" > < a aria - label= \"Next\" > < span aria - hidden= \"true\" >&raquo ; </span > </a > </li > { %- else -%} < li > { % if not kw %} < a href= \"{{ url_for(url,number=number+1) }}\" aria - label= \"Next\" > < span aria - hidden= \"true\" >&raquo ; </span > </a > { % else %} < a href= \"{{ url_for(url,number=number+1,**kw) }}\" aria - label= \"Next\" > < span aria - hidden= \"true\" >&raquo ; </span > </a > { % endif -%} </li > { % endif -%} </ul > </ div> { % endmacro %} { % macro page_url(url,page,number,kw) -%} { %- if page == number %} < li class= \"active\" > {{ page_kw ( url , page , kw )}} </li > { %- else -%} < li> {{ page_kw ( url , page , kw )}} </li > { %- endif -%} { % endmacro %} { % macro page_dot_end(pages,number) -%} { %- if number <= pages - 4 %} < li class= \"disabled\" ><a>···</a></li > { %- endif -%} { % endmacro %} { % macro page_dot_start(number) -%} { %- if number > 5 %} < li class= \"disabled\" ><a>···</a></li > { %- endif -%} { % endmacro %} { % macro page_kw(url,page,kw) -%} { % if not kw %} < a href= \"{{ url_for(url,number=page) }}\" > {{ page }} </a > { % else %} < a href= \"{{ url_for(url,number=page,**kw) }}\" > {{ page }} </a > { %- endif -%} { % endmacro %}","tags":"Linux","url":"https://honmaple.me/articles/2016/04/flask实现分页.html","loc":"https://honmaple.me/articles/2016/04/flask实现分页.html"},{"title":"sqlalchemy学习(一)","text":"sqlalchemy 系统的学一下sqlalchemyA,不过没有中文文档,只能用我的渣英文能力慢慢看原文档了 数据库连接 >>> from sqlalchemy import create_engine >>> engine = create_engine ( 'sqlite:///:memory:' , echo = True ) echo为True输出日志 各种数据库连接方式 dialect+driver://username:password@host:port/database Postgresql # default engine = create_engine('postgresql://scott:tiger@localhost/mydatabase') # psycopg2 engine = create_engine('postgresql+psycopg2://scott:tiger@localhost/mydatabase') # pg8000 engine = create_engine('postgresql+pg8000://scott:tiger@localhost/mydatabase') MySQL # default engine = create_engine('mysql://scott:tiger@localhost/foo') # mysql-python engine = create_engine('mysql+mysqldb://scott:tiger@localhost/foo') # MySQL-connector-python engine = create_engine('mysql+mysqlconnector://scott:tiger@localhost/foo') # OurSQL engine = create_engine('mysql+oursql://scott:tiger@localhost/foo') Oracle engine = create_engine ( ' oracle : //scott:tiger@127.0.0.1:1521/sidname') engine = create_engine ( ' oracle + cx_oracle : //scott:tiger@tnsname') SQLite # sqlite://<nohostname>/<path> # where <path> is relative: engine = create_engine('sqlite:///foo.db') #Unix/Mac - 4 initial slashes in total engine = create_engine('sqlite:////absolute/path/to/foo.db') #Windows engine = create_engine('sqlite:///C:\\\\path\\\\to\\\\foo.db') #Windows alternative using raw string engine = create_engine(r'sqlite:///C:\\path\\to\\foo.db') # To use a SQLite :memory: database, specify an empty URL: engine = create_engine('sqlite://') 声明样式 from sqlalchemy.ext.declarative import declarative_base from sqlalchemy import Column , Integer , String Base = declarative_base () class User ( Base ): __tablename__ = 'users' id = Column ( Integer , primary_key = True ) name = Column ( String ) fullname = Column ( String ) password = Column ( String ) def __repr__ ( self ): return \"<User(name=' %s ', fullname=' %s ', password=' %s ')>\" % ( self . name , self . fullname , self . password ) 样式参数说明 说明 **\\_ tablename \\_\\_** 表名 字段类型及说明 字段类型及文档 Generic Types 字段类型 说明 BigInteger 大数 Boolean(create constraint =True, name=None, _create events =True) 布尔 Data DateTime(timezone=False) 时间 Enum(*enums, **kw) 枚举 Float(precision=None, asdecimal=False, decimal return scale =None, **kwargs) 浮点型 Integer 整型 Interval(native=True, second precision =None, day precision =None) 时间间隔 LargeBinary(length=None) 二进制大对象 MatchType(create constraint =True, name=None, _create events =True) Numeric(precision=None, scale=None, decimal return scale =None, asdecimal=True) PickleType(protocol=2, pickler=None, comparator=None) SchemaType(name=None, schema=None, metadata=None, inherit schema =False, quote=None, _create events =True) SmallInteger 小整型 String(length=None, collation=None, convert unicode =False, unicode error =None, _warn on bytestring =False) 字符串 Text(length=None, collation=None, convert unicode =False, unicode error =None, _warn on bytestring =False) 文本对象 Time(timezone=False) 时间 Unicode(length=None, **kwargs) UnicodeText(length=None, **kwargs) SQL Standard Types 字段类型 说明 BIGINT BINARY(length=None) BLOB(length=None) BOOLEAN(create constraint =True, name=None, _create events =True) CHAR(length=None, collation=None, convert unicode =False, unicode error =None, _warn on bytestring =False) CLOB(length=None, collation=None, convert unicode =False, unicode error =None, _warn on bytestring =False) DATE DATETIME(timezone=False) DECIMAL(precision=None, scale=None, decimal return scale =None, asdecimal=True) FLOAT(precision=None, asdecimal=False, decimal return scale =None, **kwargs) INT INTEGER NCHAR(length=None, **kwargs) NVARCHAR(length=None, **kwargs) NUMERIC(precision=None, scale=None, decimal return scale =None, asdecimal=True) REAL(precision=None, asdecimal=False, decimal return scale =None, **kwargs) SMALLINT TEXT(length=None, collation=None, convert unicode =False, unicode error =None, _warn on bytestring =False TIME(timezone=False) TIMESTAMP(timezone=False) VARBINARY(length=None) VARCHAR(length=None, collation=None, convert unicode =False, unicode error =None, _warn on bytestring =False) 创建表 Base.metadata.create_all(engine) 为表创建实例 >>> ed_user = User(name='ed', fullname='Ed Jones', password='edspassword') >>> ed_user.name 'ed' >>> ed_user.password 'edspassword' >>> str(ed_user.id) 'None' 创建session >>> from sqlalchemy.orm import sessionmaker >>> Session = sessionmaker ( bind = engine ) 你也可以先创建Session,在创建应用前 >>> Session = sessionmaker() 当你创建了应用,可以这样配置 >>> Session.configure(bind=engine) # once engine is available 插入和更新数据 插入 插入一条数据 >>> ed_user = User(name='ed', fullname='Ed Jones', password='edspassword') >>> session.add(ed_user) 插入多条数据 >>> session.add_all([ ... User(name='wendy', fullname='Wendy Williams', password='foobar'), ... User(name='mary', fullname='Mary Contrary', password='xxg527'), ... User(name='fred', fullname='Fred Flinstone', password='blah')]) 更新 >>> ed_user.password = 'f8s7ccs' 查看 >>> session.dirty IdentitySet([<User(name='ed', fullname='Ed Jones', password='f8s7ccs')>]) >>> session.new # doctest: +SKIP IdentitySet([<User(name='wendy', fullname='Wendy Williams', password='foobar')>, <User(name='mary', fullname='Mary Contrary', password='xxg527')>, <User(name='fred', fullname='Fred Flinstone', password='blah')>]) 必须提交才能生效 >>> session.commit()","tags":"Python","url":"https://honmaple.me/articles/2016/04/sqlalchemy学习(一).html","loc":"https://honmaple.me/articles/2016/04/sqlalchemy学习(一).html"},{"title":"archlinux的一些设置","text":"最近在整理文件时发现了以前记下的一些设置，但是单独记在一个文件里不好找，也占用空间，现在记在博客里 vesa error fcitx输入法 sudo pacman -S fcitx-im fcitx-configtool fcitx-sunpinyin 使用 增加内容到~/.xinitrc export LANG=zh_CN.UTF-8 export XMODIFIERS=@im=fcitx export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx exec startxfce4 终端汉字显示 sudo pacman -S fbterm fcitx-fbterm vim ~/fbtermrc 输入内容input-method=fcitx-fbterm 使用 终端输入fbterm 输入忽略大小写 vim ~/.inputrc 增加内容 set completion-ignore-case on virtualbox sudo pacman -S virtualbox 手动加载模块 modprobe vboxdrv 启动时加载模块 /etc/modules-load.d/virtualbox.conf vboxdrv 添加用户到vboxusers组 gpsswd -a $USER vboxusers 开机启动rc.local vim /usr/lib/systemd/system/rc-local.service 增加内容 >[Unit] Description=\"/etc/rc.local Compatibility\" ConditionFileIsExecutable=/etc/rc.local [Service] Type=forking ExecStart=/etc/rc.local start TimeoutSec=0 StandardInput=tty RemainAfterExit=yes SysVStartPriority=99 [Install] WantedBy=multi-user.target 常用的一些软件 ack","tags":"Linux","url":"https://honmaple.me/articles/2016/04/archlinux的一些设置.html","loc":"https://honmaple.me/articles/2016/04/archlinux的一些设置.html"},{"title":"python一些加密解密","text":"import hashlib import base64 data = '123456' data = data . encode ( 'utf-8' ) md5 = hashlib . md5 () md5 . update ( data ) print ( \"md5加密 : %s \" % md5 . hexdigest ()) sha1 = hashlib . sha1 () sha1 . update ( data ) print ( \"sha1加密: %s \" % sha1 . hexdigest ()) sha224 = hashlib . sha224 () sha224 . update ( data ) print ( \"sha224加密: %s \" % sha224 . hexdigest ()) sha256 = hashlib . sha256 () sha256 . update ( data ) print ( \"sha256加密: %s \" % sha256 . hexdigest ()) sha384 = hashlib . sha384 () sha384 . update ( data ) print ( \"sha384加密: %s \" % sha384 . hexdigest ()) sha512 = hashlib . sha512 () sha512 . update ( data ) print ( \"sha512加密: %s \" % sha512 . hexdigest ()) new = hashlib . new ( 'ripemd160' ) new . update ( data ) print ( \"new加密: %s \" % new . hexdigest ()) b = base64 . encodestring ( data ) c = base64 . decodestring ( b ) print ( \"base64加密: %s \" % b ) print ( \"base64解密: %s \" % c )","tags":"python","url":"https://honmaple.me/articles/2016/04/python一些加密解密.html","loc":"https://honmaple.me/articles/2016/04/python一些加密解密.html"},{"title":"flask解决f5刷新问题","text":"问题来源 def index(): if form.validate_on_submit() and request.method == \"POST\": # do something else: # 这里使用**redirect**重定向而不是render_template","tags":"python","url":"https://honmaple.me/articles/2016/04/flask解决f5刷新问题.html","loc":"https://honmaple.me/articles/2016/04/flask解决f5刷新问题.html"},{"title":"python时间转换","text":">>> import datetime string转datetime >>> import datetime >>> str = \"2016-04-03\" >>> date_time = datetime . datetime . strptime ( str , '%Y-%m- %d ' ) >>> date_time datetime . datetime ( 2016 , 4 , 3 , 0 , 0 ) datetime转string >>> date_time.strftime('%Y-%m-%d') '2016-04-03' datetime转时间戳 >>> time_time = time.mktime(date_time.timetuple()) >>> time_time 1459612800.0 时间戳转string >>> time.strftime('%Y-%m-%d',time.localtime(time_time)) '2016-04-03'","tags":"python","url":"https://honmaple.me/articles/2016/04/python时间转换.html","loc":"https://honmaple.me/articles/2016/04/python时间转换.html"},{"title":"母羊生羊问题解决","text":"问题是这样的: 1只母羊，在第2年和第4年生下小母羊,在第5年死去,问N年后有多少母羊? 想了很久，终于有了一个思路，不过目前效率不高 给出代码: a = [1] def sheep(N): N = int(N) if N == 1: return a for n,k in enumerate(a): a[n] += 1 for n,k in enumerate(a): if k == 2: a.append(1) if k == 4: a.append(1) return sheep(N-1) while True: b = sheep(input('请输入年份:\\n')) c = [i for i in b if i < 5] print('母羊总数: %d'%len(c)) a = [1]","tags":"python","url":"https://honmaple.me/articles/2016/03/母羊生羊问题解决.html","loc":"https://honmaple.me/articles/2016/03/母羊生羊问题解决.html"},{"title":"python复习(二)","text":"map map()函数接收两个参数，一个是函数，一个是Iterable， map将传入的函数依次作用到序列的每个元素， 并把结果作为新的Iterator返回。 >>> def f(x): ... return x * x ... >>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) >>> list(r) [1, 4, 9, 16, 25, 36, 49, 64, 81] 或者 >>> list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9])) ['1', '2', '3', '4', '5', '6', '7', '8', '9'] reduce reduce把一个函数作用在一个序列[x1, x2, x3, ...]上， 这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算 >>> from functools import reduce >>> def add ( x , y ): ... return x + y ... >>> reduce ( add , [ 1 , 3 , 5 , 7 , 9 ]) 25 filter filter()把传入的函数依次作用于每个元素， 然后根据返回值是True还是False决定保留还是丢弃该元素。 例如，在一个list中，删掉偶数，只保留奇数，可以这么写： def is_odd(n): return n % 2 == 1 list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15])) # 结果: [1, 5, 9, 15] sorted sorted()可以对list进行排序 key 接收 key 实现自定义排序 >>> sorted([36, 5, -12, 9, -21], key=abs) [5, 9, -12, -21, 36] 对 字符串排序 ，是按照 ASCII 的大小比较的 排序忽略大小写 >>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower) ['about', 'bob', 'Credit', 'Zoo'] reverse reverse = True 反向排序 >>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True) ['Zoo', 'Credit', 'bob', 'about'] 返回函数 返回闭包时牢记的一点就是：返回函数不要引用任何循环变量， 或者后续会发生变化的变量。 匿名函数lambda 可以把匿名函数赋值给一个变量，再利用变量来调用该函数： >>> f = lambda x: x * x >>> f <function <lambda> at 0x101c6ef28> >>> f(5) 25 把匿名函数作为返回值返回: def build(x, y): return lambda: x * x + y * y","tags":"python","url":"https://honmaple.me/articles/2016/03/python复习(二).html","loc":"https://honmaple.me/articles/2016/03/python复习(二).html"},{"title":"flask-sqlalchemy使用","text":"简单的例子 这里 已经有了 中文 这里记录一下平时我遇到的一些问题 一对多 需求:一个问题对应多个回复 下面给出代码(字段不完整) class Questions ( db . Model ) : __tablename__ = 'questions' id = db . Column ( db . Integer , primary_key = True ) title = db . Column ( db . String ( 50 ), nullable = False ) content = db . Column ( db . Text , nullable = False ) def __init__ ( self , title , content ) : self . title = title self . content = content def __repr__ ( self ) : return \"<Questions %r>\" % self . title class Replies ( db . Model ) : __tablename__ = 'replies' id = db . Column ( db . Integer , primary_key = True ) content = db . Column ( db . Text , nullable = False ) question_id = db . Column ( db . Integer , db . ForeignKey ( 'questions.id' , ondelete = \"CASCADE\" )) replies = db . relationship ( 'Questions' , backref = db . backref ( 'replies' , cascade = 'all,delete-orphan' , lazy = 'dynamic' , order_by = 'Replies.time' ) ) def __init__ ( self , content ) : self . content = content def __repr__ ( self ) : return \"<Replies %r>\" % self . content 会发现这样的两行(虽然实际上有好几行) question_id = db.Column(db.Integer, db.ForeignKey('questions.id', ondelete=\"CASCADE\")) replies = db.relationship('Questions', backref=db.backref('replies', cascade='all,delete-orphan', lazy='dynamic', order_by='Replies.time') ) question_id为外键,关联着questions这个数据表 replies这一行我习惯用反代,也就是backref=db.backref 调用 question = Questions.query.filter_by(id=1).first() print(question.replies) # 输出该问题的回复 print(question.replies.content) # 错误 for reply in question.replies: print(reply.content) # 正确 reply = Replies.query.filter_by(id=1).first() print(reply.question_id) # 输出该回复的所属问题 print(reply.question_id.title) 级联删除 也就是删除一个问题，也会将该问题下的所有回复删除,而删除问题下的回复将不会影响到具体问题 具体请google sqlalchemy cascade 经过测试,上面代码可级联删除回复,而不是将外键置空","tags":"python","url":"https://honmaple.me/articles/2016/03/flask-sqlalchemy使用.html","loc":"https://honmaple.me/articles/2016/03/flask-sqlalchemy使用.html"},{"title":"python复习(一)","text":"· 参考 循环 ranger(100)表示0到99这一百个数 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。 把list、dict、str等Iterable变成Iterator可以使用iter()函数 不可变对象 >>> a = 'abc' >>> a.replace('a', 'A') 'Abc' >>> a 'abc' 列表(list) # 向列表追加元素 a = ['hello','h','a','b'] a.append('world') # 删除列表最后一个元素 a.pop() 切片 # 从a[0]开始到a[2] a[0:3] # 或者,省略0 a[:3] # 省略-1 a[-2:] # 每两个取一个 a[::2] 迭代 判断是否可迭代 isinstance(x, Iterable) 下标循环 >>> for i, value in enumerate(['A', 'B', 'C']): ... print(i, value) ... 0 A 1 B 2 C 列表生成式 >>> [x * x for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] # 或者 >>> [x * x for x in range(1, 11) if x % 2 == 0] [4, 16, 36, 64, 100] # 使用两层循环，生成全排列 >>> [m + n for m in 'ABC' for n in 'XYZ'] ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] 元组(tuple) # 只有一个元素时 a = ('hello',) # 而不是 a = ('hello') 字典(dict) key不存在 如果key不存在,dict会报错 >>> a['hello'] Traceback (most recent call last): File \" \", line 1, in KeyError: 'hello' 可以用 get 方式避免报错,如果key不存在，返回None,或者自己指定的value >>> a.get('hello') >>> a.get('hello', -1) -1 删除key a.pop('hello') set key不会重复 a = set([1,2,3]) # 添加key到set a.add(4) # 删除key从set a.add(4) set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作： >>> s1 = set([1, 2, 3]) >>> s2 = set([2, 3, 4]) >>> s1 & s2 {2, 3} >>> s1 | s2 {1, 2, 3, 4} 迭代key和value for k,v in a.items(): print(k,v) 数据类型转化及内置函数 # 转换函数 int float str bool # 数据类型检查 isinstance(x, (int, float)) generator 生成一个generator >>> g = (x * x for x in range(2)) >>> g <generator object <genexpr> at 0x1022ef630> 输出generator >>> next(g) 0 >>> next(g) 1 >>> next(g) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> StopIteration 或者使用for yield 可将函数输出转化为generator 函数 函数没有return，默认return None,简写为return 返回多个数 return 'hello','world' 其实质是一个tuple 可变参数 def calc(numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 调用是需要使用list或tuple, calc([1,2,3]) 或 calc((1,2,3)) 使用可变参数 def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 调用时就可以 calc(1,2,3) 也可以将list或tuple传入 >>> nums = [1, 2, 3] >>> calc(*nums) 14 关键字参数 def person(name, age, **kw): print('name:', name, 'age:', age, 'other:', kw) 调用时可以只传入 name 和 age ,或者传入任意个数的关键字参数 >>> person('Michael', 30) name: Michael age: 30 other: {} >>> person('Adam', 45, gender='M', job='Engineer') name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'} 也可这样调用 >>> extra = {'city': 'Beijing', 'job': 'Engineer'} >>> person('Jack', 24, **extra) 命名关键字参数 如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下： def person(name, age, *, city, job): print(name, age, city, job) 参数组合 参数定义的顺序必须是：必选参数、默认参数、可变参数/命名关键字参数和关键字参数 尾递归","tags":"python","url":"https://honmaple.me/articles/2016/03/python复习(一).html","loc":"https://honmaple.me/articles/2016/03/python复习(一).html"},{"title":"使用fabric进行自动化部署","text":"fabric也使用好久了，这次静下心来好好整理一遍，当然这只是很简单的用法 参考文档 安装 凡事先从安装说起,fabric不支持python3,所以只能安装python2版本的fabric 由于我使用了virtualenv，所以先退出虚拟环境 $ deactivate 安装全局fabric $ sudo pip2 install fabric 使用 使用之前先想想以前是怎么部署的，是不是这样: 先ssh到服务器,进行数据备份,然后退出(或者重新开一个终端),然后上传文件到服务器, 再ssh到服务器,安装所需要的模块,然后退出，ssh到root账户，重启，再退出··· 是不是想想都烦 没关系，有了fabric后就不必这么麻烦了,需求: 备份数据 # fabfile.py from fabric.api import run , env , cd , local , put , get def backup (): env . user = 'root' dirname = 'backup_' + datetime . now () . strftime ( '%Y%m %d ' ) with cd ( '/root/backup/' ): run ( './backup-db.sh' ) run ( 'tar zcvf %s .tar.gz %s /' % ( dirname , dirname )) print '正在下载备份······' get ( '/root/backup/ %s .tar.gz' % dirname , 'backup/' ) 使用 fab backup 就可以一步备份 代码打包上传 def pack (): '''这是我需要打包的文件''' local ( 'pip freeze > requirements.txt' ) local ( 'tar zcvf hohai.tar.gz manager.py requirements.txt app/ migrations/ \\ --exclude=\"*.pyc\" \\ --exclude=\"*.swp\" \\ --exclude=\"**/__pycache__\" \\ --exclude=\"**/.webassets-cache\"' ) def putcode (): env.user = '账户名称' print '正在上传代码······' put ( 'hohai.tar.gz' , '~/hhuc/' ) local ( 'rm hohai.tar.gz' ) print '正在备份数据······' run ( 'cp -r ~/hhuc/app/ ~/backup/hhuc/' ) with cd ( '~/hhuc/' ): run ( 'rm -rf app/' ) run ( 'tar zxvf hohai.tar.gz' ) run ( 'rm hohai.tar.gz' ) 使用 fab pack putcode 一步打包上传 重启服务器 def restart(): \"\"\"重启服务器\"\"\" env.user = 'root' run('supervisorctl restart hhuc') 一键部署 def deploy (): env.user = 'honmaple' print '正在上传代码······' put ( 'hohai.tar.gz' , '~/hhuc/' ) local ( 'rm hohai.tar.gz' ) print '正在备份数据······' run ( 'cp -r ~/hhuc/app/ ~/backup/hhuc/' ) with cd ( '~/hhuc/' ): run ( 'rm -rf app/' ) run ( 'tar zxvf hohai.tar.gz' ) run ( 'rm hohai.tar.gz' ) restart () print '部署成功······' 使用 fab pack deploy 就可部署 ok,就这样","tags":"linux","url":"https://honmaple.me/articles/2016/03/使用fabric进行自动化部署.html","loc":"https://honmaple.me/articles/2016/03/使用fabric进行自动化部署.html"},{"title":"关于sqlalchemy的desc","text":"也就是降序排序 简单使用 questions = Questions.query.order_by(Questions.time.desc()).all() 设置默认排序 如果几乎所有的questions都是按照时间降序排序,总不能每一条语句都加上 order_by(Questions.time.desc()) 所以设置默认排序是有效的 class Questions ( db . Model ) : __tablename__ = 'questions' id = db . Column ( db . Integer , primary_key = True ) title = db . Column ( db . String ( 50 ), nullable = False ) content = db . Column ( db . Text , nullable = False ) time = db . Column ( db . DateTime , nullable = False ) __mapper_args__ = { \"order_by\" : time . desc () } 如代码所示,使用 __mapper_args__ 就可， __mapper_args__ 可以做很多事,具体看 这里 设置默认排序下面的做法是 错误 的 __mapper_args__ = { \"order_by\": 'Questions.time.desc()' } # 或者 __mapper_args__ = { \"order_by\": 'Questions.time desc' } # 或者 __mapper_args__ = { \"order_by\": 'desc(Questions.time)' } 多对多默认排序 比如这样 question = Questions.query.filter_by(id=1).first() for reply in question.replies: print(reply.content) 又如何设置回复是按照回复时间排序的 总不能这样 for reply in sorted(question.replies): # 这会报错的 TypeError: unorderable types: Replies() < Replies() 怎么设置 replies = db.relationship('Questions', backref=db.backref('replies', lazy='dynamic', order_by='Replies.time') ok，暂时这样","tags":"python","url":"https://honmaple.me/articles/2016/03/关于sqlalchemy的desc.html","loc":"https://honmaple.me/articles/2016/03/关于sqlalchemy的desc.html"},{"title":"关于sqlalchemy的filter_by与filter","text":"都可看做是where但用法不一样 filter_by question = Questions.query.filter_by(id=1).first() filter question = Questions.query.filter(Questions.id==1).first() 其实就是 = 与 == 还有是否带类名的区别 如果要 select * from questions where id < 5 这时只能使用 filter questions = Questions.query.filter(Questions.id < 5).all() 多个条件 question = Questions.query.filter_by(name='hello',id=5).first() # 或者 question = Questions.query.filter(Questions.name=='hello',Questions.id==5).first()","tags":"python","url":"https://honmaple.me/articles/2016/03/关于sqlalchemy的filter_by与filter.html","loc":"https://honmaple.me/articles/2016/03/关于sqlalchemy的filter_by与filter.html"},{"title":"记录Flask-Login的例子","text":"书签不够用了 例子1: https://gist.github.com/bkdinoop/6698956","tags":"python","url":"https://honmaple.me/articles/2016/02/记录Flask-Login的例子.html","loc":"https://honmaple.me/articles/2016/02/记录Flask-Login的例子.html"},{"title":"自定义jinja2转义标签","text":"参考问题 参考资料 最终代码: def safe_clean ( text ): from flask import Markup from bleach import clean tags = [ 'b' , 'i' , 'font' , 'br' ] attrs = { '*' :[ 'style' ], 'font' :[ 'color' ] } styles = [ 'color' ] return Markup ( clean ( text , tags = tags , attributes = attrs , styles = styles )) 自定义filter过滤器","tags":"python","url":"https://honmaple.me/articles/2016/02/自定义jinja2转义标签.html","loc":"https://honmaple.me/articles/2016/02/自定义jinja2转义标签.html"},{"title":"arch更新遇到的问题","text":"：confuse: signature from \"Thorsten Töpper atsutane@freethoughts.de \" is unknown trust 解决: $ sudo pacman-key --refresh-keys arch错误：无法准备事务处理 (无法满足依赖关系) :: package-query: 要求 pacman<4.3 解决: $ sudo pacman -R package-query yaourt 更新python2-pip出现问题 $ sudo pacman -Syu 错误：无法提交处理 ( 有冲突的文件 ) python2-pip: 文件系统中已存在 /usr/lib/python2.7/site-packages/pip/_vendor/requests/packages/urllib3/contrib/socks.py python2-pip: 文件系统中已存在 /usr/lib/python2.7/site-packages/pip/_vendor/requests/packages/urllib3/contrib/socks.pyc 发生错误，没有软件包被更新。 解决: $ sudo mv /usr/lib/python2.7/site-packages/pip/_vendor/requests/packages/urllib3/contrib/socks.py ~/ $ sudo mv /usr/lib/python2.7/site-packages/pip/_vendor/requests/packages/urllib3/contrib/socks.py~ ~/ $ sudo pacman -Syu # 我也不清楚为什么会发生这个问题，只能这样解决了 $ sudo cp ~/sock.py /usr/lib/python2.7/site-packages/pip/_vendor/requests/packages/urllib3/contrib/ $ sudo cp ~/sock.py~ /usr/lib/python2.7/site-packages/pip/_vendor/requests/packages/urllib3/contrib/","tags":"Linux","url":"https://honmaple.me/articles/2016/02/arch更新遇到的问题.html","loc":"https://honmaple.me/articles/2016/02/arch更新遇到的问题.html"},{"title":"flask使用ajax","text":"简单使用ajax 参考文档 <script type= text/javascript > $(document).ready(function(){ $('button#ajax').click(function() { $.ajax ({ type : \"POST\", url : \" {{ url_for ( 'index.login' ) }} \", data:JSON.stringify({ name: $('input[name=\"name\"]').val(), passwd: $('input[name=\"passwd\"]').val() }), contentType: 'application/json;charset=UTF-8', success: function(result) { if (result.judge == true) { window.location = '/'; } else { $(\"#showerror\").show(); $(\"#error\").text(result.error); } } }); }); }); </script> ajax使用CSRF 参考文档 首先注册CSRF from flask_wtf.csrf import CsrfProtect csrf = CsrfProtect () csrf . init_app ( app ) 在模板中使用 var csrftoken = \" {{ csrf_token () }} \" $.ajaxSetup({ beforeSend: function(xhr, settings) { if (!/&#94;(GET|HEAD|OPTIONS|TRACE)$/i.test(settings.type) && !this.crossDomain) { xhr.setRequestHeader(\"X-CSRFToken\", csrftoken) } } });","tags":"python","url":"https://honmaple.me/articles/2016/02/flask使用ajax.html","loc":"https://honmaple.me/articles/2016/02/flask使用ajax.html"},{"title":"使用jquery实现markdown预览","text":"虽然算不上是实时预览 实时预览功能等有时间在把它加上 还是把实时预览加上，不过实时预览可能会对网站有所影响，读者看着加上 前端 < script type = \"text/javascript\" > function previewTopicContent (){ $ . getJSON ( \"{{ url_for('blog.preview') }}\" , { content : $ ( \"#content\" ). val (), }, function ( data ) { $ ( \"#showPreview\" ). html ( data . result ); }); /*setTimeout('previewTopicContent()',300);*/ }; < /script> 或者 function previewTopicContent (){ $ . get ( \"{{ url_for('blog.preview') }}\" , { content : $ ( \"#content\" ). val (), }, function ( data ) { $ ( \"#showPreview\" ). html ( data ); }); }; 服务端 @site.route ( '/pages/preview' ) def preview (): from misaka import Markdown , HtmlRenderer from flask import jsonify content = request . args . get ( 'content' ) html = HtmlRenderer () markdown = Markdown ( html ) return jsonify ( result = Markup ( markdown ( content ))) 或者 def preview (): from misaka import Markdown , HtmlRenderer content = request . args . get ( 'content' ) html = HtmlRenderer () markdown = Markdown ( html ) return Markup ( markdown ( content ))","tags":"linux","url":"https://honmaple.me/articles/2016/02/使用jquery实现markdown预览.html","loc":"https://honmaple.me/articles/2016/02/使用jquery实现markdown预览.html"},{"title":"关于flask-wtf中的validators","text":"以前都是\"吃快餐\",利用别人的例子进行修改，弄得自己不明不白的，这次放假，静下心来好好的看看官方文档， 才发现写的代码有很多不必要的东西，可以进行很多优化 flask-wtforms是一个优秀的flask扩展，可惜官方文档说的不明不白，只是简单的说了大概的 功能,如果想要更好的利用这个扩展，请google wtforms,或者 看这里 这里记录一下wtforms的 validators 参考文档 class RegisterForm ( Form ) : name = StringField ( '用户名:' ) email = StringField ( '邮箱:' ) passwd = PasswordField ( '密码:' ) repasswd = PasswordField ( '重复密码:' ) register = SubmitField ( '注册' ) 这只是一个最简单注册表单 慢慢地加上一些要求: 输入不能为空 from wtforms.validators import Required name = StringField ( '用户名:' , [ Required ()]) 限制name长度 from wtforms.validators import Length name = StringField ( '用户名:' , [ Length ( min = 4 , max = 20 )]) 判断邮箱格式是否正确 from wtforms.validators import Email email = StringField ( '邮箱' , [ Email ()]) 比较两次密码是否一致 from wtforms.validators import Email passwd = PasswordField ( '密码:' , [ EqualTo ( 'repasswd' )]) repasswd = PasswordField ( '重复密码:' ) 自定义错误信息 默认错误信息可以通过 form = RegisterForm() print(form.errors) //或者print(form.name.errors) 查看 比如输入不能为空的默认错误信息 'This field is required.' 想要修改默认信息,请使用 message 比如: name = StringField('用户名:', [Required(message=u'输入不能为空')]) 同样的 Length(min=4, max=25, message=u'用户名长度在4到25个字符之间') Email(message=u'错误的邮箱地址') EqualTo('confirm',message=u'两次密码不一致') 这样就不用在视图文件不停地判断了,不要像我原先那样 if form.name.data == '' or form.passwd.data == '': flash(u'输入不能为空') if form.repasswd.data != form.passwd.data: flash(u'两次密码不一致') ok,就这样,这里写的不完善，不过对于我来说暂时够用了","tags":"python","url":"https://honmaple.me/articles/2016/02/关于flask-wtf中的validators.html","loc":"https://honmaple.me/articles/2016/02/关于flask-wtf中的validators.html"},{"title":"redis记录用户操作","text":"必须得记下来，否则等那天看到又要浪费时间了,主要记录访问时间这里 '''记录访问的时间''' now_time = int(time()) #首先得到当前时间戳 '''查询上次访问的时间和最近访问的时间''' query_last_time = redis_data.zscore(visited_users,'last_time') query_now_time = redis_data.zscore(visited_users,'time') '''判断查询是否为空,一般是第一次访问还未记录的IP''' if query_last_time is None: query_last_time = now_time pipe.zadd(visited_users,query_last_time,'last_time') if query_now_time is None: query_now_time = now_time '''将当前时间与last_time进行对比,十分钟之内不记录''' if now_time - query_last_time >= 600: '''这里类似交换更新数据,把query_now_time变成last_time,把now_time更新''' pipe.zadd(visited_users,query_now_time,'last_time') pipe.zadd(visited_users,now_time,'time') else: pipe.zadd(visited_users,now_time,'time')","tags":"linux","url":"https://honmaple.me/articles/2016/01/redis记录用户操作.html","loc":"https://honmaple.me/articles/2016/01/redis记录用户操作.html"},{"title":"flask应用部署——安装环境","text":"虽然以前安装过但是没有记录，这次重新安装，趁机记录下来，省得满世界地找 环境: centos7 安装nginx 参考资料 使用 yum list nginx 会发现nginx是1.6的版本,但现在nginx已经到了1.9，虽然不必那么新， 但是过旧的版本说不定会出现安全问题 # vim /etc/yum.repos.d/nginx.repo 输入 [nginx] name = nginx repo baseurl = http://nginx.org/packages/centos/$releasever/$basearch/ gpgcheck = 0 enabled = 1 然后 # yum list nginx #你会发现nginx已经是1.8的版本 # yum install nginx # systemctl start nginx #启动nginx 安装python3 centos7默认安装了python2.7的版本，但我习惯用python3,但是centos无法通过yum install python3安装, 只好自己编译了 安装必要的文件 # yum groupinstall \"Development tools\" # yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel 下载python3源码 python3已到的python3.5，请按自己的需求下载 $ wget https://www.python.org/ftp/python/3.4.4/Python-3.4.4.tgz $ tar xz Python-3.4.4.tgz $ cd Python-3.4.4 $ ./configure $ make # make install 如果提示c 编译器未找到 yum install gcc gcc-c++ 安装supervisor 编译安装python3的时候python3-pip就已经安装好了 # pip3 install supervisor Collecting supervisor Downloading supervisor-3.2.0.tar.gz (409kB) 100% |################################| 413kB 972kB/s Complete output from command python setup.py egg_info: Supervisor requires Python 2.4 or later but does not work on any version of Python 3. You are using version 3.4.4 (default, Jan 6 2016, 11:01:55) [GCC 4.8.3 20140911 (Red Hat 4.8.3-9)]. Please install using a supported version. ---------------------------------------- Command \"python setup.py egg_info\" failed with error code 1 in /tmp/pip-build-qp0f7ft9/supervisor 报错，错误提示很明显, supervisor 不支持python3 安装python2的pip # yum install python-pip # yum install python-devel #最好把这个也装上，以后会用到的 # pip install supervisor # 这里又有一个提示 You are using pip version 7.1.0, however version 7.1.2 is available. You should consider upgrading via the 'pip install --upgrade pip' command. # pip install --upgrade pip 安装python的虚拟环境virtualenv # pip3 install virtualenv $ mkdir www $ cd www $ virtualenv-3.4 venv Using base prefix '/usr/local' New python executable in venv/bin/python3.4 Also creating executable in venv/bin/python Installing setuptools, pip, wheel...done. 建议在~/.bashrc中添加 alias ve='. venv/bin/activate' 以后只要使用 ve 就能进入虚拟环境 关于数据库的安装请参考我的另一篇文章 postgresql学习1——安装","tags":"linux","url":"https://honmaple.me/articles/2016/01/flask应用部署——安装环境.html","loc":"https://honmaple.me/articles/2016/01/flask应用部署——安装环境.html"},{"title":"supervisor使用","text":"supervisor安装请参考 flask应用部署——安装环境 生成配置文件 # cd /etc # mkdir -p supervisord/conf.d # echo_supervisord_conf > /etc/supervisord/supervisord.conf 修改supervisord.conf # vim supervisord.conf # G直接跳到最后一行 取消下面注释并修改 [include] files = /etc/supervisord/conf.d/*.ini ok，现在可以在/etc/supervisord/conf.d/目录下创建配置文件了 # vim honmaple.com.ini 输入以下内容 # 进程的名字 [program:website] # 命令 command=/home/www/honmaple.com/venv/bin/gunicorn run:app -c /home/www/honmaple.com/gunicorn.conf # 网站目录 directory=/home/www/honmaple.com # 进程所属用户 user=www # 自动重启设置。 autostart=true autorestart=true # 日志存放位置。 stdout_logfile=/home/www/honmaple.com/logs/gunicorn_supervisor.log 上面有几处需要注意的地方 创建新用户www # useradd www # passwd www #设置密码 # su - www $ cd $ mkdir -p honmaple.com/logs 建立虚拟环境(honmaple.com/目录下) $ virtualenv-3.4 venv $ . venv/bin/activate gunicorn配置 # gunicorn.conf workers = 4 bind = '127.0.0.1:8000' 简单的web应用 #run.py from flask import Flask app = Flask ( __name__ ) @app.route ( '/' ) def hello_world (): return 'Hello World!' if __name__ == '__main__' : app . run () 加载supervisor配置 # supervisord -c /etc/supervisord/supervisord.conf # supervisorctl -c /etc/supervisord/supervisord.conf reload supervisor遇到的问题 提示 Error : Another program is already listening on a port that one of our HTTP servers is configured to use . Shut this program down first before starting supervisord . For help , use /usr/bin/s upervisord - h ... fail ! 解决办法 # unlink /tmp/supervisor.sock 提示 error: <class 'socket.error'>, [Errno 111] Connection refused: file: /usr/lib64/python2.6/socket.py line: 567 解决办法 # supervisord -c /etc/supervisord/supervisord.conf # supervisorctl -c /etc/supervisord/supervisord.conf reload 提示 ERROR (no such process),请仔细查看配置文件是否有误","tags":"linux","url":"https://honmaple.me/articles/2016/01/supervisor使用.html","loc":"https://honmaple.me/articles/2016/01/supervisor使用.html"},{"title":"使用python的Pillow模块生成验证码","text":"参考资料 准备 from PIL import Image , ImageDraw , ImageFont , ImageFilter _letter_cases = \"abcdefghjkmnpqrstuvwxy\" # 去除可能干扰的i，l，o，z _upper_cases = _letter_cases . upper () # 大写字母 _numbers = '' . join ( map ( str , range ( 3 , 10 ))) # 数字 init_chars = '' . join (( _letter_cases , _upper_cases , _numbers )) fontType = \"/usr/share/fonts/TTF/DejaVuSans.ttf\" 1.创建图像 def create_validate_code(self,size=(120, 30), chars=init_chars, img_type=\"PNG\", mode=\"RGB\", bg_color=(255, 255, 255), fg_color=(0, 0, 255), font_size=18, font_type=fontType, length=4, draw_lines=True, n_line=(1, 2), draw_points=True, point_chance = 2): width, height = size # 图像的宽，高 img = Image.new(mode, size, bg_color) # 创建新图像 img.save(\"validate.png\", \"PNG\") # 存储图片 if __name__ == '__main__': create_validate_code() 2.绘制干扰线 在创建新图像后添加 if draw_lines: self.create_lines(draw,n_line,width,height) # 绘制干扰线 干扰线函数 def create_lines(self,draw,n_line,width,height): line_num = random.randint(n_line[0],n_line[1]) # 干扰线条数 for i in range(line_num): # 起始点 begin = (random.randint(0, width), random.randint(0, height)) #结束点 end = (random.randint(0, width), random.randint(0, height)) draw.line([begin, end], fill=(0, 0, 0)) 3.绘制干扰点 在绘制干扰线后添加 if draw_points: self.create_points(draw,point_chance,width,height) #绘制干扰点 干扰点函数 def create_points(self,draw,point_chance,width,height): chance = min(100, max(0, int(point_chance))) # 大小限制在[0, 100] for w in range(width): for h in range(height): tmp = random.randint(0, 100) if tmp > 100 - chance: draw.point((w, h), fill=(0, 0, 0)) 4.生成验证码 在绘制干扰点之后添加 strs = self.create_strs(draw,chars,length,font_type, font_size,width,height,fg_color) 验证码函数 def create_strs(self,draw,chars,length,font_type, font_size,width,height,fg_color): c_chars = random.sample(chars, length) strs = ' %s ' % ' '.join(c_chars) # 每个字符前后以空格隔开 font = ImageFont.truetype(font_type, font_size) font_width, font_height = font.getsize(strs) draw.text(((width - font_width) / 3, (height - font_height) / 3),strs,\\ font=font, fill=fg_color) ok，简单的验证码就生成好了","tags":"python","url":"https://honmaple.me/articles/2015/12/使用python的Pillow模块生成验证码.html","loc":"https://honmaple.me/articles/2015/12/使用python的Pillow模块生成验证码.html"},{"title":"如何备份postgresql数据库","text":"对于网站来说数据无疑是最重要的，而养成备份数据的习惯更加重要， 忽然想到一句经典台词 曾经有一份数据摆在我的面前， 可我没有备份， 直到数据丢失后才后悔莫及, 人世间最痛苦的事莫过于此， 如果上天能给我一次再来一次的机会， 我会对那份数据说五个字：我要备份你， 如果非要在这份备份上加一个期限，我希望是每天！ 进入主题,这只是对数据进行简单的备份 怎么备份数据 shell脚本 1 2 3 4 5 6 #!/bin/bash backup_time = ` date +%Y%m%d ` pg_dump articledb > /home/xxx/backup/article_ $backup_time .sql # articledb是要备份的数据库名称 echo \"backup finished\" 保存为backup_db.sh 注意 xxx是数据库用户,并且是super权限 可以这样 $ sudo -i -u postgres $ [ sudo ] xxx 的密码: postgres~ $ createuser xxx --interactive # 创建数据库用户,我的是archlinux,不同系统可能有所不同 定时备份数据 crontab -e 输入 0 22 * * * /home/xxx/backup/backup_db.sh #表示每天22点定时备份数据 如果你需要在其他时间段备份数据，请查阅crontab文档 ok，就这样","tags":"linux","url":"https://honmaple.me/articles/2015/12/如何备份postgresql数据库.html","loc":"https://honmaple.me/articles/2015/12/如何备份postgresql数据库.html"},{"title":"为网站启用https并增加ssl证书","text":"HTTPS和HTTP的区别 超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号、密码等。 为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 HTTPS和HTTP的区别主要为以下四点: https协议需要到ca申请证书，一般免费证书很少，需要交费。 http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 申请ssl证书 对于像我这样的穷学生或者不希望花钱的同学可以使用 startssl免费ssl证书 当然如果可以，最好购买ssl证书,安全性上更有保障 对于怎么申请startssl免费证书这里不多说，网上很多教程，其中有几点是我在申请中遇到的问题，希望对大家有所帮助 * 在进行域名验证时不论如何startssl 搜索不到我的域名注册邮箱 ,我已将whois保护关闭后还是一样 解决办法 ：一个不是办法的办法，因为我在qq邮箱使用了域名邮箱,所以我将域名邮箱管理员admin@honmaple.com 更改为postmaster@honmaple.com,然后发送验证邮件到该邮箱对域名进行验证 如何导出公钥 如果申请成功，在Tool Box点击Certificate List,Action中选择Retrieve导出zip包到本地, 在本地解压就会发现里面有对应服务器类型的crt证书 如何导出私钥 在申请过程中保存了一个.key文件，这个文件就可以作为私钥(请妥善保管) 如果在申请中对私钥设置了密码,每次重启ngnix都要输入密码,如果不想每次输入密码, 在startssl的Tool Box的Decrypt Private Key中填入保存的私钥以及私钥密码,对私钥进行解密, 将解密后的字符串保存为.key文件 关于nginx配置 在/etc/nginx/conf.d/ssl.conf中添加 server { listen 443 ssl ; server_name honmaple.com ; #请更改成你的文件地址 ssl_certificate /root/ssl/1_honmaple.com.pem ; ssl_certificate_key /root/ssl/1_honmaple.com.key ; ssl_session_cache shared : SSL : 1 m ; ssl_session_timeout 5m ; #下面这些请根据实际更改,我的是flask+nginx location / { # Pass the request to Gunicorn proxy_pass http : // 127.0.0.1 : 8000 ; proxy_redirect off ; # Set some HTTP headers so that our app knows where the # request really came from proxy_set_header Host $host ; proxy_set_header X-Real-IP $remote_addr ; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for ; } } 注意: 我不知道是我的原因还是其他,启动ngnix时总报错 SSL_CTX_use_PrivateKey_file(\"/root/ssl/1_honmaple.com.key\") failed (SSL: error:0D07207B:asn1 encoding routines:ASN1_get_object: header too long error:0D068066:asn1 encoding routines:ASN1_CHECK_TLEN:bad object header error:0D07803A:asn1 encoding routines:ASN1_ITEM_EX_D2I:nested asn1 error: Type=PKCS8_PRIV_KEY_INFO error:2306A065:PKCS12 routines:PKCS12_item_decrypt_d2i: decode error error:0907B00D:PEM routines:PEM_READ_BIO_PRIVATEKEY:ASN1 lib error: 140B0009:SSL routines:SSL_CTX_use_PrivateKey_file:PEM lib) 所以我将.crt文件改成.pem,后面我发现还是报错，我将公钥里的 -----END CERTIFICATE----- -----BEGIN CERTIFICATE----- 之间的空行去除 如果还是报错，请将.key文件解密 其他配置 如果要全站启用https,并将http定向到https,可以这样 server { listen 80 ; server_name honmaple.com ; rewrite &#94;/(.*) https : // honmaple . com / $ 1 permanent ; } 记得更改成自己的域名 ok,就这样","tags":"Security","url":"https://honmaple.me/articles/2015/12/为网站启用https并增加ssl证书.html","loc":"https://honmaple.me/articles/2015/12/为网站启用https并增加ssl证书.html"},{"title":"I Have Not Loved the World","text":"I have not loved the world, nor the world me; I have not flatter'd its rank breath, nor bow'd To its idolatries a patient knee, -- Nor coin'd my cheek to smiles, -- nor cried aloud In worship of an echo; in the crowd They could not deem me one of such; I stood Among them, but not of them; in a shroud Of thoughts which were not their thoughts, and still could, Had I not filed my mind, which thus itself subdued. I have not loved the world, nor the world me, -- But let us part fair foes; I do believe, Though I have found them not, that there may be Words which are things, -- hopes which will not deceive, And virtues which are merciful, nor weave Snares for the failing: I would also deem O'er others' griefs that some sincerely grieve; That two, or one, are almost what they seem, -- That goodness is no name, and happiness no dream. --George · Gordon · Byron 我从未爱过这世界， 它对我也一样； 我没有阿谀过它腐臭的气息， 也不曾忍从地屈膝， 膜拜它的各种偶像； 我没有在脸上堆着笑， 更没有高声叫嚷着， 崇拜一种回音； 纷纭的世人不能把我看作他们一伙； 我站在人群中却不属于他们； 也没有把头脑放进 那并非而又算作他们的思想的尸衣中， 一齐列队行进， 因此才被压抑而至温顺。 我没有爱过这世界， 它对我也一样; 但是，尽管彼此敌视， 让我们方方便便分手吧； 虽然我自己不曾看到， 在这世上我相信或许会有不骗人的希望， 真实的语言， 也许还有些美德， 它们的确怀有仁心， 并不给失败的人安排陷阱； 我还这样想： 当人们伤心的时候， 有些人真的在伤心， 有那么一两个，几乎就是所表现的那样—— 我还认为： 善不只是空话，幸福并不只是梦想 ——拜伦《I Have Not Loved the World》","tags":"Life","url":"https://honmaple.me/articles/2015/12/I Have Not Loved the World.html","loc":"https://honmaple.me/articles/2015/12/I Have Not Loved the World.html"},{"title":"centos搭建shadowsocks服务端","text":"1.安装必要组建 # yum inst 刚搭建好，记录下来，用的是centos 1.安装必要组建 # yum install build-essential autoconf libtool openssl-devel gcc -y 2.安装git # yum install git -y # git --version #安装完后查看版本 3.下载shadowsocks-libev源码包并且编译安装 $ git clone https://github.com/madeye/shadowsocks-libev.git $ cd shadowsocks-libev $ ./configure # make && make install .配置shadowsocks # nohup /usr/local/bin/ss-server -s IP地址 -p 端口 -k 密码 -m 加密方式 & 注： ip地址为当前服务器ip，端口随意，加密方式建议为aes-256-cfb 5.加入开机启动 # echo \"nohup /usr/local/bin/ss-server -s IP地址 -p 端口 -k 密码 -m 加密方式 &\" >> /etc/rc.local 6.加入防火墙 # vim /etc/sysconfig/iptables 增加 -A INPUT -m state --state NEW -m tcp -p tcp --dport 端口 -j ACCEPT 重启防火墙 # service iptables restart 7.客户端配置 下载地址 注：如果 http://sourceforge.net/ 进不去可以 http://sourceforge.jp 客户端中两个端口，一个是服务端（自己设的端口) ，另一个本地端口（默认1080），配置完成启用系统代理，并且选PAC模式 ok，就这样","tags":"linux","url":"https://honmaple.me/articles/2015/12/centos搭建shadowsocks服务端.html","loc":"https://honmaple.me/articles/2015/12/centos搭建shadowsocks服务端.html"},{"title":"flask学习--jinja模板","text":"janja2是flask的默认模板,使用模板能够很大程度的将前端与后端分离 下面内容主要参考 jinja介绍 Jinja是flask的默认模板引擎。 jinja设置 在扩展名为 .html 、 .htm 、 .xml 和 .xhtml 的模板中开启自动 转义。 在模板中可以使用 {% autoescape %} 来手动设置是否转义。 Flask 在 Jinja2 环境中加入一些全局函数和辅助对象，以增强模板的功能。","tags":"python","url":"https://honmaple.me/articles/2015/12/flask学习--jinja模板.html","loc":"https://honmaple.me/articles/2015/12/flask学习--jinja模板.html"},{"title":"flask学习——数据库操作","text":"flask 作为后端数据库操作是必要的，现在记录一下一些flask数据库的相关操作， 我将使用三种方法操作数据库 暂时使用较简单的sqlite作为例子 相关环境的安装 建议使用ve虚拟环境 sudo pacman -S sqlite # archlinux sudo pip install virtualenv # 在vertualenv环境下执行 pip install Flask-SQLAlchemy Jinja2 SQLAlchemy 最好是多看文档 1.使用sqlite3模块API 参考资料 这是最简单的方法,不仅适用于flask,python的其他方面也一样适用,如爬虫之类 连接数据库 1 2 3 4 5 6 7 #!/usr/bin/env python # -*- coding=UTF-8 -*- import sqlite3 database = / path / test . db #数据库文件路径 test = sqlite . connect ( 'database' ) #连接数据库，如果数据库文件不存在则创建 print ( 'connect database successfully' ) test . close () #关闭数据库连接 如果将数据库名改为 :memory: ,则在内存中打开数据库而不是磁盘 创建表 database = /path/test.db test = sqlite.connect('database') test.execute('''CREATE TABLE BOOKS (ID INT PRIMARY KEY NOT NULL, TYPE TEXT NOT NULL, NAME TEXT NOT NULL, CONTENT TEXT);''') print(\"Table created successfully\") test.close() 插入数据 database = /path/test.db test = sqlite.connect('database') test.execute(\"INSERT INTO BOOKS (ID,TYPE,NAME,CONTENT) \\ VALUES (1, 'hello', 'world', 'helloworld')\"); test.execute(\"INSERT INTO BOOKS (ID,TYPE,NAME,CONTENT) \\ VALUES (2, 'goodbye', 'world', 'goodbyeworld')\"); test.commit() #要使数据保存，必须提交 print(\"Records commited successfully\") test.close() 查询数据 database = /path/test.db test = sqlite.connect('database') cursor = test.execute(\"SELECT ID,TYPE,NAME,CONTENT from BOOKS\") for row in cursor: print(\"ID =%d \"%(row[0])) print(\"TYPE =%s \"%(row[1])) print(\"NAME =%s \"%(row[2])) print(\"CONTENT =%s \"%(row[3])) test.close() 更新数据 database = /path/test.db test = sqlite.connect('database') test.execute(\"UPDATE BOOKS SET CONTENT = 'hello' WHERE ID=2\") test.commit test.close() 删除数据 database = /path/test.db test = sqlite.connect('database') test.execute(\"DELETE FROM BOOKS WHERE ID=2\") test.commit test.close() 由于数据库文件我已经在外部使用第一种方法创建,所以第二种方法我直接打开 2.使用文档上所说的方法 参考资料 英文 中文 import sqlite3 from flask import g DATABASE = '/path/to/database.db' def connect_db (): return sqlite3 . connect ( DATABASE ) @app.before_request #使用app_request装饰器打开数据库 def before_request (): g . db = connect_db () @app.teardown_request #使用app_request装饰器关闭数据库 def teardown_request ( exception ): if hasattr ( g , 'db' ): g . db . close () def query_db ( query , args = (), one = False ): #数据库简化查询 cur = g . db . execute ( query , args ) rv = [ dict (( cur . description [ idx ][ 0 ], value ) for idx , value in enumerate ( row )) for row in cur . fetchall ()] return ( rv [ 0 ] if rv else None ) if one else rv 需要使用时(主要是查询) for book in query_db('select * from BOOKS'): print book['NAME'], 'has the id', book['ID'] #由于flask一般不使用print，可以这样 book = query_db('select * from BOOKS') 在模板中 {{ book.ID }} 或着 {{ book [ 'ID' ] }} 如果只希望得到一个单独的结果 book = query_db('select * from BOOKS where NAME = ?', [the_bookname], one=True) if book is None: print 'No such user' else: print the_bookname, 'has the id', book['ID'] 创建，更新，插入，删除数据请使用第一个方法 初始化数据库模型 from contextlib import closing def init_db (): with closing ( connect_db ()) as db : with app . open_resource ( 'schema.sql' ) as f : db . cursor () . executescript ( f . read ()) db . commit () 3.使用Flask-SQLAlchemy扩展 (这应该是最推荐的方法) 参考文档 中文 英文 一个最小应用 from flask import Flask from flask.ext.sqlalchemy import SQLAlchemy app = Flask ( __name__ ) app . config [ 'SQLALCHEMY_DATABASE_URI' ] = 'sqlite:////tmp/test.db' # sqlite打开的格式是sql:///三个\"/\",接着是数据库文件的**绝对路径** db = SQLAlchemy ( app ) class User ( db . Model ): id = db . Column ( db . Integer , primary_key = True ) username = db . Column ( db . String ( 80 ), unique = True ) email = db . Column ( db . String ( 120 ), unique = True ) def __init__ ( self , username , email ): self . username = username self . email = email def __repr__ ( self ): return '<User %r >' % self . username 使用 假若上面代码保存为test.py 打开python shell >>> from test import db , User >>> db . create_all () #创建表 >>> admin = User ( 'admin' , 'admin@example.com' ) #创建数据 # 这时数据还未真正写入数据库,需要提交 >>> db . session . add ( admin ) >>> db . session . commit () #这时数据已经写入数据库中 # 简单数据查询 >>> users = User . query . all () >>> print ( users ) [ < User u 'admin' > ] >>> admin = User . query . filter_by ( username = 'admin' ) . first () >>> print ( admin ) < User u 'admin' > 如果想要简单的查看数据,推荐firefox的一个sqlite插件 sqlite manager 配置 SQLALCHEMY_DATABASE_URI #用于连接的数据库 SQLALCHEMY_BINDS #连接多个数据库 # 比如 SQLALCHEMY_BINDS = { 'users' : 'mysqldb://localhost/users' , 'appmeta' : 'sqlite:////path/to/appmeta.db' } # 创建删除表 >>> db . create_all ( bind = [ 'users' ]) >>> db . create_all ( bind = 'appmeta' ) # 引用绑定 , 使用 __bind_key__ class User ( db . Model ) : __bind_key__ = 'users' id = db . Column ( db . Integer , primary_key = True ) username = db . Column ( db . String ( 80 ), unique = True ) 选择，插入，删除 插入 >>> from test import User >>> me = User ( 'admin' , 'admin@example.com' ) >>> db . session . add ( me ) >>> db . session . commit () 删除 >>> db.session.delete(me) >>> db.session.commit() 查询 首先插入如下数据 id username email 1 admin admin@example.com 2 peter peter@example.org 3 guest guest@example.com 通过用户名查询用户: >>> admin = User.query.filter_by(username='admin').first() >>> print(admin.id) 1 >>> print(admin.email) u'admin@example.com' 查找不存在的用户名: >>> missing = User.query.filter_by(username='missing').first() >>> missing is None True 使用更复杂的表达式查询一些用户: >>> User.query.filter(User.email.endswith('@example.com')).all() [<User u'admin'>, <User u'guest'>] 按某种规则对用户排序: >>> User.query.order_by(User.username) [<User u'admin'>, <User u'guest'>, <User u'peter'>] 限制返回用户的数量: >>> User.query.limit(1).all() [<User u'admin'>] 用主键查询用户: >>> User.query.get(1) <User u'admin'> 在视图中使用 使用 get_or_404() 来代替 get()，使用 first_or_404() 来代替 first()。 这样会抛出一个 404 错误，而不是返回 None: @app.route('/user/<username>') def show_user(username): user = User.query.filter_by(username=username).first_or_404() return render_template('show_user.html', user=user) 主要就是这样，最好看完整的文档 具体例子可以查看 GitHub","tags":"python","url":"https://honmaple.me/articles/2015/12/flask学习——数据库操作.html","loc":"https://honmaple.me/articles/2015/12/flask学习——数据库操作.html"},{"title":"flask学习笔记--1","text":"基本知识 python html/css javascript http等 flask安装 Flask 依赖两个外部库： Werkzeug 和 Jinja2 。 Werkzeug 是一个 WSGI 套件。 WSGI 是 Web 应用与 多种服务器之间的标准 Python 接口，即用于开发，也用于部署。 Jinja2 是用于渲染 模板的。 virtualenv 关于virtualenv 安装 virtualenv $ sudo pip install virtualenv 安装完virtualenv后创建自己的文件夹 $ mkdir flask $ cd flask $ virtualenv venv New python executable in env/bin/python Installing setuptools............done. 以后要使用virtualenv只用输入 $ . venv/bin/activate #不要忘记了\".\" 你会发现在终端PS1前会出现(venv),代表你已经进入virtualenv虚拟环境 退出virtualenv $ deactivate 在virtualenv中安装flask $pip install flask 另外,你也可以使用 $ sudo pip install flask 安装flask到你的电脑中 flask使用 安装完后就可以使用了 注意项目结构 推荐使用 |-app/ |-|views.py |-|models.py |-| init .py |-|templates/ |-|static/ |-config.py |-run.py |-tmp/ 创建第一个应用过过隐 暂时可以不用进行项目结构编排 $vim hello.py 输入 from flask import Flask #导入Flask类 app = Flask ( __name__ ) #__name__模块名，必须的 @app.route ( '/' ) #使用 route() 装饰器来告诉 Flask 触发函数的 URL def hello_world (): return 'Hello World!' if __name__ == '__main__' : app . run () #使用 run() 函数来运行本地服务器和应用 运行后出现 * Running on http://127.0.0.1:5000/ 打开浏览器输入网址 http://127.0.0.1:5000/ 打开调试模式 app.debug = True app.run() 或者是 app.run(debug=True) 注意 调试模式仅限在本地使用，在生产环境中不要打开","tags":"python","url":"https://honmaple.me/articles/2015/12/flask学习笔记--1.html","loc":"https://honmaple.me/articles/2015/12/flask学习笔记--1.html"},{"title":"flask学习笔记--2","text":"今天被flask的项目结构或者说是蓝图搞得晕头转脑，各种文档也没说清，从github搜索并clone了几个用flask做成的网站，无奈水平太低，看不懂 记录一下今天学到的 蓝图 |-app/ |-| init .py |-|views.py |-| init .py |-|templates/ |-|static/ |-config.py |-run.py |-tmp/ run.py 输入 python run.py 就可以运行程序 from app import app #从app包中调用app模块 app . run () #运行程序 config.py 一些基本的配置 DEBUG = True #打开调试模式 app/ init .py from flask import Flask , request , session , g , redirect , url_for , \\ abort , render_template , flash app = Flask ( __name__ ) app . config . from_object ( \"config\" ) #调用config.py配置文件 from app import views #从app包中导入views模块 app/views.py 视图文件 from app import app from flask import Flask , request , session , g , redirect , url_for , \\ abort , render_template , flash @app.route. ( '/' ) def Index (): return 'hello,world' @app.route ( / index ) def Show_page (): return render_template ( 'index.html' ) app/templates/ 放置模板 app/templates/index.html <!DOCTYPE html> < html > < head > < meta charset = \"utf-8\" > < meta name = \"viewport\" content = \"width=device-width\" > < link rel = stylesheet type = text/css href = \" {{ url_for ( 'static' , filename = 'style.css' ) }} \" > #使用static文件夹中的css，js < title > hello </ title > </ head > < body > < ul > < li > hello </ li > < li > world </ li > < li > hello world </ li > </ ul > </ body > </ html > app/static 放置一些静态文件 css,js等","tags":"python","url":"https://honmaple.me/articles/2015/12/flask学习笔记--2.html","loc":"https://honmaple.me/articles/2015/12/flask学习笔记--2.html"},{"title":"flask学习笔记——3","text":"好久没有写东西的，主要是最近在用flask写一个网站，由于写前端界面时为了让UI好看一点，搞得自己晕头转向，方向都错了,在此期间也遇到很多问题，虽然绝大部分已经解决了，但是还有很多没有解决。其实，做一个项目是最能检验能力的。 中文网站链接编码 如果访问一个含中文字符的网站，很大可能会提示错误 import urllib urllib . parse . quote ( url )","tags":"python","url":"https://honmaple.me/articles/2015/12/flask学习笔记——3.html","loc":"https://honmaple.me/articles/2015/12/flask学习笔记——3.html"},{"title":"postgresql学习1——安装","text":"最近从sqlite转到postgresql,虽然postgresql比sqlite更加复杂 archlinux 参考资料 $ sudo pacman -S postgresql $ sudo mkdir /var/lib/postgres/data #如果已存在则可以不建立 $ sudo chmod -R postgres:postgres /var/lib/postgres/data 由于我安装系统时没有生成en_US_UTF-8本地化文件 ( 如果已经生成了的就 不必再生成 ) $ sudo vim /etc/locale.gen #找到en_US_UTF-8，注释掉 $ locale-gen 然后运行 $ sudo -i -u postgres #或者使用root账户su - postgres $ initdb --locale en_US.UTF-8 -E UTF8 -D '/var/lib/postgres/data' $ createuser -i #输入你的账户名称,并给管理员权限 最好给postgres用户设置密码 ( 注意不是linux系统帐号 ) # su - postgres $ psql >ALTER USER postgres WITH PASSWORD 'yourpasswd' ; centos 参考资料 到 这里 下载所需要的rpm安装包 或者直接 # yum localinstall http://yum.postgresql.org/9.4/redhat/rhel-6-x86_64/pgdg-centos94-9.4-1.noarch.rpm # yum list postgres* # yum install postgresql94-server # yum install postgresql94-contrib # service postgresql initdb #初始化数据库 # service postgresql start #启动数据库 # chkconfig postgresql on #将数据库服务加入启动列表 修改PostgreSQL 数据库用户postgres的密码 (注意不是linux系统帐号) # su - postgres $ psql >ALTER USER postgres WITH PASSWORD 'yourpasswd';","tags":"linux","url":"https://honmaple.me/articles/2015/12/postgresql学习1——安装.html","loc":"https://honmaple.me/articles/2015/12/postgresql学习1——安装.html"},{"title":"postgresql学习2——使用","text":"postgresql的简单使用 python 参考资料 安装psycopg2 推荐使用venv虚拟环境 pip install psycopg2 这个API打开一个连接到PostgreSQL数据库。如果成功打开数据库时，它返回一个连接对象 psycopg2.connect(database=\"testdb\", user=\"postgres\", password=\"cohondob\", host=\"127.0.0.1\", port=\"5432\") 该程序创建一个光标将用于整个数据库使用Python编程。 connection.cursor() 此例程执行SQL语句。可被参数化的SQL语句（即占位符，而不是SQL文字）。 psycopg2的模块支持占位符用％s标志 cursor.execute(sql [, optional parameters]) 该程序执行SQL命令对所有参数序列或序列中的sql映射 curosr.executemany(sql, seq_of_parameters) 这个程序执行的存储数据库程序给定的名称。该程序预计为每一个参数，参数的顺序必须包含一个条目。 curosr.callproc(procname[, parameters]) 这个只读属性，它返回数据库中的行的总数已修改，插入或删除最后 execute*(). cursor.rowcount 此方法提交当前事务。如果不调用这个方法，无论做了什么修改，自从上次调用commit()是不可见的，从其他的数据库连接。 connection.commit() 此方法会回滚任何更改数据库自上次调用commit（）方法 connection.rollback() 此方法关闭数据库连接。请注意，这并不自动调用commit（）。如果你只是关闭数据库连接而不调用commit（）方法首先，那么所有更改将会丢失！ connection.close() 这种方法提取的查询结果集的下一行，返回一个序列，或者无当没有更多的数据是可用的。 cursor.fetchone() 这个例程中取出下一个组的查询结果的行数，返回一个列表。当没有找到记录，返回空列表。该方法试图获取尽可能多的行所显示的大小参数。 cursor.fetchmany([size=cursor.arraysize]) 这个例程获取所有查询结果（剩余）行，返回一个列表。空行时则返回空列表 cursor.fetchall() 可以看出,psycopg2的操作与sqlite类似除了连接数据库","tags":"linux","url":"https://honmaple.me/articles/2015/12/postgresql学习2——使用.html","loc":"https://honmaple.me/articles/2015/12/postgresql学习2——使用.html"},{"title":"vim操作及配置","text":"vim号称编辑器之神，最近也一直使用vim写代码，最大的印象就是快，无论是临时修改文件，还是专门写代码.现在记录vim主要操作快捷键和我的vim配置 vim操作 一、移动光标 左移h、右移l、下移j、上移k 向下翻页ctrl + f，向上翻页ctrl + b 向下翻半页ctrl + d，向上翻半页ctrl + u 移动到行尾$，移动到行首0（数字），移动到行首第一个字符处&#94; 移动光标到下一个句子 ），移动光标到上一个句子（ 移动到段首{，移动到段尾} 移动到下一个词w，移动到上一个词b 移动到文档开始gg，移动到文档结束G 移动到匹配的{}.().[]处% 跳到第n行 ngg 或 nG 或 :n 移动光标到屏幕顶端H，移动到屏幕中间M，移动到底部L 读取当前字符，并移动到本屏幕内下一次出现的地方 * 读取当前字符，并移动到本屏幕内上一次出现的地方 # 二、查找替换 光标向后查找关键字 #或者g# 光标向前查找关键字 或者g 当前行查找字符 fx, Fx, tx, Tx 基本替换 :s/s1/s2 （将下一个s1替换为s2） 全部替换 :%s/s1/s2 只替换当前行 :s/s1/s2/g 替换某些行 :n1,n2 s/s1/s2/g 搜索模式为 /string，搜索下一处为n，搜索上一处为N 制定书签 mx, 但是看不到书签标记，而且只能用小写字母 移动到某标签处 \\`x，1旁边的键 移动到上次编辑文件的位置 \\`. .代表一个任意字符 *代表一个或多个字符的重复 三、编辑操作 光标后插入a, 行尾插入A 后插一行插入o，前插一行插入O 删除字符插入s， 删除正行插入S 光标前插入i，行首插入I 删除一行dd，删除后进入插入模式cc或者S 删除一个单词dw，删除一个单词进入插入模式cw 删除一个字符x或者dl，删除一个字符进入插入模式s或者cl 粘贴p，交换两个字符xp，交换两行ddp 复制y，复制一行yy 撤销u，重做ctrl + r，重复. 智能提示 ctrl + n 或者 ctrl + p 删除motion跨过的字符，删除并进入插入模式 c{motion} 删除到下一个字符跨过的字符，删除并进入插入模式，不包括x字符 ctx 删除当前字符到下一个字符处的所有字符，并进入插入模式，包括x字符，cfx 删除motion跨过的字符，删除但不进入插入模式 d{motion} 删除motion跨过的字符，删除但不进入插入模式，不包括x字符 dtx 删除当前字符到下一个字符处的所有字符，包括x字符 dfx 如果只是复制的情况时，将12-17条中的c或d改为y 删除到行尾可以使用D或C 拷贝当前行 yy或者Y 删除当前字符 x 粘贴 p 可以使用多重剪切板，查看状态使用:reg，使用剪切板使用\"，例如复制到w寄存器，\"wyy，或者使用可视模式v\"wy 重复执行上一个作用使用. 使用数字可以跨过n个区域，如y3x，会拷贝光标到第三个x之间的区域，3j向下移动3行 在编写代码的时候可以使用]p粘贴，这样可以自动进行代码缩进 \\>> 缩进所有选择的代码, << 反缩进所有选择的代码 gd 移动到光标所处的函数或变量的定义处 K 在man里搜索光标所在的词 合并两行 J 若不想保存文件，而重新打开 :e! 若想打开新文件 :e filename，然后使用ctrl + &#94;进行文件切换 四.窗口操作 分隔一个窗口:split或者:vsplit 创建一个窗口:new或者:vnew 在新窗口打开文件:sf {filename} 关闭当前窗口:close 仅保留当前窗口:only 到左边窗口 ctrl + w, h 到右边窗口 ctrl + w, l 到上边窗口 ctrl + w, k 到下边窗口 ctrl + w, j 到顶部窗口 ctrl + w, t 到底部窗口 ctrl + w, b 五.宏操作 开始记录宏操作q[a-z]，按q结束，保存操作到寄存器[a-z]中 @[a-z]执行寄存器[a-z]中的操作 @@执行最近一次记录的宏操作 六、可视操作 进入块可视模式 ctrl + v 进入字符可视模式 v 进入行可视模式 V 删除选定的块 d 删除选定的块然后进入插入模式 c 在选中的块同是插入相同的字符 I<String>ESC 七.跳到声明 [[ 向前跳到顶格第一个{ [] 向前跳到顶格第一个} ]] 向后跳到顶格的第一个{ ]] 向后跳到顶格的第一个} [{ 跳到本代码块的开头 ]} 跳到本代码块的结尾 八.挂起操作 挂起Vim ctrl + z 或者 :suspend 查看任务 在shell中输入 jobs 恢复任务 fg [job number]（将后台程序放到前台）或者 bg [job number]（将前台程序放到后台） 执行shell命令 :!command 开启shell命令 :shell，退出该shell exit 保存vim状态 :mksession name.vim 恢复vim状态 :source name.vim 启动vim时恢复状态 vim -S name.vim vim配置 http://github.com/honmaple/vim 初始化文件 ~/vim/vimrc set nocompatible filetype off let g : is_mac = has ( 'macunix' ) let g : is_linux = has ( 'unix' ) && ! has ( 'macunix' ) && ! has ( 'win32unix' ) let g : is_windows = has ( 'win32' ) || has ( 'win64' ) if has ( \"gui_running\" ) let g : is_gui = 1 else let g : is_gui = 0 endif set rtp += $HOME / . vim / bundle / Vundle . vim function s : require ( file ) let l : file = $HOME . '/.vim/plugins/' . a : file . '.vim' if filereadable ( expand ( l : file )) execute 'source ' . fnameescape ( l : file ) else echom l : file . ' does not exist.' endif endfunction call vundle # begin () Plugin 'VundleVim/Vundle.vim' call vundle # end () \" required filetype plugin indent on \" required \" call plug#begin('~/.vim/plugged') \" call plug # end () let require_list = [ \\ 'init-gui' , \\ 'init-ui' , \\ 'init-editor' , \\ 'init-buffer' , \\ 'init-file' , \\ 'init-auto-insert' , \\ 'init-git' , \\ 'init-develop' , \\ 'init-python' , \\ 'init-html' , \\ 'init-text' , \\ 'init-keybind' ] for file in require_list call s : require ( file ) endfor 全局设置 ~/git/.vim/plugins/init-gui.vim \" 修改leader键 let mapleader = ',' let g:mapleader = ',' filetype on \"启用文件类型侦测 filetype plugin on \"针对不同的文件类型加载对应的插件 filetype plugin indent on \"启用缩进 syntax on \"代码高亮 syntax enable \"代码高亮 set t_Co=256 set mouse=a \"任何模式下启用鼠标 set mousehide \"Hide the mouse cursor while typing scriptencoding utf-8 \" 设置 退出vim后，内容显示在终端屏幕, 可以用于查看和复制, 不需要可以去掉 \" set t_ti= t_te= if has('clipboard') if has('unnamedplus') \" When possible use + register for copy-paste set clipboard=unnamed,unnamedplus else \" On mac and Windows, use * register for copy-paste set clipboard=unnamed endif endif set shortmess+=filmnrxoOtT \"去掉欢迎界面 set guifont=Monospace\\ 12 set viewoptions=folds,options,cursor,unix,slash \" Better Unix / Windows compatibility set virtualedit=onemore \" Allow for cursor beyond last character set history=1000 \" Store a ton of history (default is 20) \"set spell \"启用拼写检查 set hidden \" Allow buffer switching without saving set iskeyword-=. \" '.' is an end of word designator set iskeyword-=# \" '#' is an end of word designator set iskeyword-=- \" '-' is an end of word designator \"set backup \"设置备份文件 \"if has('persistent_undo') \" set undofile \" So is persistent undo ... \" set undolevels=1000 \" Maximum number of changes that can be undone \" set undoreload=10000 \" Maximum number lines to save for undo on a buffer reload \"endif set tabpagemax=15 \" Only show 15 tabs set showmode \" Display the current mode set cursorline \"高亮光标所在行 set cuc \"高亮光标所在列 set colorcolumn=80 highlight clear SignColumn \" SignColumn should match background highlight clear LineNr \" Current line number row will have same background color in relative mode \"highlight clear CursorLineNr \" Remove highlight color from current line number if has('cmdline_info') set ruler \" Show the ruler set rulerformat=%30(%=\\:b%n%y%m%r%w\\ %l,%c%V\\ %P%) \" A ruler on steroids set showcmd \" Show partial commands in status line and \" Selected characters/lines in visual mode endif if has('statusline') set laststatus=2 \"启用状态栏信息 set statusline=%<%f\\ \" Filename set statusline+=%w%h%m%r \" Options \" if !exists('g:override_bundles') \"set statusline+=%{fugitive#statusline()} \" Git Hotness \"endif set statusline+=\\ [%{&ff}/%Y] \" Filetype set statusline+=\\ [%{getcwd()}] \" Current dir set statusline+=%=%-14.(%l,%c%V%)\\ %p%% \" Right aligned file nav info endif set backspace=indent,eol,start \" Backspace for dummies set linespace=0 \" No extra spaces between rows set number \"显示行号 set relativenumber number \"设置相对行号 au FocusLost * :set norelativenumber number au FocusGained * :set relativenumber \" 插入模式下用绝对行号, 普通模式下用相对 autocmd InsertEnter * :set norelativenumber number autocmd InsertLeave * :set relativenumber function! NumberToggle() if(&relativenumber == 1) set norelativenumber number else set relativenumber endif endfunction set scrolloff=10 \"在上下移动光标时，光标的上方或下方至少会保留显示的行数 set showmatch \"高亮显示匹配的括号 set incsearch \"在输入要搜索的文字时，实时匹配 set hlsearch \"高亮搜索 \"set winminheight=0 \" Windows can be 0 line high set ignorecase \"搜索模式里忽略大小写 set smartcase \"如果搜索模式包含大写字符，不使用'ignorecase' 选项，只有在输入搜索模式并且打开 'ignorecase' 选项时才会使用 set wildmenu \" 增强模式中的命令行自动完成操作 set wildmode=list:longest,full \" Command <Tab> completion, list matches, then longest common part, then all. set whichwrap=b,s,h,l,<,>,[,] \" Backspace and cursor keys wrap too \"让Vim的补全菜单行为与一般IDE一致(参考VimTip1228) set completeopt=longest,menu set wildignore=*.o,*~,*.pyc,*.class \"set scrolljump=5 \" Lines to scroll when cursor leaves screen \"set scrolloff=3 \" Minimum lines to keep above and below cursor set list set listchars=tab:›\\ ,trail:•,extends:#,nbsp:. \" Highlight problematic whitespace set showcmd \"在状态栏显示正在输入的命令 set nowrap \"设置不自动换行 \"set autoindent \"打开自动缩进 set shiftwidth=4 \"换行时自动缩进宽度，可更改（宽度同tabstop） set expandtab \"将Tab键转换为空格 set tabstop=4 \"设置Tab键的宽度，可以更改，如：宽度为2 \"autocmd FileType haskell,rust setlocal nospell let g:FoldMethod = 0 fun! ToggleFold() if g:FoldMethod == 0 exe \"normal! zM\" let g:FoldMethod = 1 else exe \"normal! zR\" let g:FoldMethod = 0 endif endfun function! ToggleBG() let s:tbg = &background \" Inversion if s:tbg == \"dark\" set background=light else set background=dark endif endfunction \"set smartindent \"启用智能对齐方式 \"set shiftround \"缩进时，取整 \"set showtabline=1 \"显示标签 set smarttab \"指定按一次backspace就删除shiftwidth宽度 \"set foldmethod=indent \"indent 折叠方式 \"set foldmethod=syntax \"set foldenable \"启用折叠 set foldmethod=marker \" 启动 vim 时关闭折叠代码 set nofoldenable \"set matchtime=5 \"匹配括号高亮的时间（单位是十分之一秒） \"set autoread \"当文件在外部被修改，自动更新该文件 \"set autowrite \"自动保存 \" set vb t_vb= \"关闭提示音 \" 显示/隐藏菜单栏、工具栏、滚动条，可用 Ctrl + F11 切换 if g:is_gui winpos 100 10 \"指定窗口出现的位置，坐标原点在屏幕左上角 set guiheadroom=0 set lines=38 columns=120 set guioptions-=m set guioptions-=T set guioptions-=r set guioptions-=L nmap <silent> <c-F11> :if &guioptions =~# 'm' <Bar> \\set guioptions-=m <Bar> \\set guioptions-=T <Bar> \\set guioptions-=r <Bar> \\set guioptions-=L <Bar> \\else <Bar> \\set guioptions+=m <Bar> \\set guioptions+=T <Bar> \\set guioptions+=r <Bar> \\set guioptions+=L <Bar> \\endif<CR> endif UI设置 ~/.vim/plugins/init-ui.vim Plugin 'altercation/vim-colors-solarized' Plugin 'tomasr/molokai' \" Plugin 'spf13/vim-colors' Plugin 'bling/vim-airline' Plugin 'powerline/fonts' Plugin 'luochen1990/rainbow' Plugin 'Yggdroot/indentLine' Plugin 'liuchengxu/space-vim-dark' Plugin 'mhinz/vim-startify' if $TERM=~'cons25' colorscheme default elseif g:is_gui set background=dark \" let g:solarized_termcolors=256 \" let g:solarized_termtrans = 0 \" colorscheme solarized let g:molokai_original = 1 colorscheme molokai else set background=dark let g:solarized_termcolors=256 let g:solarized_termtrans = 0 \" colorscheme molokai colorscheme solarized endif \" indentLine { \" 用于显示对齐线 let g:indentLine_char = \"┊\" let g:indentLine_first_char = \"┊\" \" 色块宽度 \"let g:indent_guides_guide_size=1 \" 设置终端对齐线颜色，如果不喜欢可以将其注释掉采用默认颜色 let g:indentLine_color_term = 256 \" } \" vim-airline { \" let g:airline#extensions#tabline#enabled = 1 let g:airline_powerline_fonts=1 if !exists('g:airline_theme') let g:airline_theme = 'dark' endif \" } \" rainbow { let g:rainbow_active = 1 \" } 编辑器设置 ~/.vim/plugins/init-editor.vim Plugin 'tpope/vim-surround' Plugin 'jiangmiao/auto-pairs' Plugin 'vim-scripts/matchit.zip' Plugin 'gcmt/wildfire.vim' Plugin 'godlygeek/tabular' Plugin 'majutsushi/tagbar' Plugin 'kristijanhusak/vim-multiple-cursors' Plugin 'tpope/vim-commentary' Plugin 'Chiel92/vim-autoformat' Plugin 'thinca/vim-quickrun' \" tagbar { \"nmap tb :TlistClose<CR>:TagbarToggle<CR> let g:tagbar_width=20 \"设置窗口宽度 let g:tagbar_left=0 \"在左侧窗口中显示 let g:tagbar_compact=1 \"不显示帮助信息 \"tagbar_map_togglefold 打开tagbar变量 \"o\" \" set tags=./tags; \" 自动切换目录为当前编辑文件所在目录 \" au BufRead,BufNewFile,BufEnter * cd %:p:h \" } \" wildfire { let g:wildfire_objects = { \\ \"*\" : [\"i'\", 'i\"', \"i\\)\", \"i\\]\", \"i\\}\", \"ip\",\"it\"], \\ \"html,xml\" : [\"at\",\"i>\",'i\"',\"i\\)\"]} \" } \" vim-multiple-cursors { \" default mapping let g:multi_cursor_next_key='<c-n>' let g:multi_cursor_prev_key='<c-p>' let g:multi_cursor_skip_key='<c-x>' let g:multi_cursor_quit_key='<esc>' \" } \" Tabularize { \" 对齐 \" nmap <Leader>a= :Tabularize /&#94;[&#94;=]*\\zs=<CR> \" vmap <Leader>a= :Tabularize /&#94;[&#94;=]*\\zs=<CR> \" } \" quickrun { let g:quickrun_config = { \\ \"_\" : { \\ \"outputter\" : \"message\", \\ }, \\} let g:quickrun_no_default_key_mappings = 1 \" } Buffer设置 ~/.vim/plugins/init-buffer.vim Plugin 'bling/vim-bufferline' Plugin 'sjl/gundo.vim' \" gundo { set undodir=~/.vim/.cache/undo set undofile set undolevels=10 \" Maximum number of changes that can be undone set undoreload=10 \" Maximum number lines to save for undo on a buffer reload \" } 文件设置 ~/.vim/plugins/init-file.vim Plugin 'ctrlpvim/ctrlp.vim' Plugin 'tacahiroy/ctrlp-funky' Plugin 'dyng/ctrlsf.vim' Plugin 'scrooloose/nerdtree' Plugin 'jistr/vim-nerdtree-tabs' \" ctrlp { let g:ctrlp_working_path_mode = 'ra' let g:ctrlp_map = '<c-p>' let g:ctrlp_cmd = 'CtrlP' let g:ctrlp_custom_ignore = { \\ 'dir': '\\v[\\/]\\.(git|hg|svn|rvm)$', \\ 'file': '\\v\\.(exe|so|dll|zip|tar|tar.gz|pyc)$', \\ } if executable('ag') let s:ctrlp_fallback = 'ag %s --nocolor -l -g \"\"' elseif executable('ack-grep') let s:ctrlp_fallback = 'ack-grep %s --nocolor -f' elseif executable('ack') let s:ctrlp_fallback = 'ack %s --nocolor -f' else let s:ctrlp_fallback = 'find %s -type f' endif if exists(\"g:ctrlp_user_command\") unlet g:ctrlp_user_command endif let g:ctrlp_user_command = { \\ 'types': { \\ 1: ['.git', 'cd %s && git ls-files . --cached --exclude-standard --others'], \\ 2: ['.hg', 'hg --cwd %s locate -I .'], \\ }, \\ 'fallback': s:ctrlp_fallback \\ } \" } \" ctrlp-funky { \" CtrlP extensions let g:ctrlp_extensions = ['funky'] let g:ctrlp_funky_syntax_highlight = 1 \" } \" ctrlsf { \" 工程内查找文件内容,先安装ag /the_silver_searcher let g:ctrlsf_ackprg = 'ag' nmap <C-F>f <Plug>CtrlSFPrompt vmap <C-F>f <Plug>CtrlSFVwordPath vmap <C-F>F <Plug>CtrlSFVwordExec nmap <C-F>n <Plug>CtrlSFCwordPath nmap <C-F>p <Plug>CtrlSFPwordPath \" } \" NerdTree { \" 自动开启nerdtree let g:nerdtree_tabs_open_on_console_startup = 0 let g:nerdtree_tabs_open_on_gui_startup = 0 \"当打开vim且没有文件时自动打开NERDTree \" if !g:is_gui \" autocmd StdinReadPre * let s:std_in=1 \" autocmd VimEnter * if argc() == 0 && !exists(\"s:std_in\") | NERDTree | endif \" endif \"显示文件 let NERDTreeShowFiles=1 let NERDTreeIgnore=['\\.py[cd]$', '\\~$', '\\.swo$', '\\.swp$', '&#94;\\.git$', '&#94;\\.hg$', '&#94;\\.svn$', '\\.bzr$'] \"显示隐藏文件 let NERDTreeShowHidden=0 let NERDTreeChDirMode=0 let NERDTreeQuitOnOpen=1 let NERDTreeMouseMode=2 let NERDTreeKeepTreeInNewTab=1 let NERDTreeWinSize=22 let NERDTreeWinPos=\"left\" \"高亮显示当前文件或目录 let NERDTreeHightCursorline=1 \"不显示'Bookmarks' label 'Press ? for help' let NERDTreeMinimalUI=1 \" s/v 分屏打开文件 let g:NERDTreeMapOpenSplit = 's' let g:NERDTreeMapOpenVSplit = 'v' \" }","tags":"Linux","url":"https://honmaple.me/articles/2015/12/vim操作及配置.html","loc":"https://honmaple.me/articles/2015/12/vim操作及配置.html"},{"title":"一些vim插件的使用方法","text":"关于一些vim插件的使用方法，vim插件多，快捷键也多，记录一下 tpope/vim-surround 光标在 \"Hello world!\" 中时按下 cs\"' ，则会替换双引号为单引号： 'Hello world!' 继续按下 cs' ，则会替换单引号为 标签 <q> Hello world! </q> 按下 cst\" ，则回到初始的双引号： \"Hello world!\" 要删除符号，则按下 ds\" Hello world! 当光标在hello上时，按下 ysiw] ，则会变为 [Hello] world! 这个操作为其加上了包围符号。 总结： 1.删除包围符号的命令是 ds ,后面加的字符表示要删除的符号。比如： \"Hello *world!\" ds\" Hello world! 2.替换包围符号的命令是 cs ,命令后跟两个参数，分别是被替换的符号和需要使用的符号。比如 \"Hello *world!\" cs\"' 'Hello world!' 3.添加包围符号的命令是 ys ，命令后同样跟两个参数，第一个是一个vim\"动作\"（motion）或者是一个文本对象。（motion即vim动作，比如说 w 向后一个单词。文本对象简单的来说主要是来通过一些分隔符来标识一段文本，比如 iw 就是一个文本对象，即光标下的单词。） Hello w*orld! ysiw) Hello (world)! 另外： yss 命令可以用于整行操作，忽略中间的空格。 yS 和 ySS 还能让包围内容单独一行并且加上缩进。 4.添加包围符号还有个非常好用的：在可视模式v下，按下 S 后即可添加想要添加的包围符号了。 再说一个小技巧：在包围符号为括时，输入左括号 (或者{ ,则会留一个空格 Hello w*orld! ysiw( Hello ( world )!","tags":"linux","url":"https://honmaple.me/articles/2015/12/一些vim插件的使用方法.html","loc":"https://honmaple.me/articles/2015/12/一些vim插件的使用方法.html"},{"title":"丧钟为你而鸣","text":"没有人是自成一体、与世隔绝的孤岛， 每一个人都是广袤大陆的一部份。 如果海浪冲掉了一块岩石， 欧洲就减少。 如同一个海岬失掉一角， 如同你的朋友或者你自己的领地失掉一块。 每个人的死亡都是我的哀伤， 因为我是人类的一员。 所以，不要问丧钟为谁而鸣， 它就为你而鸣！","tags":"Life","url":"https://honmaple.me/articles/2015/12/丧钟为你而鸣.html","loc":"https://honmaple.me/articles/2015/12/丧钟为你而鸣.html"},{"title":"使用pelican搭建个人博客","text":"pelican介绍 Pelican是一个用Python语言编写的静态网站生成器，支持使用restructuredText和Markdown写文章，配置灵活，扩展性强 pelican安装 $ sudo pip install pelican 安装markdown $ sudo pip install markdown pelican使用 工具准备好了，接下来就开始使用 $ cd git $ mkdir pelican #建立一个文件夹(位置和名称随意，自己记得就行) $ cd pelican $ pelican-quickstart 显示 (也可以直接回车默认) Welcome to pelican-quickstart v3.4.0. This script will help you create a new Pelican-based website. Please answer the following questions so this script can generate the files needed by Pelican. > Where do you want to create your new web site? [.] > What will be the title of this web site? HonMaple > Who will be the author of this web site? honmaple > What will be the default language of this web site? [en] zh > Do you want to specify a URL prefix? e.g., http://example.com (Y/n) > What is your URL prefix? (see above example; no trailing slash) http://honmaple.github.io > Do you want to enable article pagination? (Y/n) > How many articles per page do you want? [10] > Do you want to generate a Fabfile/Makefile to automate generation and publishing? (Y/n) > Do you want an auto-reload & simpleHTTP script to assist with theme and site development? (Y/n) > Do you want to upload your website using FTP? (y/N) > Do you want to upload your website using SSH? (y/N) > Do you want to upload your website using Dropbox? (y/N) > Do you want to upload your website using S3? (y/N) > Do you want to upload your website using Rackspace Cloud Files? (y/N) > Do you want to upload your website using GitHub Pages? (y/N) Y > Is this your personal page (username.github.io)? (y/N) Y Done. Your new project is available at /home/git/pelican 接下来要设置pelicanconf.py和publishconf.py 具体可以看 官方帮助文档 或者参考 我的配置 查看目录 pelican/ ├── content ├── output ├── develop_server.sh ├── fabfile.py ├── Makefile ├── pelicanconf.py # Main settings file └── publishconf.py # Settings to use when ready to publish 现在可以开始写第一篇文章了 $ cd content $ mkdir articles pages extra impages $ cd articles $ vim hello.md 在文件开头输入下列内容 Title : 文章标题 Author : 作者 Date : 2015 - 10 - 15 Category : 文章类别 Tags : 标签 Summary : 概要内容 具体内容 保存退出后输入 $ cd ../../ #进入pelican文件夹下 $ make html 可以看实际效果 $ google-chrome-stable output/index.html 提交内容 编辑好内容并且 make html 后需要将内容push到github $ cd output/ $ git init $ git remote add origin git@github.com:honmaple/honmaple.github.io.git #关联远程仓库 $ git add . $ git commit -m \"My first blog by pelican\" 过几分钟后就可以看到内容了","tags":"python","url":"https://honmaple.me/articles/2015/12/使用pelican搭建个人博客.html","loc":"https://honmaple.me/articles/2015/12/使用pelican搭建个人博客.html"},{"title":"如何上传文件到服务器","text":"主要介绍通过scp和sftp上传文件到服务器，或者从服务器下载文件到本地,其主要命令 scp介绍 SCP的全称是secure copy (remote file copy program)，此命令是openssh-clients附带 的,它的作用就是在机器之间实现拷贝，且机器之间的传输完全是加密的。 scp简单操作 $ scp 帐号@主机:path/filename path/ #从服务器下载文件到本地 $ scp path/filename 帐号@主机:path/ #上传文件到服务器指定文件夹 选项与参数： -p ：保留原本档案的权限数据； -r ：复制来源为目录时，可以复制整个目录 (含子目录) -l ：可以限制传输的速度，单位为 Kb/s ，例如 [-l 100] 代表传输速限 100Kb/s scp实例 $ scp /home/xxx/test.md xxx@xxxx:~/ #在使用本地~/目录时，使用tab自动补全会转化为绝对路径 test.md 100 % 86 0 .1KB/s 00 :00 $ scp xxxx@xxxx:~/test.md /home/xxxx/web/ test.md 100 % 86 0 .1KB/s 00 :00 可以ssh到服务器查看是否有test.md文件,如果有那就成功了 sftp介绍 sftp是Secure File Transfer Protocol的缩写，安全文件传送协议。可以为传输文件提供 一种安全的加密方法。sftp 与 ftp 有着几乎一样的语法和功能。SFTP 为 SSH的一部分， 是一种传输档案至 Blogger 伺服器的安全方式。其实在SSH软件包中，已经包含了一个叫 作SFTP(Secure File Transfer Protocol)的安全文件传输子系统，SFTP本身没有单独的 守护进程，它必须使用sshd守护进程（端口号默认是22）来完成相应的连接操作，所以从 某种意义上来说，SFTP并不像一个服务器程序，而更像是一个客户端程序。SFTP同样是使 用加密传输认证信息和传输的数据，所以，使用SFTP是非常安全的。但是，由于这种传输 方式使用了加密/解密技术，所以传输效率比普通的FTP要低得多，如果您对网络安全性要 求更高时，可以使用SFTP代替FTP。 sftp基本操作 $ sftp xxxx@xxxx #类似ssh登陆 Connected to xxxx sftp> 针对服务器 sftp>cd /home/xxx/test/ 切换目录 sftp>ls #就是一些linux上的基本操作(ls mkdir chown rm mv) sftp>pwd #显示目前所在的目录 sftp>exit #退出 针对本地 sftp>lcd /home/xxx/test/ sftp>lls #在基本命令前加l(L小写l) sftp>lpwd #显示目前所在的目录 sftp>exit #退出 上传下载文件 上传 $ put ~/test.md /home/xxx/test/ # 将本机的test.md文件上传到服务器 下载 $ get /home/xxx/test/test.md ~/web/ #将服务器上的test.md下载到本地 这些命令对我来说就足够了，如果你还有其他要求 man 是最好的伙伴","tags":"linux","url":"https://honmaple.me/articles/2015/12/如何上传文件到服务器.html","loc":"https://honmaple.me/articles/2015/12/如何上传文件到服务器.html"},{"title":"愿能结芦山野","text":"愿能结芦山野，退而隐，依木闲坐，隐而狂。何时能，披发仗剑破门去，采菊南山香满襟","tags":"Life","url":"https://honmaple.me/articles/2015/12/愿能结芦山野.html","loc":"https://honmaple.me/articles/2015/12/愿能结芦山野.html"},{"title":"我是疯子","text":"1.我们生活的世界其实是别人的梦境，梦醒，便是这世界某个人一生的终结，入梦，便是一段新人生的开始，换句话说，就是轮回。至于其他人会不会时时做梦，不做分析。 2.一个平面上任意一点，它的反面必定有一点与之相对应。所以，是不是任意物体，都有一个与之对应的比它小，但其他完全相似的物体。而这个物体又有一个比它小，但完全相似的物体，以此无限循环下去。 3.这世界是由无数的轨道所构成（组成）的，像地球的自转和公转，如果将整个太阳系竖着看，不是正像一个在近似椭圆轨道上运动吗，近日点是顶点，远日点是最底点。 4.任何群居性生物都是一种整体的特殊的生物。如蚂蚁，和人类相比，蚁后是大脑，控制整个蚁群的活动，同时生育后代（细胞），工蚁是运输系统，兵蚁是组织防卫系统，把蚂蚁比做细胞，蚁群的活动整体上就是完整生物不同形式的活动。 5.人类是四维的虫子，任何生物都是四维的虫子，而所有非生物是三维虫子。人从出生起，用时间轴把一个人的一生串起来，就是一个以时间为长度的大虫子，例如从家到学校，所有的动作，所经过的路，等等，在不同时间里组成一个完整的个体，类似虫子的生物。 6.梦很熟悉，一个人所做的梦其实是前生或来生或今生经历的事或即将经历的事。 7.珍爱生命，远离镜子。我们怎么能保证自己是真实的，而不是生活在别人的镜子里，我坐在这里，镜子里还有一个我坐在那里也许他才是真实的，也许他也是假的，再加上一个镜子，就多了一个自己，到底哪一个才是真实的自己。 8.一个人或任意生物绝对不可能在不借用其他外力的情况下举起比自己重的物品。 理论推导:滑轮，绳子，一头物品，一头是人，绳子绝对竖直向下，物品比人重，人向下出力后绝对是人悬空，只有物品比人轻时，人才能使物品悬空（举起物品），相等情况下两者都不动或两者都悬空（平衡）。 像举重或蚂蚁举起比自身重的物品，实际上借用了摩擦力。 不过感觉不太对","tags":"Life","url":"https://honmaple.me/articles/2015/12/我是疯子.html","loc":"https://honmaple.me/articles/2015/12/我是疯子.html"},{"title":"摘抄一些经典语句","text":"民可使由之不可使知之 ――《论语·泰伯篇》 天下熙熙皆为利来，天下攘攘皆为利往。 ——司马迁 .....因为尽管沉默代替了交谈，言语却总是能保持它的力量，言语给予意义谋介, 它向那些愿意倾听的人们发出真相的宣告。 而真相是，这个国家，有些事情错得可怕，残暴、不公、歧视和镇压。你曾经有过反对的自由，可以说出你想说的话，但你现在有是审查制度和监视系统，强迫你随大流，强迫你服从。 这是怎么发生的？这要怪谁？当然, 有些人比大家更需要负上责任。 但是，老实说, 如果你要找人负责的话，你只需要照照镜子。 我知道你为什么这样做，我知道你害怕，谁不会呢？战争、恐怖事件、疾病。它们就像杂草的种子，用来摧毁你的理智，夺走你的常识，恐惧控制了你。你在慌乱中投向了元首先生，亚当沙特勒。 他向你许诺秩序，他向你许诺和平，所要求的不过是你无条件的服从和沉默。昨晚我决定结束这种沉默。昨晚我摧毁了老巴里街，以提醒这个国家忘记的事情.........以此提醒世界公平、正义和自由，不只是口头说说，它们是信念...... ――《V For Vendetta》 他们的目的不是为人民服务，而是控制人民为其服务……","tags":"Life","url":"https://honmaple.me/articles/2015/12/摘抄一些经典语句.html","loc":"https://honmaple.me/articles/2015/12/摘抄一些经典语句.html"},{"title":"无题","text":"记录一下随手写的诗，或者也不算诗 1. 大漠孤烟无边关 地上重楼忘记人 天涯海角难磨灭 怎奈何 这里有两句类似候补的最后一句 + 夜迹血月怎奈何 + 万千奴隶怎奈何 不想说明当时是怎样的心境,毕竟当时的心境是没有办法重来的 2. 星空太美，手机拍不了也放不下， 只能放在记忆里，看不清也摸不着， 最后只能慢慢流逝，留不了也抓不到 3. 焚舟破釜天， 唯命弃我岸上前， 惘顾神州情碎， 山水一念， 勿镜天下红尘， 在人间","tags":"Life","url":"https://honmaple.me/articles/2015/12/无题.html","loc":"https://honmaple.me/articles/2015/12/无题.html"},{"title":"辩证法与放屁","text":"第一堂课： 上课时，我放了一个屁——很普通的屁。既不很臭，当然也绝对不香。 可怕的是，教授正在讲辩证法。 \"请你自己对这个屁作一下判断，\"教授说，\"它好还是不好？\" 我只得说：\"不好。\" \"错了，\"教授说，\"任何事物都有矛盾组成，有它不好的一面，肯定有它好的一面。\" \"那么说它好也不对了？\"我问。 \"当然。\"教授说。 \"它既好又不好。\" \"错了。你只看到矛盾双方对立斗争的一面，没有看到他们统一的一面。\" 我只好认真看待这个严肃的问题，仔细想了想说：\"这个屁既好又不好，但不好的一面是主要的，处于主导地位。\" \"错了。你是用静止的观点看问题。矛盾的双方会相互转换，今天处于主导地位一面，明天一定处于次要地位。\" \"你是说明天全人类会为了我的这个屁欢呼雀跃吗？\" \"不尽如此，但不能否认这种发展趋势\" 我愣了好大一会儿，只得硬着头皮说：\"我的屁既好又不好，既不好又好。今天可能不好，明天一定会好。今天可能很好，明天也许会不好.\" 教授听得直摇头，说：\"这是彻底的怀疑论，不是辩证法的观点。\" 就这样，仅仅因为放了一个屁，我就成了一个怀疑论者。 教授接着讲课：\"辩证法的威力不仅在于能够轻而易举地驳斥任何观点，而且他能够轻易地为任何观点找到理论根据。\" \"可是我的屁就没有任何根据。\"我抗议道。 \"那是因为你没有找到，其实很简单，它是你肚子里矛盾双方对立统一的必然结果。\" 我哑口无言。 教授说：\"下面我们不谈屁，谈一个更复杂的问题：一个西瓜，一粒芝麻，无论你怎样选择，都有理论基础。\" 我赶紧说：\"我要捡起西瓜，丢了芝麻。\" \"很好。\"教授说，\"你抓住了主要矛盾，也就是说，你抓住了解决问题的关键。\" \"那我就捡起芝麻，丢掉西瓜。\" \"先有量变，才能达到质变。你解决问题的顺序十分正确。\" \"我既要西瓜，又要芝麻。\" \"即抓住主要矛盾，又不放过次要矛盾。你是用全面的眼光看问题\" \"我既要砸烂西瓜，又要踩碎芝麻。\" \"很好，你是用发展的眼光看问题。新事物就是对旧事物的否定。一切旧的事物必然灭亡。旧事物的灭亡是新事物产生的前提。\" \"我既要吃掉西瓜，又要砸烂西瓜。既要捡起芝麻，又要踩碎芝麻。可是，只有一个西瓜，一粒芝麻，怎么办？\" \"你这才算对辩证法入了门，重要的是：矛盾的双方不仅对立，而且有它统一的一面。你吃掉西瓜当然有它合理的一面，但你要砸烂西瓜，也并非不合理。只有将二者统一，才能进入更高层次的斗争。\" 我张口结舌，目瞪口呆：\"可是，你并没有解决我的问题。\" 教授笑着说：\"辩证法不解决任何问题，它的用途在于首先把人变成傻瓜——如果还有人不是傻瓜的话。\" \"你是说‘首先'？\"我问。 \"是对，然后再从傻瓜飞跃到学者。\"教授开始整理讲义，\"关于辩证法为什么不解决问题，如何把人变成傻瓜，以及怎样实现从傻瓜到学者的飞跃，这是下一节课的内容。\" 教授一蹦一跳，走出教室。 第二堂课： 教授说：\"下面我们讲一下辩证法的用途。我们要举一个更加复杂的例子：如何看待中国传统文化？\" 我说：\"那一定要用辩证的观点。\" \"对。我们有许多大牌的辩证法学者，他们会充分利用辩证法的三大规律，理论联系实际，旁征博引，纵横捭阖。下笔万言，紧绕主体。最后给你得出一个结论：要取其精华，去其糟粕——你佩服不佩服？\" \"是啊。辩证法不是很有用吗？\" \"以前我也这样认为。直到我见到一只丧家的野狗——它改变了我的看法。\" \"野狗？\"我莫名其妙。 \"是的。我家屋后有个垃圾堆，有一天来了一只丧家的野狗。它对其他东西看也不看，‘喀哧'一口，咬住一块骨头。\" \"这毫不奇怪，所有的狗都会这样。\"我说。 \"不错。问题是对于狗来说，这块骨头就是‘精华'，垃圾堆里除了骨头以外，还有砖头，铁块，破水桶等等糟粕，他为什么只要骨头这个精华呢？他怎么知道取其精华，去其糟粕？难道它已经充分理解了大牌学者们的论述了吗？\" \"好像不会。\" \"肯定不会，所以说大牌学者们通过精确的论述，得到的精妙结论，其实是连一只丧家的野狗早就知道的东西。既然如此，我们为什么还要为他们喝彩，对他们崇拜呢？\" \"是啊，为什么？\" \"唯一的解释就是：辩证法已经成功地把你变成了一个傻瓜。\" \"我明白了。\" \"你明白以后一定要问：你说的没用。取其精华，去其糟粕谁都知道。问题是什么是精华，什么是糟粕。\" \"对，看他怎么说。\" \"你难不倒他，他又会充分利用辩证法的三大规律，理论联系实际，旁征博引，纵横捭阖。下笔万言，紧绕主体。最后给你得出一个结论：具体问题，具体分析。高明不高明？\" \"是有道理。\" \"可是我认为：这不仅是无聊，无用的问题，已经近于无赖了。\" \"这怎么说？\" \"难道世界上有人会‘具体问题，抽象分析'吗？那只丧家的野狗，来到垃圾堆前，难道会象亚里斯多德一样，先把各种东西分门别类，搞清其内涵和外延，再通过归纳演绎，最后确定它是吃砖头还是吃骨头吗？这可能吗？\" \"不可能。那样的话，他连吃砖头都有可能。\" \"对，孺子可教。没有人会‘具体问题，抽象分析'，‘具体问题，具体分析'这句话，等于没说。不过辩证法学者倒是喜欢用抽象的方法，分析具体问题。因为辩证法是放之四海而皆准的普遍真理。所以如果你看到一只吃砖头的狗，千万不能小视，它可能是一个著名学者。\" 教授又收拾好讲义，说：\"辩证法的根本在于使用‘全面的，发展的，联系的'观点看问题。象所有的谎言一样，这话听起来很显真理。下一节课讲辩证法的渊源，以及它和形而上学的关系。\" 第三堂课： \"迄今为止，人类用三种方法研究这个世界。\"教授毫不客气，单刀直入，\"第一种是‘屠夫式'，大部分科学家都是这种方式。他们把世界割裂成极小的部分进行分析研究。研究生物的并不研究全部生物，有的只研究动物；研究动物的也不研究全部动物，有的只研究哺乳动物；研究哺乳动物的，有的只研究猴子；研究猴子的有的只研究猴子的尾巴。他们眼中只见树木，不见森林，是极其片面的观点。\" \"不是辩证法的观点。\"我说。 \"对，\"教授接着说，\"不仅如此，他们还尽量割裂研究对象与其他事物的联系，在尽量不受干扰的情况下，看看他到底是什么样子。科学家花费大量金钱建造实验室，而不在大街上做实验，主要原因就在于此。现在有些实验还要搞到太空里去做，连空气引力都要隔绝，可见，为了割裂事物之间的关系，这些科学家是不择手段的。\" 我说：\"与辩证法的观点相反。\" \"有说对了，但仍然不止于此，他们还不管一只猴子过去怎样，将来如何，只管拿来一刀宰掉，看看它肚子里都是什么东西。他们用的是彻底的静止观点。\" \"非常野蛮，而且十分笨拙。\" \"所以我把它叫做‘屠夫式'。但这是我们一切科学知识的基础和来源。没有这些人，也就没有任何科学。他们应该得到应有的尊重——他们的人格，才智和他们使用的方法，都应该得到尊重。\" \"有谁不尊重他们吗？\" \"有很多，你可能就是一个。\" \"此话怎讲？\" \"他们用的是孤立，静止，片面的方法，这种方法有一个名称，你们中学老师教过你们吗？\" \"叫形而上学，可那是个贬义词呀？\" \"是的，就叫形而上学，这就是过去全部的科学家，现在大部分科学家使用的方法。\" \"那为什么它是一个贬义词呢？\" \"因为它和辩证法不相容，而且针锋相对。有些人不仅自以为是正确的，而且断定其他人都是错的。奇怪的是，辩证法整天讲什么对立统一，形而上学来和辩证法对立，他却不肯同一，而是对形而上学采取一棍子打死的态度。\" \"我明白了。\" \"使用第二种方法的也是科学家，我称之为‘强盗式'，这种科学家更重要。 他们什么也不干，坐等形而上学的科学家研究出比较确切的成果，在此基础上综合升华。千千万万的科学家研究了万万千千的动物，植物，微生物以后，达尔文拿来一综合，就提出了进化论。\" \"这活倒很轻松。\" \"一点也不轻松，而且需要更高的聪明才智和更加宽阔的视野。爱因斯坦是其中最出色的一位。他的视野非常开阔，甚至研究过辩证法。但是他说辩证法对他的研究没有任何帮助。\" \"辩证法到底是干什么的呢？\" \"研究世界的第三种方法就是辩证法的方法，我称之为‘上帝式'的方法。也就是我们下一节课的内容。\" 最后一课： \"我被开除了，\"教授说，\"今天上最后一课。请先提问。\" 我说：\"有的同学说，你的观点有点偏激。\" \"他说对了，我不仅偏激，而且有错误。上一节课我就故意设置了一个常识性的错误，但是你们并没有给我提出来。现在我不得不把最重要的东西教给你们：没有谁是全部正确的，最多只是正确了一部分。如果世界是那只大象，我们就是那一群摸象的瞎子。我们想知道大象的样子，但是我们谁也不可能把这只大象摸完。我所有的瞎子加在一起也不可能，如果你的一生只能摸完大象的尾巴，你一定要认真去摸。如果你确信自己完全了解了这支尾巴，你一定要坚持自己的观点。 不要听见别人说大象像柱子或者象扇子就轻易改变自己的观点。偏激并不可怕，可怕的是听风就是雨，毫无自己的主见。如果你坚持的错了，没什么大不了，一定有更聪明的瞎子给你指出错误。科学就是这样在成千上万的错误中提取一个真理的学问。但是如果你对了，却没有坚持，世界就失去了一次前进的机会。 \"另外你要随时记住：无论你是对是错，你只是了解大象的一小部分。要听听别的瞎子怎么说。不能轻信，也不能不信。你别无选择，只有使用你的理性，它也许有许多不足，但却是你唯一可以信赖的东西。一个人的理性十分有限，许多人的理性却威力巨大。如果你不知道许多人的理性在那里，那么我告诉你——那就是科学。科学也有不足，以后一定要被突破。不过那需要许许多多比爱因斯坦更聪明的人，肯定不是你我。 \"理性，批判和宽容，就是我所说的最重要的东西。\" 这次我没有提问，也没有其他人提问。 \"言归正传，继续谈辩证法。\"教授只好自己接着说，\"辩证法也是个瞎子，但是他不摸象。\" \"他不想了解大象吗？\"我问。 \"他当然想了解大象，但是他认为摸象没有用，或者说作用不大。他认为大象在到处乱跑，还在不断地从小变大，而且与他周围的森林，地球，甚至太阳系，银河系有无限多的联系，用‘孤立，静止，片面'的形而上学观点徒劳无功，只有使用‘全面，发展，联系'的辩证法观点，才能搞清大象的样子。\" \"可是他连象都不摸，怎么全面，发展，联系呢？\" \"我不知道，鬼也不知道，只有上帝知道。所以我把它称为‘上帝式'的方法。辩证法最初在中国流行，伏羲八卦，阴阳五行，孔子的\"过犹不及\"，老子的\"反者道之动\"，《易经》\"一阴一阳谓之道\"，《黄帝内经》\"内外调和，邪不能侵\"统统都是辩证法。西方只有亚里斯多德提出过辩证法的雏形，既不全面，也不具体。恩格斯说他阐述了辩证法的基本原理，我不知道从何说起。不过这无关紧要，现代意义上的辩证法是从黑格尔开始的，这一点恩格斯和我，以及其他任何人，都不会有任何意见。\" \"你只说恩格斯，怎么不提马克思？\" \"马克思和辩证法关系不大。\" \"辩证唯物主义不是不是马克思主义的灵魂吗？\" \"我不同意这个观点，马克思早期写过一篇《神圣家族》，痛批黑格尔的\"泛逻辑论\"，泛逻辑论就包括辩证法。以后也没见他怎样说过辩证法。直到他最晚的哲学著作《资本论第二版跋》中，他才玩笑的说自己卖弄了辩证法。但是辩证法是什么，马克思终其一生，也没有回答过。\" \"那么辩证法怎样进入马克思主义的呢？\" \"完全是恩格斯的原因，从《反杜林论》到恩格斯致死不愿发表的《自然辩证法》，辩证法才成为马克思主义的所谓灵魂。这一点我和顾准的看法一样，马克思是不会同意‘辩证唯物主义'这个说法的。这完全是后人的需要。不过《反杜林论》是经过马克思同意的，这一点倒是事实。\" \"辩证法有哪些内容？\" \"首先是三大规律：第一，质量互变规律，来自黑格尔《逻辑学》第一部\"存在论\"。第二，矛盾统一规律，来自《逻辑学》第二部\"本质论\"。第三，否定之否定规律，来自《逻辑学》第三部\"理念论\"。这都是表面的东西，也就是马克思所说的\"神秘外形\"。它的根本在于用全面，发展，联系的观点看问题。它的实质是隐藏其后的两大主义：第一，真理一元论。反对真理的多元论和相对主义。这早已成为历史的垃圾。第二，真理不可分，局部事务的真理都是整体世界的一部分，孤立的研究发现不了这些真理。只有在森林中找树木，不能从树木开始研究森林。这不仅极其荒唐，而且毫不现实。\" \"为什么不现实？\" \"有个西方不败教授说得很好：事实充分证明，孤立的，静止的、片面地来研究事物的方法，在人类现有的认识情况下才是最好的方法论，才可能了解事物的本质。因为事物之间的联系千丝万缕，如果把所有的关联都考虑进去，就等于什么也干不成，就象我们老祖宗一样，只能抱着个\"太极生两仪，两仪生四象，\"这个思维懒怠症混日子。等到对事物的各种性状及规律有了较为详细的把握，再把它放到系统中进行非常谨慎的观察和研究。而中国人的传统思维是总想一口吃成个大胖子，一开始便从总体上提出本质的观点。这种带有原始思维特征的传统正与辩证法不谋而合，或者说辩证法只是中国古代思想方法的一种现代表述，中国人从来不缺少这种思维方式，需要补课的正是孤立的，静止的、片面地来研究事物的笨功夫。\" \"辩证法到底是怎么来的呢？\" \"你们中学教科书上是怎么讲的？\" \"好像是对客观世界，人类社会以及思维规律的全面正确的总结。\" \"这种说法极其荒唐，而且全然不顾任何事实。是彻底的误人子弟。第一，别说黑格尔活着的时候，就是在二十一世纪的今天，人类对客观世界仅仅了解一点，很小的一点。对人类社会只了解半点。对思维规律了解得半点也不到。一只大象我们只是了解了尾巴上的几个关节，腿上的几根毛，加上耳朵上一块皮而已，谈得上什么全面总结，正确总结？纯粹是说梦话。 \"第二，你们可以看一看《马克思恩格斯选集》第三卷469页第十二行到第十四行：\"黑格尔的著作中有一个广博的辩证法纲要，虽然它是从一个完全错误的出发点发展起来的。\"恩格斯在不止二十个地方说过，这个错误的出发点就是唯心主义。谁都知道，恩格斯所谓的辩证法原版照抄的来自黑格尔的《逻辑学》，如他自己所说，只不过\"打碎了黑格尔唯心主义的外壳，\"取了他\"辩证法的合理内核\"。你相信吗？人类从许许多多正确的出发点出发，都要走上弯路。而一个叫黑格尔的帝国教授，却可以从一个错误的出发点出发，\"全面地，正确地\"总结出客观世界，人类社会以及思维的全部正确规律。这是人说的话吗？ \"我绝不相信。就是再把我绑到新教徒的火刑柱上，把我烧死以前烤上两个小时，我仍然不相信！\" \"我也不相信。\"我小声说。 \"可是相信的人相当多。自从打碎了基督教的枷锁，辩证法是科学发展道路上的最大障碍。他把现代科学斥责为不入流的形而上学，机械论。使科学在一些地方停滞不前。二十世纪二十年代，前苏联科学院的一个院长，就因为要搞农作物的杂交改良而丢了脑袋。\" \"那为什么？\" \"因为杂交改良依据的是孟德尔－摩尔根理论，与辩证法格格不入。\" \"你很熟悉前苏联吗？\" \"我最熟悉的是中国，我在这里住了几十年。可是打别人头上的苍蝇更轻松。\" 我问：\"对于辩证法的进攻，科学是怎么反击的呢？\" \"西方哲学用实证主义，逻辑经验主义进行了反击。现代科学却默不做声。它只是不断地发展，生产出更多的粮食，钢铁，机器，以及人类除精神需要的一切。当这一切成为不可逆转的潮流的时候，辩证法才忽然发现，虽然它在骂别人，丢人的却是他自己。\" \"辩证法没有任何可取之处吗？\" \"有人说辩证法是一个早产的怪胎，虽然在人类认识的现阶段并不适用，但他整体的观点确实十分诱人。现代科学的整体论，有机论已经初具雏形。不过这不是对辩证法的回归，而是在科学自身的发展中，若隐若现地概括出的一些原则。真理一元论毕竟是难以接受的。科学从不放过任何一个发展的可能性，哪怕最微小的希望，也会有人付出百倍的努力。1984年，一大群名气很大的科学大师在美国成立了圣菲研究所（Santa Fe Institute），他们包括众多的诺贝尔奖获得者，是许多科学领域的顶尖人物，出钱的大老板也是赫赫有名——金融杀手索罗斯。它们的目标就是研究\"一元化理论\"的可能性。当然，他们谁也不会相信什么辩证法，那就不要研究\"一元化\"了。它们是用现代科学的方法探讨控制复杂的适应系统（CAS）的一般性原理。虽然我不相信他们会取得任何结果，但这是人类科学史上最大胆的尝试之一。我预祝他们成功——尽管那样会打破我的一切观念。\"（转载）","tags":"Life","url":"https://honmaple.me/articles/2015/12/辩证法与放屁.html","loc":"https://honmaple.me/articles/2015/12/辩证法与放屁.html"},{"title":"linux下C51开发","text":"开发工具mcu8051ide 下载地址 http://sourceforge.net/projects/mcu8051ide/ 安装sdcc $ sudo pacman -S sdcc 根据README需要下载的依赖 REQUIRED PACKAGES : (Without these packages this program WILL NOT run) Package min. Version Where it's available tcl 8.5.9 http://www.tcl.tk/software/tcltk/downloadnow84.html tk 8.5.9 http://www.tcl.tk/software/tcltk/downloadnow84.html itcl 3.4 http://sourceforge.net/projects/incrtcl tdom 0.8 http://tdom.github.com/ tkimg 1.3 http://sourceforge.net/projects/tkimg tcllib 1.6 http://sourceforge.net/projects/tcllib Tclx 8.4 http://tclx.sourceforge.net bwidget 1.8 http://sourceforge.net/projects/tcllib 注:安装必要依赖可以下载源码包自己编译安装,因为我的是Archlinux,以下命令以Arch为主 安装tcl,tk,tcllib,bwidget $ sudo pacman -S tcl tk tcllib bwidget 安装itcl,tdom,tkimg,tclx $ yaourt -Ss itcl aur/eclipse-dltk-itcl 5 .0-1 ( 3 ) incr Tcl IDE for Eclipse aur/itcl3 3 .4.1-1 [ installed ] ( 1 ) Provides the extra language support needed to build large Tcl/Tk applications, version 3 .4 $ yaourt -S itcl3 #具体步骤略过 $ yaourt -S tdom aur/tdom 0 .8.3-1 [ installed ] ( 13 ) A fast XML/DOM/XPath package for Tcl written in C aur/tdom-git 0 .8.3.r92.g363cbda-1 ( 4 ) A fast XML/DOM/XPath package for Tcl written in C $ yaourt -S tdom $ yaourt -Ss tkimg aur/tkimg 1 .4.2-1 [ installed ] ( 3 ) This package enhances Tk, adding support for many other Image formats: BMP, XBM, XPM, GIF, PNG, JPEG, TIFF and postscript. $ yaourt -S tkimg $ yaourt -Ss tclx aur/tclx 8 .4-4 ( 19 ) Provides OS primitives, file scanning, data records etc. for Tcl aur/tclxml 3 .2-2 ( 4 ) XML support for the Tcl scripting language aur/tclxosd 0 .20-2 ( 2 ) A Tcl bindings for libxosd ( On Screen Display ) $ yaourt -S tclx #这里发现一个问题，我tclx没有装但mcu8051ide也能正常使用 安装mcu8051ide 解压源码包,进入源码包目录 $ cmake . -DCMAKE_INSTALL_PREFIX = /opt/mcu8051ide/ #不要忘记\".\",后面的是要安装到的目录 $ make $ sudo make install 打开使用mcu8051ide $ cd /opt/bin $ ./mcu8051ide --check-libraries #检查依赖是否安装好 $ ./mcu8051ide #打开软件 ok,可以编写程序了 单片机烧写 使用软件gSTCISP 下载地址 安装gSTCISP 解压缩软件 $ cd gSTC-ISP $ ./configure --prefix = /opt/gSTCISP/ $ make #如果直接make会出错,cd 到src目录，vim Makefile将CFLAGS = -g -O2更改为CFLAGS = -g -O2 -I/usr/include/vte-0.0/ $ sudo make install 使用gSTCISP $ sudo gSTCISP #如果直接使用gSTCISP打开,烧写时会提示没有权限,请使用root权限打开 选择 /dev/ttyUSB0 (or 1) 和 4800 bauds 然后点击下载 ok,可以在linux系统下开发C51单片机了","tags":"linux","url":"https://honmaple.me/articles/2015/10/linux下C51开发.html","loc":"https://honmaple.me/articles/2015/10/linux下C51开发.html"},{"title":"git学习","text":"参考资料 廖雪峰Git教程 记忆一下主要内容： 安装git $ sudo dnf install git 安装后配置 $ git config --global user.name \"Your Name\" $ git config --global user.email \"email@example.com\" 创建版本库 $ mkdir git $ cd git $ mkdir \"目录名\" $ cd \"目录名\" $ git init #将该目录变成可用于git管理的仓库 git操作指令 $ git add filename #将文件添加到仓库 $ git commit -m \"注释内容\" #将文件提交到仓库，-m后面是本次提交的内容说明 $ git add file1.txt $ git add file2.txt file3.txt $ git commit -m \"add 3 files.\" #git commit 可以一次性提交多个文件 $ git status #查看仓库当前状态 $ git diff filename #查看文件修改状态 $ git log --pretty = oneline #查看提交日志 $ git reset --hard HEAD&#94; #从当前状态回退到上个版本状态 ，上上版本HEAD&#94;&#94;,100个上版本HEAD~100 $ git diff HEAD -- filename #查看工作区与版本库里的最新版本的区别 $ git checkout -- filename #让工作区文件回退到上次提交状态 $ git reset HEAD readme.txt #把暂存区的修改撤销掉 $ git rm filename #删除仓库文件 远程仓库 $ ssh-keygen -t rsa -C \"youremail@example.com\" #生成公钥与私钥 将公钥上传到到 GitHub 账户 保存好私钥 $ git remote add origin git@github.com:honmaple/vim.git #关联远程仓库 $ git push -u origin master #把本地库内容推送到远程库 $ git push origin master #以后提交本地内容只要输入这个命令就行 $ git clone git@github.com：honmaple/honmaple.git #从远程库克隆到本地 我这里出现问题(远程的commit比本地的commit要新),需要 $ git pull origin master","tags":"linux","url":"https://honmaple.me/articles/2015/08/git学习.html","loc":"https://honmaple.me/articles/2015/08/git学习.html"},{"title":"linux的一些操作命令","text":"一些linux下的基本操作命令，linux下命令太多，不可能完全记住，记个笔记还是有必要的 命令行快捷操作 ctrl + 左右键 :在单词间跳转 ctrl+a :跳到本行的行首 ctrl+e :跳到页尾 Ctrl+u ：删除当前光标前面的文字 ctrl+k ：删除当前光标后面的文字 Ctrl+L ：进行清屏操作 Ctrl+y :进行恢复删除做 Ctrl+w :删除光标前面的单词的字符 Alt – d ：由光标位置开始，往右删除单词。往行尾删 字符界面播放ascii视频 $ mplayer -vo caca MovieName 打开nvidia设置 $ optirun nvidia-settings -c :8 更新google禁用 GPG 签名检查 $ sudo dnf update google-chrome-stable* --nogpgcheck 字符界面使用鼠标 $ sudo dnf install gpm $ sudo service gpm start 新字体安装 字体目录下运行 $ mkfontscale $ mkfontdir $ fc-cache -fv ssh代理 $ ssh -qTfnN -D 7070 ~@~ 安装vimdoc ./vimcdoc.sh -i 安装 ./vimcdoc.sh -u 卸载 编译Youcompleteme $ ./install.sh --clang-completer vim安装bundle插件管理 $ git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle 挂载iso文件 $ sudo mount -o loop xxx.iso /mnt/123 $ sudo umount /mnt/123","tags":"linux","url":"https://honmaple.me/articles/2015/08/linux的一些操作命令.html","loc":"https://honmaple.me/articles/2015/08/linux的一些操作命令.html"},{"title":"fedora22成功安装bumblebee-nvidia","text":"参考fedora安装 bumblebee官方wiki 写在前面：安装前最好更新系统，安装内核头文件等，如果有多余旧内核先删除 安装驱动最好进入字符界面操作 有一些错误，现更正 将selinux设置为disabled # vim /etc/sysconfig/selinux 安装及必要的依赖 # dnf install -y libbsd-devel libbsd glibc-devel libX11-devel help2man autoconf git tar glib2 glib2-devel kernel-devel kernel-headers automake gcc gtk2-devel # dnf install VirtualGL # dnf install VirtualGL.i686 # 即使是在64位操作系统上，这个也是必装的 # dnf -y install http://install.linux.ncsu.edu/pub/yum/itecs/public/bumblebee/fedora22/noarch/bumblebee-release-1.2-1.noarch.rpm # dnf -y install bbswitch bumblebee # dnf -y install http://install.linux.ncsu.edu/pub/yum/itecs/public/bumblebee-nonfree/fedora22/noarch/bumblebee-nonfree-release-1.2-1.noarch.rpm # dnf -y install bumblebee-nvidia 安装完成后加入用户组 $ sudo usermod -a -G video username $ sudo usermod -a -G bumblebee username #username是用户名 启动必要服务 $ sudo systemctl enable dkms $ sudo systemctl enable bumblebeed 重启 $ reboot 测试bumblebee $ optirun glxgears -info | grep \"GL_VENDOR\"","tags":"linux","url":"https://honmaple.me/articles/2015/06/fedora22成功安装bumblebee-nvidia.html","loc":"https://honmaple.me/articles/2015/06/fedora22成功安装bumblebee-nvidia.html"},{"title":"fedora安装后设置","text":"记录一下，省得每次重装都要找（绝大多数转自网络) fedora22 发布后 dnf 代替了 yum 1.增加sudo用户组 $ su 转到root用户，输入密码 # visudo 在root ALL=(ALL) ALL下增加一行 yourname ALL=(ALL) ALL 如果不想每次输入密码更改为 yourname ALL=(ALL) NOPASSWD:ALL :wq #保存退出 exit #回到一般用户 2.备份的主题，图标,字体拷贝到home目录 $ cp -r files ~/.theme $ cp -r files ~/.icons $ cp -r files ~/.fonts $ sudo chmod -R 755 files ## 3. 启用RPM Fusion仓库 $ sudo rpm -Uhv http://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-22.noarch.rpm $ sudo rpm -Uhv http://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-22.noarch.rpm 4.使用 dnf 缓存与dnf 最快源 # vim /etc/dnf/dnf.conf 添加 keepcache=true 与 fastestmirror=true 5. 安装Flash播放器 32位系统 $ sudo rpm - ivh http : // linuxdownload . adobe . com / adobe - release / adobe - release - i386 - 1.0 - 1. noarch . rpm $ sudo rpm -- import / etc / pki / rpm - gpg / RPM - GPG - KEY - adobe - linux $ sudo dnf install flash - plugin 64位系统 $ sudo rpm - ivh http : // linuxdownload . adobe . com / adobe - release / adobe - release - x86_64 - 1.0 - 1. noarch . rpm $ sudo rpm -- import / etc / pki / rpm - gpg / RPM - GPG - KEY - adobe - linux $ sudo dnf install flash - plugin 6.安装解压缩插件 $ sudo yum install unrar unzip p7zip 7.安装gcc 和g++ $ sudo yum install gcc gcc-c++ 8.安装播放器 vlc视频播放器 $ sudo yum install vlc mplayer 音乐播放器 $ sudo yum install moc 歌词 osdlyrics 9.安装火狐 $ sudo yum install firefox 10.安装code::blocks $ sudo yum install codeblocks 11.开机默认进文本模式 $ sudo rm /etc/systemd/system/default.target $ sudo ln -sf /lib/systemd/system/multi-user.target /etc/systemd/system/default.target #文本模式 $ sudo ln -sf /lib/systemd/system/graphical.target /etc/systemd/system/default.target #图形模式 12.安装头文件 $ sudo yum install kernel-headers kernel-devel 13.一些必要的编译工具 $ sudo yum install cscope ctags pylint cmake clang gtk2-devel ncurses ncurses-devel 14.游戏 $ sudo yum install asciiquarium sl fortune oneko gnome-mines 扫雷 gnome-sudoku 数独 gnome-mahjongg 对对碰 15.输入法 $ sudo yum install fcitx fcitx-configtool fcitx-qt fcitx-sunpinyin 16.联网程序 $ sudo yum install w3m w3m-img bcloud uget git wget firefox google-chrome-stable 17.系统清理 $ sudo yum install bleachbit 18.图像与文字 $ sudo yum install wps gimp shotwell 19.其他 # vim /etc/sysconfig/selinux #selinux配置位置 # vim /etc/sysconfig/iptables #防火墙配置位置","tags":"linux","url":"https://honmaple.me/articles/2015/05/fedora安装后设置.html","loc":"https://honmaple.me/articles/2015/05/fedora安装后设置.html"},{"title":"《有敌相惜》","text":"是我让火起， 将你路烧尽， 换今日送你归去。 我是泪眼迷， 你却笑如昔， 问我：\"君为何沾衣？\" 原上的草还如来时离离， 我只说：\"不过触景生情。\" 你似了然道：\"愿再逢你。\" 我许你约定，愿天意答应。 十年里，你我也曾挥手支风批雨， 乾坤都在掌中握紧， 而如今，你我间还要问天意， 自君长别此去， 只剩我一人独行雪里。 你笑着问我：\"君为何沾衣？\" 我只说：\"不过触景生情。\" 你似了然道：\"愿再逢你。\" 我许你约定，愿天意答应。 十年里，你我也曾挥手支风批雨， 乾坤都在掌中握紧， 而如今，你我间还要问天意， 自君长别此去， 只剩我一人独行雪里。 纵马去，等背影藏在峰回路转里， 空山也听不见马蹄， 独留我，在这浩荡的乾坤里， 想起忘说一句： \"此生得识君，三生有幸\"。","tags":"Life","url":"https://honmaple.me/articles/2014/06/《有敌相惜》.html","loc":"https://honmaple.me/articles/2014/06/《有敌相惜》.html"},{"title":"《钢琴家》","text":"Can you hear what I'm saying? I'm telling you it's a disgrace! I can hear you! We let them take us to our death like sheep to the slaughter. Not so loud. Wh don't we attack them? There's half a million of us here. We could break out of the ghetto. At least we could die honorably, not as a stain on the face of history. Why are you so sure they're sending us to our death? I'm not sure! You know why I'm not sure? Because they didn't tell me. They're gonna wipe us all out. What do you want me to do? Do your want me to fight? To fight you need organization... He's right. What do you think I can do, fight them with my violin bow? The Germans will never squander a hug labor force like this. They're sending us to a labor camp. It's obvious. Oh, sure! Look at that cripple there. Look at the old people, the children. They're gonna work? Look at you? You gonna carry iron girders on your back? They're exterminating us. It won't take them long. We're 60,000 left out of half a million. Mostly young people. And this time we're gonna fight. We're in good shape, organized. We're prepared. If you need help, I... No one thought they'd hold out so long. I never should have come out. I should have stayed there and fought with them. stop that. It's over now. Just be proud it happened. My God, did they put up a fight. Yes, well. So did the Germans. They're in shock. They didn't expect it. Nobody expected it. Jews fighting back. Who would've thought? Well, what good did it do? What good? I'm surprised at you. They died with dignity, that's what good it did. And you know something else? Now the poles will rise. We're ready. We'll fight too. You'll see. 你听到我说的话吗？ 我告诉你这是一个耻辱 我在听！ 我们任凭他们把我们引向死亡 就像羔羊走向屠场 别这麽大声 我们何不攻击他们？ 我们有五十万人在这里 我们可以突破犹太人区重围 为什你这麽确定 他们会送我们下黄泉？ 我不确定！ 你知道为什麽我不能确定吗？ 因为他们没说过 他们要把我们彻底消灭 你希望我怎麽做？ 你要我抗争吗？ 抗争的话需要组织... 他说得没错 你认为我能做什麽？ 用我的小提琴弓抗争吗？ 德国人不会浪费 像这样庞大的劳动力量 很明显地他们正要把我们 送到劳动集中营 喔 当然！ 看看那个瘸子 看看这些老人跟小孩 他们也要工作？ 看看你，你要带着 背上的铁架一起去吗？ 他们想把我们赶尽杀绝 那用不着花太多时间 从50万人到现在 我们只剩下6万人 几乎都是年轻人 而这一次我们要反抗 我们状况良好 组织健全 我们已经准备好了 如果你需要援助 我... 没人想得到他们会持续这麽久 我不应该出来的 我应该留在那里跟他们对抗 停止 现在都结束了 你该骄傲它发生了 天哪 他们发起了抗争 是的 没错 德国人也是 他们非常震惊 他们没有预料到 没有人预料得到 犹太人反击了 有谁想得到？ 好吧 那有什麽好处？ 什麽好处？ 你真让我吃惊 他们尊严地死去 这就是它的好处 你还知道别的吗？ 现在波兰人要苏醒了 我们准备好了 我们也要抗战了 你知道吗？","tags":"Life","url":"https://honmaple.me/articles/2014/04/《钢琴家》.html","loc":"https://honmaple.me/articles/2014/04/《钢琴家》.html"},{"title":"随便写写——文化","text":"作为中国人，不应该死守文化，而是应该发展文化，否则就像今天看的电影，安禄山，龙脉等中国元素却被运用在外国电影中，而这，并不是文化的相互交融。大家想想我们中国的端午节，为什么国际社会就相信是源自棒子？除了棒子的据\"理\"力争（不要脸）外还有什么，是它一直在发展端午文化，一直发展到提起端午节自然而然地就想起它这个国家。而我们中国呢？就算对端午节的真正来历心知肚明，又能怎样？难道全世界地喊端午节是中国的，谁信？如果再不发展那些即将\"消失\"的文化，那么将来全世界都有中国文化的身影而全世界都没有人记得这些精粹来自中国。 拥有五千年古老且优秀历史的中华儿女们，在历史的长河中我们已经失去了太多太多优秀的文化，而大多数是由于战乱，这些我们无法阻止，但今天，生活在和平年代的今天，难道我们这些所谓的中华儿女就忍心看着自己的文化流向他国？就忍心中华祖先们经历五千年沉淀的文化就此消逝？不，中华民族的灵魂告诉我们，中华儿女不会让祖先的英灵埋没，中华儿女不会让祖先的精神消逝，中华儿女更不会白白地让祖先的文化流向他国。 发展文化已经刻不容缓","tags":"Life","url":"https://honmaple.me/articles/2013/03/随便写写——文化.html","loc":"https://honmaple.me/articles/2013/03/随便写写——文化.html"},{"title":"九阴真经","text":"上卷 总纲 天之道，损有余而补不足，是故虚胜实，不足胜有余。其意博，其理奥，其趣深，天地之象分，阴阳之候列，变化之由表，死生之兆彰，不谋而遗迹自同，勿约而幽明斯契，稽其言有微，验之事不忒，诚可谓至道之宗，奉生之始矣。假若天机迅发，妙识玄通，成谋虽属乎生知，标格亦资于治训，未尝有行不由送，出不由产者亦。然刻意研精，探微索隐，或识契真要，则目牛无全，故动则有成，犹鬼神幽赞，而命世奇杰，时时间出焉。 五藏六府之精气，皆上注于目而为之精。精之案为眼，骨之精为瞳子，筋之精为黑眼，血之精力络，其案气之精为白眼，肌肉之精为约束，裹撷筋骨血气之精而与脉并为系，上属于脑，后出于项中。故邪中于项，因逢其身之虚，其人深，则随眼系以入于脑，入手腼则脑转，脑转则引目系急，目系急则目眩以转矣。邪其精，其精所中不相比亦则精散，精散则视岐，视岐见两物。 阴极在六，何以言九。太极生两仪，天地初刨判。六阴已极，逢七归元太素，太素西方金德，阴之清纯，寒之渊源。 内功心法 第一重诀曰：子午卯酉四正时，归气丹田掌前推。面北背南朝天盘，意随两掌行当中。意注丹田一阳动，左右回收对两穴。拜佛合什当胸作，真气旋转贯其中。气行任督小周天，温养丹田一柱香。快慢合乎三十六，九阴神功第一重。每日子、午、卯、酉四正时，找一阴气重的地方，最好为四高中低。面北而坐，五心朝天，静心绝虑，意守丹田，到一阳初动之时，双手在胸前合什，指尖朝前。引丹田之气沿督脉上行，任脉下归丹田。如此待小周天三十六圈。由慢至快。气归丹田后，双掌前推，掌心向前，掌指朝天，气行两掌。双掌指下垂，掌指朝下，掌心朝下，迅速收回，左手掌心对准气海穴，右手掌心对准命门穴，真气随手式成螺旋状贯入气海、命门两穴。汇于丹田内。如此意守下丹田一柱香的时间。待此功练有一定功力，能收发自如，有抗寒之功时可修第二重。 第二重诀曰：极寒午时正，独坐寒冰床。**面朝北，气行小周天。五心朝天式，打开丹田门。寒气螺旋入，收发当自如。合和汇丹田，落雪雪不化。缩如一寒珠，雪落无化雪。扩为雾环身，九阴第二重。每日午时，找一极寒之地，面北背南，五心朝天，坐于寒冰床上（一种玉、一年四季都如寒冰一样）。今人练习可在冰或雪上练习，静心绝虑，启动周天三十六圈，意守丹田片刻，打开气海、命门两穴，分别成螺旋状入寒气，吸一柱香的时间后，关闭以上两穴，丹田内有一寒球再不停的旋转，越转越大，至到隔体三丈远，收回。如此反复八十一次，练到雪花落体而不化，放气时雪花距体三尺不落为功成。 第三重诀曰：法如第二重，阴阳互相克。意在修罡气，热火不侵法。阳中求真阴，九阴第三重。每日子时，找一极热之地，坐于火鼎之上（今人练习坐在铁板上，下面加火，应慢慢加热，以不能忍耐为度）。面北背南，五心朝天，静心绝虑，起动丹田寒气防止热气侵入，其方法就是第二重所练寒气用以抗热量。此乃\"真阳中求真阴\"。 第四重诀曰：法如第三重，阴合阴为生。同为修罡气，静流极之法。以阴练真阴，九阴第四重。不拘时间，找一静止不动的水池，五心朝天，坐于湖底，静心绝虑，水位不过脖子，运行丹田真气用以抗水之压力，其方法与第三重相同，待体入水，而衣不湿为成。然后找有流动河水中练，急流下练，而衣不湿为成。到此《九阴神功》成。如用掌把真气放出击人，就是催心掌。 第五重采气诀曰：采气不在气，口闭双目开。玄机在于目，神气乾鼎聚。此法为增进内力之法，用以目吸聚宇宙内的精气，主要是修炼双眼，使双眼在对敌时能求察分明，并有摄取敌人神魂之效。每日太阳将出之际，站于高处，双眼平视太阳，带双眼发热时，意念太阳之气由双目吸入汇于上丹田，吸汇到一定程度自天目穴射出，在由双眼收回，如此反复。 横空挪移 螺旋九影，左右挪移，其聊不为，以气行之，可幻化九影诱敌。如加九阴白骨爪其威力可增十倍。如何横空挪移可据个况自定，今公之二法以参考。 诀曰：左转一，左转半。右转一，右转半。左右转一为不一，横空旋较为太一。诀曰：左旋右旋天地旋，左踏右空平地旋。合手阴阳为上旋，右踏左空旋不为。虽为身法，实含玄理。须参照\"九阴行功诀曰\"进行，以防走火。习此功主要为子、午两时，其它时间亦可。必须选一处绝对安静，空气必须流畅。此功中的呼吸均为鼻吸鼻呼。习此功贵在持之以恒。功中会出现各种幻境，千万不可惧怕，顺其自然。练功中出现自然腾空，应顺其自然，千万不可妄加意念。 鬼狱阴风 此功属音波功，以音伤人，以音索魂，亦可以音布罡气，其威力无比，其音如地狱鬼吼，阴风阵阵，使人不攻自退，不寒而栗。 第一重：面北而坐，取五心朝天式，上身正直，虚灵顶劲，舌抵上腭，下颌微收，双目平视。双手于下丹田处成托式，即掌心向上，掌指相对，意守丹田一柱香，引真气自督脉、任脉行到中丹田，并在此汇聚成乒乓球大小的真气球，其色赤。口中默念，意念中丹田之真气化为波圈，若水纹之状。碰肤弹回，须反复重阳之数。 第二重：意大波圈，自内向外旋为散，自外向内旋为聚，散聚合适为阴阳平衡，阴阳平衡，万物之本。渐如虚空，与宇共振，法同上。 第三重：自然站立，双脚与肩同宽，双手自然放于两腿外侧，百会上顶，舌放平，双目平视，调整呼吸，意守丹田一柱香的时间，然后点头，吸气、收腹，口发鬼怪连音，同时意引丹田真气随声音向外扩散；抬头、呼气、口闭，意收回，真气归中丹田，如此反复。一点一抬，一上一下，上下起到，喉轮自开，开通喉轮魔音自现。 第四重：无相音罡，即音罡无形。其秒音无穷，可防敌护体，亦可以音控他人或给他人治病。其练法很简单，只需把\"九阴神功\"的\"先天真气\"与\"鬼狱阴风吼\"之音合二为一就可，具体练习方法可参照以上两法自悟，此不详述。 下卷 九阴白骨爪/九阴神爪 爪力无比，鬼气回荡，不攻自惧。其爪可使头骨成孔而不碎，爪心有强大的吸力可隔空取物或吸取他人功力，爪指有强大的透劲可隔空伤人。一收一放，一开一合，合乎武学大道之理。 第一重金丝手诀曰：面北背南朝天坐，气行任督贯大椎。意聚丹田一柱香，分支左右聚掌心。打开气海命门穴，气满冲贯十指爪。旋入阴气一坤炉，放收来回金丝手。凡习九阴白骨爪需先习九阴神功百日，于极阴之地，谷地为佳。面北背南，五心朝天坐于低处。双手放于膝上，手心朝下，意守丹田。开气海、命门，旋转吸入阴气汇于丹田。气顺任、督两脉上行汇于大椎穴，于右肩井穴入掌心，气满鼓支，掌起平胸。五指下垂，气贯入指，十指内扣、回拉，手丝为一。回气丹田，温养柱香。 第二重摄魂诀曰：打开丹田前后门，三昧磷火化无形。吸进鬼狱阴鬼精，阴功在此更为进。此法是一种极秘之法，可开通人的死生之谜，吸取鬼魂之气，同时亦可用此法吸他人功力元神。找一坟场，在半夜无人之时，面北背南，五心朝天，左掌心向上，大拇指扣小指其它三指伸直。左手立于胸前，掌心朝左，大拇指、中、无名、小指内扣，食指伸直，口念咒\"探地达摩，无相无上，摄阴摄魂，无畏无惧，阴阳合和，人鬼交战，吗咪呗咪‘口奄'\"三十六遍，一遍过于一遍，到最后一遍，只需\"吗咪呗咪‘口奄'\"。然后双手抬到头上方，合掌， 尖朝天，打开气海、命门两穴，从两穴内射出阴气，成螺旋型由小到大，如龙卷风一样把野魂卷入两穴汇于丹田，练习一柱香的时间后，开始炼熔。双掌放于膝上，掌心朝上，意守丹田中的无数阴魂被丹田阴气形成环状，封闭在内不能出来。意念丹田封魂球开始旋转，同时意念坟场突然起了无数磷火，用同样方法把磷火吸入丹田封魂球外圈，燃烧炼熔阴魂，由慢到快不停旋转，火由小到大，直到化尽为止。收功，温养丹田一柱香。如果用来吸取他人功力或元神其方法于上面同理。 第三重白骨练爪诀曰：白骨头上悬，幻化为二骨。悬九穴，左右手中擒。合和为阴珠，吸阴吸精鬼。齐汇坤炉内，回返丹炉内。面北背南，五心朝天，坐 坟场中，意守丹田片刻，意守自身前后有九座坟，突然裂开飞出九个头骨，这时意念打开气海、命门两穴，射出旋转真气由小到大，把九个头骨给悬起来，位于本人头顶上方左右，缓慢旋转。从每一个头骨的两眼射出一条红气线，分别射入百会、玉枕、膻中，左右肩井穴，灵台、气海、命门九大穴道中，并且在每个穴道中渐渐汇聚成一个球，然后这九个红球同时从任督两脉汇于丹田，意守丹田使之气化合。然后运气两掌贯足真气，由于反向力，双掌抬起平胸，在贯入十指，十指突然变爪，这时意念那九个头骨互相幻化，变为两个头骨于胸前方。掌心外突把两个头骨吸入掌中，随后十指内扣抓住头骨，放出真气把头骨抓成十个小孔，然后吸回真气，同时吸取头骨内的真气归于丹田。收功，温养丹田一柱香。至头骨隔空袭来抓成孔而骨不碎，九阴白骨爪成矣。练之此境界需配合外功练习即第四重。 第四重外功诀曰：气至丹田贯十指，倒行古树狸猫功。抓石打铁练指力，内外合修白骨功。平常把内气贯于十指用以隔空取物，在以十指抓，练硬物，所用之物应由轻到重，由近到远。在者可以倒立于树旁，双脚依树，然后用十指抓树缓缓上行，以练指力。此重应与第三重同练。 第五重练到第四重此功已成，此第五重为加深功夫，其阴毒程度更甚。用古时棺材、蝙蝠血、砒霜三种物体加水加热后，用以漫手，再练内外功，这样手上有剧毒，以此手伤人无救。 螺旋九影 《螺旋九影》为武林上乘轻功，集身法、步法、罡气于一体。可平地拔起数丈，亦可平空飞行万里，身体周围有一层自然罡气，可攻击外敌。练之上乘可幻化出九个身影，于佛门无上神功\"莲台九现\"有相同的功效。 第一重：室外练功，不准迎风，松去身体裹缠之物，活动一下全身关节，用意念放松全身筋、骨、肉、皮等。然后面北取五心朝天或盘坐，上身正直，虚灵顶劲，舌抵上腭，下微收，双目平视，双手掌心朝上，掌指相对，捧放于丹田处，意守丹田一柱香，接着双手轻轻向上捧，沿任脉路线至膻中穴处，双手变为捧莲花状即双手心相对，掌根相抵，掌指朝上，双手十指自然张开，接着上捧至头顶，同时缓慢吸气，意念随上捧之势，将大地之阴气由会阴穴成螺旋状吸入，经中脉上升以头顶百会穴成螺旋状射出；然后双手变掌心向下，并向下压到丹田处，同时呼气，意念随双手下压之势，将天上之云气螺旋状吸入百会穴，经中脉由会阴穴成螺旋状射出，如此反复。 第二重：第一式：面北而坐，功接上重，五心朝天，上身正直，虚灵顶劲，舌抵上腭，下颌微收，双目平视。双手轻轻提起，掌心朝下，掌指相对放于中脘穴处，双手中指间距离约为一掌宽，双肩下沉，双肘下坠，双臂要\"圆鼓\"。意念会阴穴射出螺旋状阴气把身体旋入地下，至到地极处。突然螺旋阴气收回，身体如弹簧一样被弹回地面。第二式：要领同。轻抬双手，掌心朝上，掌指相对，高举至头上方，双臂微曲，似曲非曲，似直非直，意念百会穴射出螺旋状阴气，如飞机之螺旋桨，把人身托起，飞到九重天方为极限。此时人体在天空飘浮，突然阴气收回，人从天空掉回地面。 第三重：在第二重第一式的基础上打开气海穴，命门穴射出螺旋状真气，环绕身体自左到右，意念身体随螺旋真气之力上升，或平空飞行。同时在练功中加入有外敌入侵，不能入或击伤之意，可同时练习环身罡气。 第四重：此为加深功夫，即在水中练习以上各功，要领同上。","tags":"Life","url":"https://honmaple.me/articles/2011/11/九阴真经.html","loc":"https://honmaple.me/articles/2011/11/九阴真经.html"},{"title":"彼岸花","text":"彼岸花 开一千年 落一千年 花叶永不相见 情不为因果 缘注定生死 彼岸花开 花开彼岸时 只一团火红 花开无叶 叶生无花 相念相情却不得相见 独自彼岸路 彼岸花永远在悠然绽放 此岸心唯有在此岸兀自彷徨 多少烟花事 尽付风雨间 多少尘世梦 尽随水东转 看不见的熄灭了 消失的记住了 开到荼靡 花逝了…… 留下的不过是一地花瓣……","tags":"Life","url":"https://honmaple.me/articles/2010/07/彼岸花.html","loc":"https://honmaple.me/articles/2010/07/彼岸花.html"}]};